[
    {
        "problemsName": " 3051.寻找数据科学家职位的候选人",
        "hardRate": "EASY",
        "passRate": "72.10%",
        "problemsUrl": "https://leetcode.cn/problems/find-candidates-for-data-scientist-position/",
        "solutionsUrl": "https://leetcode.cn/problems/find-candidates-for-data-scientist-position/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3052.最大化商品",
        "hardRate": "HARD",
        "passRate": "64.07%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-items/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-items/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3053.根据长度分类三角形",
        "hardRate": "EASY",
        "passRate": "58.09%",
        "problemsUrl": "https://leetcode.cn/problems/classifying-triangles-by-lengths/",
        "solutionsUrl": "https://leetcode.cn/problems/classifying-triangles-by-lengths/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3054.二叉树节点",
        "hardRate": "MEDIUM",
        "passRate": "78.38%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-nodes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3055.最高欺诈百分位数",
        "hardRate": "MEDIUM",
        "passRate": "59.60%",
        "problemsUrl": "https://leetcode.cn/problems/top-percentile-fraud/",
        "solutionsUrl": "https://leetcode.cn/problems/top-percentile-fraud/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3056.快照分析",
        "hardRate": "MEDIUM",
        "passRate": "56.19%",
        "problemsUrl": "https://leetcode.cn/problems/snaps-analysis/",
        "solutionsUrl": "https://leetcode.cn/problems/snaps-analysis/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3057.员工项目分配",
        "hardRate": "HARD",
        "passRate": "69.50%",
        "problemsUrl": "https://leetcode.cn/problems/employees-project-allocation/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-project-allocation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3058.没有共同朋友的朋友",
        "hardRate": "MEDIUM",
        "passRate": "47.62%",
        "problemsUrl": "https://leetcode.cn/problems/friends-with-no-mutual-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/friends-with-no-mutual-friends/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3059.找到所有不同的邮件域名",
        "hardRate": "EASY",
        "passRate": "69.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-unique-email-domains/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-unique-email-domains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3060.时间范围内的用户活动",
        "hardRate": "HARD",
        "passRate": "38.21%",
        "problemsUrl": "https://leetcode.cn/problems/user-activities-within-time-bounds/",
        "solutionsUrl": "https://leetcode.cn/problems/user-activities-within-time-bounds/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3061.计算滞留雨水",
        "hardRate": "HARD",
        "passRate": "76.15%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-trapping-rain-water/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-trapping-rain-water/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3062.链表游戏的获胜者",
        "hardRate": "EASY",
        "passRate": "78.79%",
        "problemsUrl": "https://leetcode.cn/problems/winner-of-the-linked-list-game/",
        "solutionsUrl": "https://leetcode.cn/problems/winner-of-the-linked-list-game/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3063.链表频率",
        "hardRate": "EASY",
        "passRate": "75.46%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-frequency/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3064.使用按位查询猜测数字 I",
        "hardRate": "MEDIUM",
        "passRate": "91.09%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-number-using-bitwise-questions-i/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-number-using-bitwise-questions-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3065.超过阈值的最少操作数 I",
        "hardRate": "EASY",
        "passRate": "89.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-i/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-i/solution",
        "problemsDesc": "<p>给你一个下标从 <b>0</b>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>一次操作中，你可以删除 <code>nums</code>&nbsp;中的最小元素。</p>\n\n<p>你需要使数组中的所有元素都大于或等于 <code>k</code>&nbsp;，请你返回需要的 <strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,11,10,1,3], k = 10\n<b>输出：</b>3\n<b>解释：</b>第一次操作后，nums 变为 [2, 11, 10, 3] 。\n第二次操作后，nums 变为 [11, 10, 3] 。\n第三次操作后，nums 变为 [11, 10] 。\n此时，数组中的所有元素都大于等于 10 ，所以我们停止操作。\n使数组中所有元素都大于等于 10 需要的最少操作次数为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,2,4,9], k = 1\n<b>输出：</b>0\n<b>解释：</b>数组中的所有元素都大于等于 1 ，所以不需要对 nums 做任何操作。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,2,4,9], k = 9\n<b>输出：</b>4\n<b>解释：</b>nums 中只有一个元素大于等于 9 ，所以需要执行 4 次操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n\t<li>输入保证至少有一个满足&nbsp;<code>nums[i] &gt;= k</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;存在。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3066.超过阈值的最少操作数 II",
        "hardRate": "MEDIUM",
        "passRate": "46.83%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你可以对&nbsp;<code>nums</code>&nbsp;执行一些操作，在一次操作中，你可以：</p>\n\n<ul>\n\t<li>选择 <code>nums</code>&nbsp;中 <strong>最小</strong> 的两个整数&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;。</li>\n\t<li>将&nbsp;<code>x</code> 和&nbsp;<code>y</code> 从&nbsp;<code>nums</code>&nbsp;中删除。</li>\n\t<li>将&nbsp;<code>min(x, y) * 2 + max(x, y)</code>&nbsp;添加到数组中的任意位置。</li>\n</ul>\n\n<p><b>注意，</b>只有当&nbsp;<code>nums</code>&nbsp;<strong>至少</strong> 包含两个元素时，你才可以执行以上操作。</p>\n\n<p>你需要使数组中的所有元素都 <strong>大于或等于</strong>&nbsp;<code>k</code>&nbsp;，请你返回需要的&nbsp;<strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><b>输入：</b>nums = [2,11,10,1,3], k = 10</p>\n\n<p><b>输出：</b>2</p>\n\n<p><b>解释：</b></p>\n\n<ol>\n\t<li>第一次操作中，我们删除元素 1 和 2 ，然后添加 <code>1 * 2 + 2</code> 到 <code>nums</code> 中，<code>nums</code> 变为 <code>[4, 11, 10, 3]</code> 。</li>\n\t<li>第二次操作中，我们删除元素 3 和 4 ，然后添加 <code>3 * 2 + 4</code> 到 <code>nums</code> 中，<code>nums</code> 变为 <code>[10, 11, 10]</code> 。</li>\n</ol>\n\n<p>此时，数组中的所有元素都大于等于 10 ，所以我们停止操作。</p>\n\n<p>可以证明使数组中所有元素都大于等于 10 需要的最少操作次数为 2 。</p>\n\n<p>&nbsp;</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><b>输入：</b>nums = [1,1,2,4,9], k = 20</p>\n\n<p><b>输出：</b>4</p>\n\n<p><b>解释：</b></p>\n\n<ol>\n\t<li>第一次操作后，<code>nums</code> 变为 <code>[2, 4, 9, 3]</code>。</li>\n\t<li>第二次操作后，<code>nums</code> 变为 <code>[7, 4, 9]</code>。</li>\n\t<li>第三次操作后，<code>nums</code> 变为 <code>[15, 9]</code>。</li>\n\t<li>第四次操作后，<code>nums</code> 变为 <code>[33]</code>。</li>\n</ol>\n\n<p>此时，<code>nums</code> 中的所有元素都大于等于 20 ，所以我们停止操作。</p>\n\n<p>可以证明使数组中所有元素都大于等于 20 需要的最少操作次数为 4 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n\t<li>输入保证答案一定存在，也就是说，在进行某些次数的操作后，数组中所有元素都大于等于&nbsp;<code>k</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3067.在带权树网络中统计可连接服务器对数目",
        "hardRate": "MEDIUM",
        "passRate": "72.72%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/solution",
        "problemsDesc": "<p>给你一棵无根带权树，树中总共有 <code>n</code>&nbsp;个节点，分别表示 <code>n</code>&nbsp;个服务器，服务器从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;编号。同时给你一个数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条双向边，边的权值为&nbsp;<code>weight<sub>i</sub></code>&nbsp;。再给你一个整数&nbsp;<code>signalSpeed</code>&nbsp;。</p>\n\n<p>如果两台服务器 <code>a</code>&nbsp;和 <code>b</code>&nbsp;是通过服务器 <code>c</code>&nbsp;<strong>可连接的</strong>，则：</p>\n\n<ul>\n\t<li><code>a &lt; b</code>&nbsp;，<code>a != c</code> 且&nbsp;<code>b != c</code>&nbsp;。</li>\n\t<li>从&nbsp;<code>c</code>&nbsp;到&nbsp;<code>a</code>&nbsp;的距离是可以被&nbsp;<code>signalSpeed</code>&nbsp;整除的。</li>\n\t<li>从&nbsp;<code>c</code>&nbsp;到&nbsp;<code>b</code>&nbsp;的距离是可以被&nbsp;<code>signalSpeed</code>&nbsp;整除的。</li>\n\t<li>从&nbsp;<code>c</code>&nbsp;到&nbsp;<code>b</code>&nbsp;的路径与从&nbsp;<code>c</code>&nbsp;到&nbsp;<code>a</code>&nbsp;的路径没有任何公共边。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>count</code>&nbsp;，其中&nbsp;<code>count[i]</code> 表示通过服务器&nbsp;<code>i</code>&nbsp;<strong>可连接</strong>&nbsp;的服务器对的&nbsp;<strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/21/example22.png\" style=\"width: 438px; height: 243px; padding: 10px; background: #fff; border-radius: .5rem;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\n<b>输出：</b>[0,4,6,6,4,0]\n<b>解释：</b>由于 signalSpeed 等于 1 ，count[c] 等于所有从 c 开始且没有公共边的路径对数目。\n在输入图中，count[c] 等于服务器 c 左边服务器数目乘以右边服务器数目。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/21/example11.png\" style=\"width: 495px; height: 484px; padding: 10px; background: #fff; border-radius: .5rem;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\n<b>输出：</b>[2,0,0,0,0,0,2]\n<b>解释：</b>通过服务器 0 ，有 2 个可连接服务器对(4, 5) 和 (4, 6) 。\n通过服务器 6 ，有 2 个可连接服务器对 (4, 5) 和 (0, 5) 。\n所有服务器对都必须通过服务器 0 或 6 才可连接，所以其他服务器对应的可连接服务器对数目都为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, weight<sub>i</sub>]</code><!-- notionvc: a2623897-1bb1-4c07-84b6-917ffdcd83ec --></li>\n\t<li><code>1 &lt;= weight<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= signalSpeed &lt;= 10<sup>6</sup></code></li>\n\t<li>输入保证&nbsp;<code>edges</code>&nbsp;构成一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3068.最大节点价值之和",
        "hardRate": "HARD",
        "passRate": "45.92%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-sum-of-node-values/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-sum-of-node-values/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code>&nbsp;个节点的 <strong>无向</strong>&nbsp;树，节点从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;编号。树以长度为 <code>n - 1</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的二维整数数组 <code>edges</code>&nbsp;的形式给你，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>u<sub>i</sub></code>&nbsp;和&nbsp;<code>v<sub>i</sub></code>&nbsp;之间有一条边。同时给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;和一个长度为 <code>n</code>&nbsp;下标从&nbsp;<strong>0</strong>&nbsp;开始的&nbsp;<strong>非负</strong>&nbsp;整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;表示节点 <code>i</code>&nbsp;的 <strong>价值</strong>&nbsp;。</p>\n\n<p>Alice&nbsp;想 <strong>最大化</strong>&nbsp;树中所有节点价值之和。为了实现这一目标，Alice 可以执行以下操作 <strong>任意</strong>&nbsp;次（<strong>包括</strong><strong>&nbsp;0 次</strong>）：</p>\n\n<ul>\n\t<li>选择连接节点&nbsp;<code>u</code>&nbsp;和&nbsp;<code>v</code>&nbsp;的边&nbsp;<code>[u, v]</code>&nbsp;，并将它们的值更新为：\n\n\t<ul>\n\t\t<li><code>nums[u] = nums[u] XOR k</code></li>\n\t\t<li><code>nums[v] = nums[v] XOR k</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 Alice 通过执行以上操作 <strong>任意次</strong>&nbsp;后，可以得到所有节点 <strong>价值之和</strong>&nbsp;的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012513.png\" style=\"width: 300px; height: 277px;padding: 10px; background: #fff; border-radius: .5rem;\" /></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\n<b>输出：</b>6\n<b>解释：</b>Alice 可以通过一次操作得到最大价值和 6 ：\n- 选择边 [0,2] 。nums[0] 和 nums[2] 都变为：1 XOR 3 = 2 ，数组 nums 变为：[1,2,1] -&gt; [2,2,2] 。\n所有节点价值之和为 2 + 2 + 2 = 6 。\n6 是可以得到最大的价值之和。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/09/screenshot-2024-01-09-220017.png\" style=\"padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 300px; height: 239px;\" /></p>\n\n<pre>\n<b>输入：</b>nums = [2,3], k = 7, edges = [[0,1]]\n<b>输出：</b>9\n<b>解释：</b>Alice 可以通过一次操作得到最大和 9 ：\n- 选择边 [0,1] 。nums[0] 变为：2 XOR 7 = 5 ，nums[1] 变为：3 XOR 7 = 4 ，数组 nums 变为：[2,3] -&gt; [5,4] 。\n所有节点价值之和为 5 + 4 = 9 。\n9 是可以得到最大的价值之和。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012641.png\" style=\"width: 600px; height: 233px;padding: 10px; background: #fff; border-radius: .5rem;\" /></p>\n\n<pre>\n<b>输入：</b>nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]\n<b>输出：</b>42\n<b>解释：</b>Alice 不需要执行任何操作，就可以得到最大价值之和 42 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= edges[i][0], edges[i][1] &lt;= n - 1</code></li>\n\t<li>输入保证&nbsp;<code>edges</code>&nbsp;构成一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3069.将元素分配到两个数组中 I",
        "hardRate": "EASY",
        "passRate": "73.41%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-elements-into-two-arrays-i/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-elements-into-two-arrays-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>1</strong> 开始、包含<strong> 不同 </strong>整数的数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p>你需要通过 <code>n</code> 次操作，将 <code>nums</code> 中的所有元素分配到两个数组 <code>arr1</code> 和 <code>arr2</code> 中。在第一次操作中，将 <code>nums[1]</code> 追加到 <code>arr1</code> 。在第二次操作中，将 <code>nums[2]</code> 追加到 <code>arr2</code> 。之后，在第 <code>i</code> 次操作中：</p>\n\n<ul>\n\t<li>如果 <code>arr1</code> 的最后一个元素 <strong>大于 </strong><code>arr2</code> 的最后一个元素，就将 <code>nums[i]</code> 追加到 <code>arr1</code> 。否则，将 <code>nums[i]</code> 追加到 <code>arr2</code> 。</li>\n</ul>\n\n<p>通过连接数组 <code>arr1</code> 和 <code>arr2</code> 形成数组 <code>result</code> 。例如，如果 <code>arr1 == [1,2,3]</code> 且 <code>arr2 == [4,5,6]</code> ，那么 <code>result = [1,2,3,4,5,6]</code> 。</p>\n\n<p>返回数组 <code>result</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>[2,3,1]\n<strong>解释：</strong>在前两次操作后，arr1 = [2] ，arr2 = [1] 。\n在第 3 次操作中，由于 arr1 的最后一个元素大于 arr2 的最后一个元素（2 &gt; 1），将 nums[3] 追加到 arr1 。\n3 次操作后，arr1 = [2,3] ，arr2 = [1] 。\n因此，连接形成的数组 result 是 [2,3,1] 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,4,3,8]\n<strong>输出：</strong>[5,3,4,8]\n<strong>解释：</strong>在前两次操作后，arr1 = [5] ，arr2 = [4] 。\n在第 3 次操作中，由于 arr1 的最后一个元素大于 arr2 的最后一个元素（5 &gt; 4），将 nums[3] 追加到 arr1 ，因此 arr1 变为 [5,3] 。\n在第 4 次操作中，由于 arr2 的最后一个元素大于 arr1 的最后一个元素（4 &gt; 3），将 nums[4] 追加到 arr2 ，因此 arr2 变为 [4,8] 。\n4 次操作后，arr1 = [5,3] ，arr2 = [4,8] 。\n因此，连接形成的数组 result 是 [5,3,4,8] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code>中的所有元素都互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3070.元素和小于等于 k 的子矩阵的数目",
        "hardRate": "MEDIUM",
        "passRate": "61.23%",
        "problemsUrl": "https://leetcode.cn/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> 和一个整数 <code>k</code>。</p>\n\n<p>返回包含 <code>grid</code> 左上角元素、元素和小于或等于 <code>k</code> 的 <strong><span data-keyword=\"submatrix\">子矩阵</span></strong>的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/01/example1.png\" style=\"padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>输入：</strong>grid = [[7,6,3],[6,6,1]], k = 18\n<strong>输出：</strong>4\n<strong>解释：</strong>如上图所示，只有 4 个子矩阵满足：包含 grid 的左上角元素，并且元素和小于或等于 18 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/01/example21.png\" style=\"padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>输入：</strong>grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\n<strong>输出：</strong>6\n<strong>解释：</strong>如上图所示，只有 6 个子矩阵满足：包含 grid 的左上角元素，并且元素和小于或等于 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length </code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 1000 </code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3071.在矩阵上写出字母 Y 所需的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "62.35%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-write-the-letter-y-on-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-write-the-letter-y-on-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的矩阵 <code>grid</code> ，其中 <code>n</code> 为奇数，且 <code>grid[r][c]</code> 的值为 <code>0</code> 、<code>1</code> 或 <code>2</code> 。</p>\n\n<p>如果一个单元格属于以下三条线中的任一一条，我们就认为它是字母 <strong>Y</strong> 的一部分：</p>\n\n<ul>\n\t<li>从左上角单元格开始到矩阵中心单元格结束的对角线。</li>\n\t<li>从右上角单元格开始到矩阵中心单元格结束的对角线。</li>\n\t<li>从中心单元格开始到矩阵底部边界结束的垂直线。</li>\n</ul>\n\n<p>当且仅当满足以下全部条件时，可以判定矩阵上写有字母 <strong>Y </strong>：</p>\n\n<ul>\n\t<li>属于 Y 的所有单元格的值相等。</li>\n\t<li>不属于 Y 的所有单元格的值相等。</li>\n\t<li>属于 Y 的单元格的值与不属于Y的单元格的值不同。</li>\n</ul>\n\n<p>每次操作你可以将任意单元格的值改变为 <code>0</code> 、<code>1</code> 或 <code>2</code> 。返回在矩阵上写出字母 Y 所需的 <strong>最少 </strong>操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/22/y2.png\" style=\"width: 461px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2,2],[1,1,0],[0,1,0]]\n<strong>输出：</strong>3\n<strong>解释：</strong>将在矩阵上写出字母 Y 需要执行的操作用蓝色高亮显示。操作后，所有属于 Y 的单元格（加粗显示）的值都为 1 ，而不属于 Y 的单元格的值都为 0 。\n可以证明，写出 Y 至少需要进行 3 次操作。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/22/y3.png\" style=\"width: 701px; height: 201px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\n<strong>输出：</strong>12\n<strong>解释：</strong>将在矩阵上写出字母 Y 需要执行的操作用蓝色高亮显示。操作后，所有属于 Y 的单元格（加粗显示）的值都为 0 ，而不属于 Y 的单元格的值都为 2 。\n可以证明，写出 Y 至少需要进行 12 次操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 49</code></li>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 2</code></li>\n\t<li><code>n</code> 为奇数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3072.将元素分配到两个数组中 II",
        "hardRate": "HARD",
        "passRate": "50.16%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>1</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p>\n\n<p>现定义函数 <code>greaterCount</code> ，使得 <code>greaterCount(arr, val)</code> 返回数组 <code>arr</code> 中<strong> 严格大于</strong> <code>val</code> 的元素数量。</p>\n\n<p>你需要使用 <code>n</code> 次操作，将 <code>nums</code> 的所有元素分配到两个数组 <code>arr1</code> 和 <code>arr2</code> 中。在第一次操作中，将 <code>nums[1]</code> 追加到 <code>arr1</code> 。在第二次操作中，将 <code>nums[2]</code> 追加到 <code>arr2</code> 。之后，在第 <code>i</code> 次操作中：</p>\n\n<ul>\n\t<li>如果 <code>greaterCount(arr1, nums[i]) &gt; greaterCount(arr2, nums[i])</code> ，将 <code>nums[i]</code> 追加到 <code>arr1</code> 。</li>\n\t<li>如果 <code>greaterCount(arr1, nums[i]) &lt; greaterCount(arr2, nums[i])</code> ，将 <code>nums[i]</code> 追加到 <code>arr2</code> 。</li>\n\t<li>如果 <code>greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i])</code> ，将 <code>nums[i]</code> 追加到元素数量较少的数组中。</li>\n\t<li>如果仍然相等，那么将 <code>nums[i]</code> 追加到 <code>arr1</code> 。</li>\n</ul>\n\n<p>连接数组 <code>arr1</code> 和 <code>arr2</code> 形成数组 <code>result</code> 。例如，如果 <code>arr1 == [1,2,3]</code> 且 <code>arr2 == [4,5,6]</code> ，那么 <code>result = [1,2,3,4,5,6]</code> 。</p>\n\n<p>返回整数数组 <code>result</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3,3]\n<strong>输出：</strong>[2,3,1,3]\n<strong>解释：</strong>在前两次操作后，arr1 = [2] ，arr2 = [1] 。\n在第 3 次操作中，两个数组中大于 3 的元素数量都是零，并且长度相等，因此，将 nums[3] 追加到 arr1 。\n在第 4 次操作中，两个数组中大于 3 的元素数量都是零，但 arr2 的长度较小，因此，将 nums[4] 追加到 arr2 。\n在 4 次操作后，arr1 = [2,3] ，arr2 = [1,3] 。\n因此，连接形成的数组 result 是 [2,3,1,3] 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,14,3,1,2]\n<strong>输出：</strong>[5,3,1,2,14]\n<strong>解释：</strong>在前两次操作后，arr1 = [5] ，arr2 = [14] 。\n在第 3 次操作中，两个数组中大于 3 的元素数量都是一，并且长度相等，因此，将 nums[3] 追加到 arr1 。\n在第 4 次操作中，arr1 中大于 1 的元素数量大于 arr2 中的数量（2 &gt; 1），因此，将 nums[4] 追加到 arr1 。\n在第 5 次操作中，arr1 中大于 2 的元素数量大于 arr2 中的数量（2 &gt; 1），因此，将 nums[5] 追加到 arr1 。\n在 5 次操作后，arr1 = [5,3,1,2] ，arr2 = [14] 。\n因此，连接形成的数组 result 是 [5,3,1,2,14] 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,3,3]\n<strong>输出：</strong>[3,3,3,3]\n<strong>解释：</strong>在 4 次操作后，arr1 = [3,3] ，arr2 = [3,3] 。\n因此，连接形成的数组 result 是 [3,3,3,3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3073.最大递增三元组",
        "hardRate": "MEDIUM",
        "passRate": "38.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-increasing-triplet-value/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-increasing-triplet-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3074.重新分装苹果",
        "hardRate": "EASY",
        "passRate": "70.84%",
        "problemsUrl": "https://leetcode.cn/problems/apple-redistribution-into-boxes/",
        "solutionsUrl": "https://leetcode.cn/problems/apple-redistribution-into-boxes/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>apple</code> 和另一个长度为 <code>m</code> 的数组 <code>capacity</code> 。</p>\n\n<p>一共有 <code>n</code> 个包裹，其中第 <code>i</code> 个包裹中装着 <code>apple[i]</code> 个苹果。同时，还有 <code>m</code> 个箱子，第 <code>i</code> 个箱子的容量为 <code>capacity[i]</code> 个苹果。</p>\n\n<p>请你选择一些箱子来将这 <code>n</code> 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的<strong> 最小</strong> 数量。</p>\n\n<p><strong>注意</strong>，同一个包裹中的苹果可以分装到不同的箱子中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>apple = [1,3,2], capacity = [4,3,1,5,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>使用容量为 4 和 5 的箱子。\n总容量大于或等于苹果的总数，所以可以完成重新分装。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>apple = [5,5,5], capacity = [2,4,2,7]\n<strong>输出：</strong>4\n<strong>解释：</strong>需要使用所有箱子。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == apple.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= m == capacity.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= apple[i], capacity[i] &lt;= 50</code></li>\n\t<li>输入数据保证可以将包裹中的苹果重新分装到箱子中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3075.幸福值最大化的选择方案",
        "hardRate": "MEDIUM",
        "passRate": "48.07%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-happiness-of-selected-children/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-happiness-of-selected-children/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>happiness</code> ，以及一个<strong> 正整数 </strong><code>k</code> 。</p>\n\n<p><code>n</code> 个孩子站成一队，其中第 <code>i</code> 个孩子的 <strong>幸福值</strong> 是<strong> </strong><code>happiness[i]</code> 。你计划组织 <code>k</code> 轮筛选从这 <code>n</code> 个孩子中选出 <code>k</code> 个孩子。</p>\n\n<p>在每一轮选择一个孩子时，所有<strong> 尚未 </strong>被选中的孩子的 <strong>幸福值 </strong>将减少 <code>1</code> 。注意，幸福值<strong> 不能 </strong>变成负数，且只有在它是正数的情况下才会减少。</p>\n\n<p>选择 <code>k</code> 个孩子，并使你选中的孩子幸福值之和最大，返回你能够得到的<strong> </strong><strong>最大值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>happiness = [1,2,3], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>按以下方式选择 2 个孩子：\n- 选择幸福值为 3 的孩子。剩余孩子的幸福值变为 [0,1] 。\n- 选择幸福值为 1 的孩子。剩余孩子的幸福值变为 [0] 。注意幸福值不能小于 0 。\n所选孩子的幸福值之和为 3 + 1 = 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>happiness = [1,1,1,1], k = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>按以下方式选择 2 个孩子：\n- 选择幸福值为 1 的任意一个孩子。剩余孩子的幸福值变为 [0,0,0] 。\n- 选择幸福值为 0 的孩子。剩余孩子的幸福值变为 [0,0] 。\n所选孩子的幸福值之和为 1 + 0 = 1 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>happiness = [2,3,4,5], k = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>按以下方式选择 1 个孩子：\n- 选择幸福值为 5 的孩子。剩余孩子的幸福值变为 [1,2,3] 。\n所选孩子的幸福值之和为 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == happiness.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= happiness[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3076.数组中的最短非公共子字符串",
        "hardRate": "MEDIUM",
        "passRate": "50.44%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-uncommon-substring-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-uncommon-substring-in-an-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>arr</code>&nbsp;，数组中有 <code>n</code>&nbsp;个 <b>非空</b>&nbsp;字符串。</p>\n\n<p>请你求出一个长度为 <code>n</code>&nbsp;的字符串数组&nbsp;<code>answer</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>answer[i]</code>&nbsp;是 <code>arr[i]</code>&nbsp;<strong>最短</strong>&nbsp;的子字符串，且它不是 <code>arr</code>&nbsp;中其他任何字符串的子字符串。如果有多个这样的子字符串存在，<code>answer[i]</code>&nbsp;应该是它们中字典序最小的一个。如果不存在这样的子字符串，<code>answer[i]</code>&nbsp;为空字符串。</li>\n</ul>\n\n<p>请你返回数组<em>&nbsp;</em><code>answer</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [\"cab\",\"ad\",\"bad\",\"c\"]\n<b>输出：</b>[\"ab\",\"\",\"ba\",\"\"]\n<b>解释：</b>求解过程如下：\n- 对于字符串 \"cab\" ，最短没有在其他字符串中出现过的子字符串是 \"ca\" 或者 \"ab\" ，我们选择字典序更小的子字符串，也就是 \"ab\" 。\n- 对于字符串 \"ad\" ，不存在没有在其他字符串中出现过的子字符串。\n- 对于字符串 \"bad\" ，最短没有在其他字符串中出现过的子字符串是 \"ba\" 。\n- 对于字符串 \"c\" ，不存在没有在其他字符串中出现过的子字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [\"abc\",\"bcd\",\"abcd\"]\n<b>输出：</b>[\"\",\"\",\"abcd\"]\n<b>解释：</b>求解过程如下：\n- 对于字符串 \"abc\" ，不存在没有在其他字符串中出现过的子字符串。\n- 对于字符串 \"bcd\" ，不存在没有在其他字符串中出现过的子字符串。\n- 对于字符串 \"abcd\" ，最短没有在其他字符串中出现过的子字符串是 \"abcd\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 20</code></li>\n\t<li><code>arr[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3077.K 个不相交子数组的最大能量值",
        "hardRate": "HARD",
        "passRate": "37.42%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-strength-of-k-disjoint-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-strength-of-k-disjoint-subarrays/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>正奇数</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p><code>x</code> 个子数组的能量值定义为&nbsp;<code>strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1</code> ，其中&nbsp;<code>sum[i]</code>&nbsp;是第 <code>i</code>&nbsp;个子数组的和。更正式的，能量值是满足&nbsp;<code>1 &lt;= i &lt;= x</code>&nbsp;的所有&nbsp;<code>i</code>&nbsp;对应的&nbsp;<code>(-1)<sup>i+1</sup> * sum[i] * (x - i + 1)</code>&nbsp;之和。</p>\n\n<p>你需要在 <code>nums</code>&nbsp;中选择 <code>k</code>&nbsp;个 <strong>不相交</strong><strong>子数组</strong>&nbsp;，使得&nbsp;<strong>能量值最大</strong>&nbsp;。</p>\n\n<p>请你返回可以得到的 <strong>最大</strong><strong>能量值</strong>&nbsp;。</p>\n\n<p><strong>注意</strong>，选出来的所有子数组&nbsp;<strong>不</strong>&nbsp;需要覆盖整个数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,-1,2], k = 3\n<b>输出：</b>22\n<b>解释：</b>选择 3 个子数组的最好方式是选择：nums[0..2] ，nums[3..3] 和 nums[4..4] 。能量值为 (1 + 2 + 3) * 3 - (-1) * 2 + 2 * 1 = 22 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [12,-2,-2,-2,-2], k = 5\n<b>输出：</b>64\n<b>解释：</b>唯一一种选 5 个不相交子数组的方案是：nums[0..0] ，nums[1..1] ，nums[2..2] ，nums[3..3] 和 nums[4..4] 。能量值为 12 * 5 - (-2) * 4 + (-2) * 3 - (-2) * 2 + (-2) * 1 = 64 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-1,-2,-3], k = 1\n<b>输出：</b>-1\n<b>解释：</b>选择 1 个子数组的最优方案是：nums[0..0] 。能量值为 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>1 &lt;= n * k &lt;= 10<sup>6</sup></code></li>\n\t<li><code>k</code> 是奇数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3078.矩阵中的字母数字模式匹配 I",
        "hardRate": "MEDIUM",
        "passRate": "56.52%",
        "problemsUrl": "https://leetcode.cn/problems/match-alphanumerical-pattern-in-matrix-i/",
        "solutionsUrl": "https://leetcode.cn/problems/match-alphanumerical-pattern-in-matrix-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3079.求出加密整数的和",
        "hardRate": "EASY",
        "passRate": "77.79%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-sum-of-encrypted-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-sum-of-encrypted-integers/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，数组中的元素都是&nbsp;<strong>正</strong>&nbsp;整数。定义一个加密函数&nbsp;<code>encrypt</code>&nbsp;，<code>encrypt(x)</code>&nbsp;将一个整数 <code>x</code>&nbsp;中 <strong>每一个</strong>&nbsp;数位都用 <code>x</code>&nbsp;中的&nbsp;<strong>最大</strong>&nbsp;数位替换。比方说&nbsp;<code>encrypt(523) = 555</code> 且&nbsp;<code>encrypt(213) = 333</code>&nbsp;。</p>\n\n<p>请你返回数组中所有元素加密后的 <strong>和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">nums = [1,2,3]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">6</span></p>\n\n<p><b>解释：</b>加密后的元素位&nbsp;<code>[1,2,3]</code>&nbsp;。加密元素的和为&nbsp;<code>1 + 2 + 3 == 6</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">nums = [10,21,31]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">66</span></p>\n\n<p><b>解释：</b>加密后的元素为&nbsp;<code>[11,22,33]</code>&nbsp;。加密元素的和为&nbsp;<code>11 + 22 + 33 == 66</code> 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3080.执行操作标记数组中的元素",
        "hardRate": "MEDIUM",
        "passRate": "47.10%",
        "problemsUrl": "https://leetcode.cn/problems/mark-elements-on-array-by-performing-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/mark-elements-on-array-by-performing-queries/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的正整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>同时给你一个长度为 <code>m</code>&nbsp;的二维操作数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [index<sub>i</sub>, k<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>一开始，数组中的所有元素都 <strong>未标记</strong>&nbsp;。</p>\n\n<p>你需要依次对数组执行 <code>m</code>&nbsp;次操作，第 <code>i</code>&nbsp;次操作中，你需要执行：</p>\n\n<ul>\n\t<li>如果下标&nbsp;<code>index<sub>i</sub></code>&nbsp;对应的元素还没标记，那么标记这个元素。</li>\n\t<li>然后标记&nbsp;<code>k<sub>i</sub></code>&nbsp;个数组中还没有标记的&nbsp;<strong>最小</strong>&nbsp;元素。如果有元素的值相等，那么优先标记它们中下标较小的。如果少于&nbsp;<code>k<sub>i</sub></code>&nbsp;个未标记元素存在，那么将它们全部标记。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组 <code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;次操作后数组中还没标记元素的&nbsp;<strong>和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">[8,3,0]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们依次对数组做以下操作：</p>\n\n<ul>\n\t<li>标记下标为&nbsp;<code>1</code>&nbsp;的元素，同时标记&nbsp;<code>2</code>&nbsp;个未标记的最小元素。标记完后数组为&nbsp;<code>nums = [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,<em><strong>1</strong></em>,2,3,1]</code>&nbsp;。未标记元素的和为&nbsp;<code>2 + 2 + 3 + 1 = 8</code>&nbsp;。</li>\n\t<li>标记下标为&nbsp;<code>3</code>&nbsp;的元素，由于它已经被标记过了，所以我们忽略这次标记，同时标记最靠前的&nbsp;<code>3</code>&nbsp;个未标记的最小元素。标记完后数组为&nbsp;<code>nums = [<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>2</strong></em>,3,<em><strong>1</strong></em>]</code>&nbsp;。未标记元素的和为&nbsp;<code>3</code>&nbsp;。</li>\n\t<li>标记下标为 <code>4</code>&nbsp;的元素，由于它已经被标记过了，所以我们忽略这次标记，同时标记最靠前的 <code>2</code>&nbsp;个未标记的最小元素。标记完后数组为&nbsp;<code>nums = [<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>1</strong></em>]</code>&nbsp;。未标记元素的和为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">nums = [1,4,2,3], queries = [[0,1]]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">[7]</span></p>\n\n<p><strong>解释：</strong>我们执行一次操作，将下标为&nbsp;<code>0</code>&nbsp;处的元素标记，并且标记最靠前的&nbsp;<code>1</code>&nbsp;个未标记的最小元素。标记完后数组为&nbsp;<code>nums = [<em><strong>1</strong></em>,4,<em><strong>2</strong></em>,3]</code>&nbsp;。未标记元素的和为&nbsp;<code>4 + 3 = 7</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= m &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>, k<sub>i</sub> &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3081.替换字符串中的问号使分数最小",
        "hardRate": "MEDIUM",
        "passRate": "34.52%",
        "problemsUrl": "https://leetcode.cn/problems/replace-question-marks-in-string-to-minimize-its-value/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-question-marks-in-string-to-minimize-its-value/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;。<code>s[i]</code>&nbsp;要么是小写英文字母，要么是问号&nbsp;<code>'?'</code>&nbsp;。</p>\n\n<p>对于长度为 <code>m</code>&nbsp;且 <strong>只</strong>&nbsp;含有小写英文字母的字符串 <code>t</code>&nbsp;，我们定义函数&nbsp;<code>cost(i)</code>&nbsp;为下标 <code>i</code>&nbsp;之前（也就是范围 <code>[0, i - 1]</code>&nbsp;中）出现过与&nbsp;<code>t[i]</code>&nbsp;<strong>相同</strong>&nbsp;字符出现的次数。</p>\n\n<p>字符串 <code>t</code>&nbsp;的&nbsp;<strong>分数</strong>&nbsp;为所有下标&nbsp;<code>i</code>&nbsp;的&nbsp;<code>cost(i)</code>&nbsp;之 <strong>和</strong>&nbsp;。</p>\n\n<p>比方说，字符串&nbsp;<code>t = \"aab\"</code>&nbsp;：</p>\n\n<ul>\n\t<li><code>cost(0) = 0</code></li>\n\t<li><code>cost(1) = 1</code></li>\n\t<li><code>cost(2) = 0</code></li>\n\t<li>所以，字符串&nbsp;<code>\"aab\"</code>&nbsp;的分数为&nbsp;<code>0 + 1 + 0 = 1</code>&nbsp;。</li>\n</ul>\n\n<p>你的任务是用小写英文字母&nbsp;<strong>替换</strong> <code>s</code>&nbsp;中 <strong>所有</strong> 问号，使 <code>s</code>&nbsp;的 <strong>分数</strong><strong>最小&nbsp;</strong>。</p>\n\n<p>请你返回替换所有问号<em>&nbsp;</em><code>'?'</code>&nbsp;之后且分数最小的字符串。如果有多个字符串的&nbsp;<strong>分数最小</strong>&nbsp;，那么返回字典序最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">s = \"???\" </span></p>\n\n<p><strong>输出：</strong>&nbsp;<span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">\"abc\" </span></p>\n\n<p><strong>解释：</strong>这个例子中，我们将 <code>s</code>&nbsp;中的问号&nbsp;<code>'?'</code>&nbsp;替换得到&nbsp;<code>\"abc\"</code>&nbsp;。</p>\n\n<p>对于字符串&nbsp;<code>\"abc\"</code>&nbsp;，<code>cost(0) = 0</code>&nbsp;，<code>cost(1) = 0</code>&nbsp;和&nbsp;<code>cost(2) = 0</code>&nbsp;。</p>\n\n<p><code>\"abc\"</code>&nbsp;的分数为&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>其他修改 <code>s</code>&nbsp;得到分数 <code>0</code>&nbsp;的字符串为&nbsp;<code>\"cba\"</code>&nbsp;，<code>\"abz\"</code>&nbsp;和&nbsp;<code>\"hey\"</code>&nbsp;。</p>\n\n<p>这些字符串中，我们返回字典序最小的。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">s = \"a?a?\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">\"abac\"</span></p>\n\n<p><strong>解释：</strong>这个例子中，我们将&nbsp;<code>s</code>&nbsp;中的问号&nbsp;<code>'?'</code>&nbsp;替换得到&nbsp;<code>\"abac\"</code>&nbsp;。</p>\n\n<p>对于字符串&nbsp;<code>\"abac\"</code>&nbsp;，<code>cost(0) = 0</code>&nbsp;，<code>cost(1) = 0</code>&nbsp;，<code>cost(2) = 1</code>&nbsp;和&nbsp;<code>cost(3) = 0</code>&nbsp;。</p>\n\n<p><code>\"abac\"</code>&nbsp;的分数为&nbsp;<code>1</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是小写英文字母，要么是&nbsp;<code>'?'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3082.求出所有子序列的能量和",
        "hardRate": "HARD",
        "passRate": "46.29%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-sum-of-the-power-of-all-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-sum-of-the-power-of-all-subsequences/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>一个整数数组的 <strong>能量</strong>&nbsp;定义为和 <strong>等于</strong>&nbsp;<code>k</code>&nbsp;的子序列的数目。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;中所有子序列的 <strong>能量和</strong>&nbsp;。</p>\n\n<p>由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> nums = [1,2,3], k = 3 </span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> 6 </span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>总共有&nbsp;<code>5</code>&nbsp;个能量不为 0 的子序列：</p>\n\n<ul>\n\t<li>子序列&nbsp;<code>[<u><em><strong>1</strong></em></u>,<u><em><strong>2</strong></em></u>,<u><em><strong>3</strong></em></u>]</code> 有&nbsp;<code>2</code>&nbsp;个和为&nbsp;<code>3</code>&nbsp;的子序列：<code>[1,2,<u><strong><em>3</em></strong></u>]</code> 和 <code>[<u><strong><em>1</em></strong></u>,<u><strong><em>2</em></strong></u>,3]</code>&nbsp;。</li>\n\t<li>子序列&nbsp;<code>[<u><em><strong>1</strong></em></u>,2,<u><em><strong>3</strong></em></u>]</code>&nbsp;有 <code>1</code>&nbsp;个和为&nbsp;<code>3</code>&nbsp;的子序列：<code>[1,2,<u><strong><em>3</em></strong></u>]</code>&nbsp;。</li>\n\t<li>子序列&nbsp;<code>[1,<u><em><strong>2</strong></em></u>,<u><em><strong>3</strong></em></u>]</code> 有&nbsp;<code>1</code>&nbsp;个和为&nbsp;<code>3</code>&nbsp;的子序列：<code>[1,2,<u><strong><em>3</em></strong></u>]</code>&nbsp;。</li>\n\t<li>子序列&nbsp;<code>[<u><em><strong>1</strong></em></u>,<u><em><strong>2</strong></em></u>,3]</code>&nbsp;有&nbsp;<code>1</code>&nbsp;个和为&nbsp;<code>3</code>&nbsp;的子序列：<code>[<u><strong><em>1</em></strong></u>,<u><strong><em>2</em></strong></u>,3]</code>&nbsp;。</li>\n\t<li>子序列&nbsp;<code>[1,2,<u><em><strong>3</strong></em></u>]</code>&nbsp;有&nbsp;<code>1</code>&nbsp;个和为&nbsp;<code>3</code>&nbsp;的子序列：<code>[1,2,<u><strong><em>3</em></strong></u>]</code>&nbsp;。</li>\n</ul>\n\n<p>所以答案为&nbsp;<code>2 + 1 + 1 + 1 + 1 = 6</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> nums = [2,3,3], k = 5 </span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> 4 </span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>总共有&nbsp;<code>3</code>&nbsp;个能量不为 0 的子序列：</p>\n\n<ul>\n\t<li>子序列&nbsp;<code>[<u><em><strong>2</strong></em></u>,<u><em><strong>3</strong></em></u>,<u><em><strong>3</strong></em></u>]</code>&nbsp;有 2 个子序列和为&nbsp;<code>5</code>&nbsp;：<code>[<u><strong><em>2</em></strong></u>,3,<u><strong><em>3</em></strong></u>]</code> 和&nbsp;<code>[<u><strong><em>2</em></strong></u>,<u><strong><em>3</em></strong></u>,3]</code>&nbsp;。</li>\n\t<li>子序列&nbsp;<code>[<u><em><strong>2</strong></em></u>,3,<u><em><strong>3</strong></em></u>]</code>&nbsp;有 1 个子序列和为&nbsp;<code>5</code>&nbsp;：<code>[<u><strong><em>2</em></strong></u>,3,<u><strong><em>3</em></strong></u>]</code>&nbsp;。</li>\n\t<li>子序列&nbsp;<code>[<u><em><strong>2</strong></em></u>,<u><em><strong>3</strong></em></u>,3]</code>&nbsp;有 1 个子序列和为 <code>5</code>&nbsp;：<code>[<u><strong><em>2</em></strong></u>,<u><strong><em>3</em></strong></u>,3]</code>&nbsp;。</li>\n</ul>\n\n<p>所以答案为&nbsp;<code>2 + 1 + 1 = 4</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> nums = [1,2,3], k = 7 </span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> 0 </span></p>\n\n<p><strong>解释：</strong>不存在和为 <code>7</code>&nbsp;的子序列，所以 <code>nums</code>&nbsp;的能量和为&nbsp;<code>0</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3083.字符串及其反转中是否存在同一子字符串",
        "hardRate": "EASY",
        "passRate": "76.23%",
        "problemsUrl": "https://leetcode.cn/problems/existence-of-a-substring-in-a-string-and-its-reverse/",
        "solutionsUrl": "https://leetcode.cn/problems/existence-of-a-substring-in-a-string-and-its-reverse/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你判断字符串 <code>s</code> 是否存在一个长度为 <code>2</code> 的子字符串，在 <code>s</code> 反转后的字符串中也出现。</p>\n\n<p>如果存在这样的子字符串，返回 <code>true</code>；如果不存在，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">s = \"leetcode\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">true</span></p>\n\n<p><strong>解释：</strong>子字符串 <code>\"ee\"</code> 的长度为 <code>2</code>，它也出现在 <code>reverse(s) == \"edocteel\"</code> 中。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">s = \"abcba\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">true</span></p>\n\n<p><strong>解释：</strong>所有长度为 <code>2</code> 的子字符串 <code>\"ab\"</code>、<code>\"bc\"</code>、<code>\"cb\"</code>、<code>\"ba\"</code> 也都出现在 <code>reverse(s) == \"abcba\"</code> 中。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">s = \"abcd\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">false</span></p>\n\n<p><strong>解释：</strong>字符串 <code>s</code> 中不存在满足「在其反转后的字符串中也出现」且长度为 <code>2</code> 的子字符串。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li>字符串 <code>s</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3084.统计以给定字符开头和结尾的子字符串总数",
        "hardRate": "MEDIUM",
        "passRate": "52.90%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-starting-and-ending-with-given-character/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-starting-and-ending-with-given-character/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符 <code>c </code>。返回在字符串 <code>s</code> 中并且以 <code>c</code> 字符开头和结尾的<span data-keyword=\"substring-nonempty\">非空子字符串</span>的总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">s = \"abada\", c = \"a\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">6</span></p>\n\n<p><strong>解释：</strong>以 <code>\"a\"</code> 开头和结尾的子字符串有： <code>\"<strong><u>a</u></strong>bada\"</code>、<code>\"<u><strong>aba</strong></u>da\"</code>、<code>\"<u><strong>abada</strong></u>\"</code>、<code>\"ab<u><strong>a</strong></u>da\"</code>、<code>\"ab<u><strong>ada</strong></u>\"</code>、<code>\"abad<u><strong>a</strong></u>\"</code>。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">s = \"zzz\", c = \"z\"</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">6</span></p>\n\n<p><strong>解释：</strong>字符串 <code>s</code> 中总共有 <code>6</code> 个子字符串，并且它们都以 <code>\"z\"</code> 开头和结尾。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>c</code> 均由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3085.成为 K 特殊字符串需要删除的最少字符数",
        "hardRate": "MEDIUM",
        "passRate": "41.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-k-special/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-k-special/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> 和一个整数 <code>k</code>。</p>\n\n<p>如果&nbsp;<code>|freq(word[i]) - freq(word[j])| &lt;= k</code> 对于字符串中所有下标 <code>i</code> 和 <code>j</code>&nbsp; 都成立，则认为 <code>word</code> 是 <strong>k 特殊字符串</strong>。</p>\n\n<p>此处，<code>freq(x)</code> 表示字符 <code>x</code> 在 <code>word</code> 中的<span data-keyword=\"frequency-letter\">出现频率</span>，而 <code>|y|</code> 表示 <code>y</code> 的绝对值。</p>\n\n<p>返回使 <code>word</code> 成为 <strong>k 特殊字符串</strong> 需要删除的字符的最小数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">word = \"aabcaba\", k = 0</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">3</span></p>\n\n<p><strong>解释：</strong>可以删除 <code>2</code> 个 <code>\"a\"</code> 和 <code>1</code> 个 <code>\"c\"</code> 使 <code>word</code> 成为 <code>0</code> 特殊字符串。<code>word</code> 变为 <code>\"baba\"</code>，此时 <code>freq('a') == freq('b') == 2</code>。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">word = \"dabdcbdcdcd\", k = 2</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">2</span></p>\n\n<p><strong>解释：</strong>可以删除 <code>1</code> 个 <code>\"a\"</code> 和 <code>1</code> 个 <code>\"d\"</code> 使 <code>word</code> 成为 <code>2</code> 特殊字符串。<code>word</code> 变为 <code>\"bdcbdcdcd\"</code>，此时 <code>freq('b') == 2</code>，<code>freq('c') == 3</code>，<code>freq('d') == 4</code>。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">word = \"aaabaaa\", k = 2</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">1</span></p>\n\n<p><strong>解释：</strong>可以删除<strong> </strong>1 个 <code>\"b\"</code> 使 <code>word</code> 成为 <code>2</code>特殊字符串。因此，<code>word</code> 变为 <code>\"aaaaaa\"</code>，此时每个字母的频率都是 <code>6</code>。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3086.拾起 K 个 1 需要的最少行动次数",
        "hardRate": "HARD",
        "passRate": "43.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二进制数组 <code>nums</code>，其长度为 <code>n</code> ；另给你一个 <strong>正整数 </strong><code>k</code> 以及一个 <strong>非负整数 </strong><code>maxChanges</code> 。</p>\n\n<p>Alice 在玩一个游戏，游戏的目标是让&nbsp;Alice 使用 <strong>最少 </strong>数量的 <strong>行动 </strong>次数从 <code>nums</code> 中拾起 <code>k</code> 个 1 。游戏开始时，Alice 可以选择数组 <code>[0, n - 1]</code> 范围内的任何索引&nbsp;<code>aliceIndex</code> 站立。如果 <code>nums[aliceIndex] == 1</code> ，Alice 会拾起一个 1 ，并且 <code>nums[aliceIndex]</code> 变成<code>0</code>（这<strong> 不算 </strong>作一次行动）。之后，Alice 可以执行 <strong>任意数量</strong> 的 <strong>行动</strong>（<strong>包括</strong><strong>零次</strong>），在每次行动中&nbsp;Alice 必须 <strong>恰好 </strong>执行以下动作之一：</p>\n\n<ul>\n\t<li>选择任意一个下标 <code>j != aliceIndex</code> 且满足 <code>nums[j] == 0</code> ，然后将 <code>nums[j]</code> 设置为 <code>1</code> 。这个动作最多可以执行 <code>maxChanges</code> 次。</li>\n\t<li>选择任意两个相邻的下标 <code>x</code> 和 <code>y</code>（<code>|x - y| == 1</code>）且满足 <code>nums[x] == 1</code>, <code>nums[y] == 0</code> ，然后交换它们的值（将 <code>nums[y] = 1</code> 和 <code>nums[x] = 0</code>）。如果 <code>y == aliceIndex</code>，在这次行动后&nbsp;Alice 拾起一个 1 ，并且 <code>nums[y]</code> 变成 <code>0</code> 。</li>\n</ul>\n\n<p>返回&nbsp;Alice 拾起 <strong>恰好 </strong><code>k</code> 个 1 所需的 <strong>最少 </strong>行动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">3</span></p>\n\n<p><strong>解释：</strong>如果游戏开始时&nbsp;Alice 在 <code>aliceIndex == 1</code> 的位置上，按照以下步骤执行每个动作，他可以利用 <code>3</code> 次行动拾取 <code>3</code> 个 1 ：</p>\n\n<ul>\n\t<li>游戏开始时&nbsp;Alice 拾取了一个 1 ，<code>nums[1]</code> 变成了 <code>0</code>。此时 <code>nums</code> 变为 <code>[1,<strong><u>0</u></strong>,0,0,0,1,1,0,0,1]</code> 。</li>\n\t<li>选择 <code>j == 2</code> 并执行第一种类型的动作。<code>nums</code> 变为 <code>[1,<strong><u>0</u></strong>,1,0,0,1,1,0,0,1]</code></li>\n\t<li>选择 <code>x == 2</code> 和 <code>y == 1</code> ，并执行第二种类型的动作。<code>nums</code> 变为 <code>[1,<strong><u>1</u></strong>,0,0,0,1,1,0,0,1]</code> 。由于 <code>y == aliceIndex</code>，Alice 拾取了一个 1 ，<code>nums</code> 变为&nbsp; <code>[1,<strong><u>0</u></strong>,0,0,0,1,1,0,0,1]</code> 。</li>\n\t<li>选择 <code>x == 0</code> 和 <code>y == 1</code> ，并执行第二种类型的动作。<code>nums</code> 变为 <code>[0,<strong><u>1</u></strong>,0,0,0,1,1,0,0,1]</code> 。由于 <code>y == aliceIndex</code>，Alice 拾取了一个 1 ，<code>nums</code> 变为&nbsp; <code>[0,<strong><u>0</u></strong>,0,0,0,1,1,0,0,1]</code> 。</li>\n</ul>\n\n<p>请注意，Alice 也可能执行其他的 <code>3</code> 次行动序列达成拾取 <code>3</code> 个 1 。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\"><!-- 以下是示例内容的中文翻译，同时保留了原有的HTML格式和注释 -->\n<p><strong>输入：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">nums = [0,0,0,0], k = 2, maxChanges = 3</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\">4</span></p>\n\n<p><strong>解释：</strong>如果游戏开始时&nbsp;Alice 在 <code>aliceIndex == 0</code> 的位置上，按照以下步骤执行每个动作，他可以利用 <code>4</code> 次行动拾取 <code>2</code> 个 1 ：</p>\n\n<ul>\n\t<li>选择 <code>j == 1</code> 并执行第一种类型的动作。<code>nums</code> 变为 <code>[<strong><u>0</u></strong>,1,0,0]</code> 。</li>\n\t<li>选择 <code>x == 1</code> 和 <code>y == 0</code> ，并执行第二种类型的动作。<code>nums</code> 变为 <code>[<strong><u>1</u></strong>,0,0,0]</code> 。由于 <code>y == aliceIndex</code>，Alice 拾起了一个 1 ，<code>nums</code> 变为 <code>[<strong><u>0</u></strong>,0,0,0]</code> 。</li>\n\t<li>再次选择 <code>j == 1</code> 并执行第一种类型的动作。<code>nums</code> 变为 <code>[<strong><u>0</u></strong>,1,0,0]</code> 。</li>\n\t<li>再次选择 <code>x == 1</code> 和 <code>y == 0</code> ，并执行第二种类型的动作。<code>nums</code> 变为 <code>[<strong><u>1</u></strong>,0,0,0]</code> 。由于<code>y == aliceIndex</code>，Alice 拾起了一个 1 ，<code>nums</code> 变为 <code>[<strong><u>0</u></strong>,0,0,0]</code> 。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= maxChanges &lt;= 10<sup>5</sup></code></li>\n\t<li><code>maxChanges + sum(nums) &gt;= k</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3087.查找热门话题标签",
        "hardRate": "MEDIUM",
        "passRate": "64.54%",
        "problemsUrl": "https://leetcode.cn/problems/find-trending-hashtags/",
        "solutionsUrl": "https://leetcode.cn/problems/find-trending-hashtags/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3088.使字符串反回文",
        "hardRate": "HARD",
        "passRate": "52.20%",
        "problemsUrl": "https://leetcode.cn/problems/make-string-anti-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/make-string-anti-palindrome/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3089.查找突发行为",
        "hardRate": "MEDIUM",
        "passRate": "35.41%",
        "problemsUrl": "https://leetcode.cn/problems/find-bursty-behavior/",
        "solutionsUrl": "https://leetcode.cn/problems/find-bursty-behavior/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3090.每个字符最多出现两次的最长子字符串",
        "hardRate": "EASY",
        "passRate": "68.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请找出满足每个字符最多出现两次的最长子字符串，并返回该<span data-keyword=\"substring\">子字符串</span>的<strong> 最大 </strong>长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">s = \"bcbbbcba\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>以下子字符串长度为 4，并且每个字符最多出现两次：<code>\"bcbb<u>bcba</u>\"</code>。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">s = \"aaaa\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>以下子字符串长度为 2，并且每个字符最多出现两次：<code>\"<u>aa</u>aa\"</code>。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul><!-- 字符串 s 的长度在 2 到 100 之间 -->\n\t<li><code>2 &lt;= s.length &lt;= 100</code></li>\n\t<!-- 字符串 s 仅包含小写英文字母 -->\n\t<li><code>s</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3091.执行操作使数据元素之和大于等于 K",
        "hardRate": "MEDIUM",
        "passRate": "48.55%",
        "problemsUrl": "https://leetcode.cn/problems/apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/solution",
        "problemsDesc": "<p>给你一个<strong>正整数</strong> <code>k</code> 。最初，你有一个数组 <code>nums = [1]</code> 。</p>\n\n<p>你可以对数组执行以下 <strong>任意 </strong>操作 <strong>任意 </strong>次数（<strong>可能为零</strong>）：</p>\n\n<ul>\n\t<li>选择数组中的任何一个元素，然后将它的值<strong> 增加</strong> <code>1</code> 。</li>\n\t<li>复制数组中的任何一个元素，然后将它附加到数组的末尾。</li>\n</ul>\n\n<p>返回使得最终数组元素之<strong> 和 </strong>大于或等于 <code>k</code> 所需的 <strong>最少 </strong>操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">k = 11</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">5</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>可以对数组 <code>nums = [1]</code> 执行以下操作：</p>\n\n<ul>\n\t<li>将元素的值增加 <code>1</code> 三次。结果数组为 <code>nums = [4]</code> 。</li>\n\t<li>复制元素两次。结果数组为 <code>nums = [4,4,4]</code> 。</li>\n</ul>\n\n<p>最终数组的和为 <code>4 + 4 + 4 = 12</code> ，大于等于 <code>k = 11</code> 。<br />\n执行的总操作次数为 <code>3 + 2 = 5</code> 。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">k = 1</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">0</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>原始数组的和已经大于等于 <code>1</code> ，因此不需要执行操作。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3092.最高频率的 ID",
        "hardRate": "MEDIUM",
        "passRate": "41.83%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-ids/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-ids/solution",
        "problemsDesc": "<p>你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code> 和&nbsp;<code>freq</code>&nbsp;，<code>nums</code>&nbsp;中每一个元素表示一个 ID ，对应的 <code>freq</code>&nbsp;中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。</p>\n\n<ul>\n\t<li><strong>增加 ID 的数目：</strong>如果&nbsp;<code>freq[i]</code>&nbsp;是正数，那么&nbsp;<code>freq[i]</code>&nbsp;个 ID 为&nbsp;<code>nums[i]</code>&nbsp;的元素在第 <code>i</code>&nbsp;步操作后会添加到集合中。</li>\n\t<li><strong>减少 ID 的数目：</strong>如果&nbsp;<code>freq[i]</code>&nbsp;是负数，那么&nbsp;<code>-freq[i]</code>&nbsp;个 ID 为&nbsp;<code>nums[i]</code>&nbsp;的元素在第 <code>i</code>&nbsp;步操作后会从集合中删除。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的数组 <code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;表示第 <code>i</code>&nbsp;步操作后出现频率最高的 ID <strong>数目</strong>&nbsp;，如果在某次操作后集合为空，那么 <code>ans[i]</code>&nbsp;为 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,3,2,1], freq = [3,2,-3,1]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[3,3,2,2]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>第 0 步操作后，有 3 个 ID 为 2 的元素，所以&nbsp;<code>ans[0] = 3</code>&nbsp;。<br />\n第 1 步操作后，有 3 个 ID 为 2 的元素和 2 个 ID 为 3 的元素，所以&nbsp;<code>ans[1] = 3</code>&nbsp;。<br />\n第 2 步操作后，有 2 个 ID 为 3 的元素，所以&nbsp;<code>ans[2] = 2</code>&nbsp;。<br />\n第 3 步操作后，有 2 个 ID 为 3 的元素和 1 个 ID 为 1 的元素，所以&nbsp;<code>ans[3] = 2</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [5,5,3], freq = [2,-2,1]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[2,0,1]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>第 0 步操作后，有 2 个 ID 为 5 的元素，所以&nbsp;<code>ans[0] = 2</code>&nbsp;。<br />\n第 1 步操作后，集合中没有任何元素，所以&nbsp;<code>ans[1] = 0</code>&nbsp;。<br />\n第 2 步操作后，有 1 个 ID 为 3 的元素，所以&nbsp;<code>ans[2] = 1</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length == freq.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= freq[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>freq[i] != 0</code></li>\n\t<li>输入保证任何操作后，集合中的元素出现次数不会为负数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3093.最长公共后缀查询",
        "hardRate": "HARD",
        "passRate": "33.59%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-suffix-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-suffix-queries/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>wordsContainer</code> 和&nbsp;<code>wordsQuery</code>&nbsp;。</p>\n\n<p>对于每个&nbsp;<code>wordsQuery[i]</code>&nbsp;，你需要从&nbsp;<code>wordsContainer</code>&nbsp;中找到一个与&nbsp;<code>wordsQuery[i]</code>&nbsp;有&nbsp;<strong>最长公共后缀</strong>&nbsp;的字符串。如果 <code>wordsContainer</code>&nbsp;中有两个或者更多字符串有最长公共后缀，那么答案为长度<strong>&nbsp;最短</strong>&nbsp;的。如果有超过两个字符串有&nbsp;<strong>相同</strong>&nbsp;最短长度，那么答案为它们在&nbsp;<code>wordsContainer</code>&nbsp;中出现&nbsp;<strong>更早</strong>&nbsp;的一个。</p>\n\n<p>请你返回一个整数数组<em>&nbsp;</em><code>ans</code>&nbsp;，其中<em>&nbsp;</em><code>ans[i]</code>是<em>&nbsp;</em><code>wordsContainer</code>中与&nbsp;<code>wordsQuery[i]</code>&nbsp;有&nbsp;<strong>最长公共后缀</strong>&nbsp;字符串的下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>wordsContainer = [\"abcd\",\"bcd\",\"xbcd\"], wordsQuery = [\"cd\",\"bcd\",\"xyz\"]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[1,1,1]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们分别来看每一个&nbsp;<code>wordsQuery[i]</code>&nbsp;：</p>\n\n<ul>\n\t<li>对于&nbsp;<code>wordsQuery[0] = \"cd\"</code>&nbsp;，<code>wordsContainer</code>&nbsp;中有最长公共后缀&nbsp;<code>\"cd\"</code>&nbsp;的字符串下标分别为&nbsp;0 ，1 和&nbsp;2 。这些字符串中，答案是下标为 1 的字符串，因为它的长度为 3 ，是最短的字符串。</li>\n\t<li>对于&nbsp;<code>wordsQuery[1] = \"bcd\"</code>&nbsp;，<code>wordsContainer</code>&nbsp;中有最长公共后缀&nbsp;<code>\"bcd\"</code>&nbsp;的字符串下标分别为 0 ，1 和 2 。这些字符串中，答案是下标为 1 的字符串，因为它的长度为 3 ，是最短的字符串。</li>\n\t<li>对于&nbsp;<code>wordsQuery[2] = \"xyz\"</code>&nbsp;，<code>wordsContainer</code>&nbsp;中没有字符串跟它有公共后缀，所以最长公共后缀为&nbsp;<code>\"\"</code>&nbsp;，下标为&nbsp;0 ，1 和 2 的字符串都得到这一公共后缀。这些字符串中，&nbsp;答案是下标为 1 的字符串，因为它的长度为 3 ，是最短的字符串。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>wordsContainer = [\"abcdefgh\",\"poiuygh\",\"ghghgh\"], wordsQuery = [\"gh\",\"acbfgh\",\"acbfegh\"]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[2,0,2]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们分别来看每一个&nbsp;<code>wordsQuery[i]</code>&nbsp;：</p>\n\n<ul>\n\t<li>对于&nbsp;<code>wordsQuery[0] = \"gh\"</code>&nbsp;，<code>wordsContainer</code>&nbsp;中有最长公共后缀&nbsp;<code>\"gh\"</code>&nbsp;的字符串下标分别为 0 ，1 和 2 。这些字符串中，答案是下标为 2 的字符串，因为它的长度为 6 ，是最短的字符串。</li>\n\t<li>对于&nbsp;<code>wordsQuery[1] = \"acbfgh\"</code>&nbsp;，只有下标为 0 的字符串有最长公共后缀&nbsp;<code>\"fgh\"</code>&nbsp;。所以尽管下标为 2 的字符串是最短的字符串，但答案是 0 。</li>\n\t<li>对于&nbsp;<code>wordsQuery[2] = \"acbfegh\"</code>&nbsp;，<code>wordsContainer</code>&nbsp;中有最长公共后缀&nbsp;<code>\"gh\"</code>&nbsp;的字符串下标分别为 0 ，1 和 2 。这些字符串中，答案是下标为 2 的字符串，因为它的长度为 6 ，是最短的字符串。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= wordsContainer.length, wordsQuery.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= wordsContainer[i].length &lt;= 5 * 10<sup>3</sup></code></li>\n\t<li><code>1 &lt;= wordsQuery[i].length &lt;= 5 * 10<sup>3</sup></code></li>\n\t<li><code>wordsContainer[i]</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>wordsQuery[i]</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>wordsContainer[i].length</code>&nbsp;的和至多为&nbsp;<code>5 * 10<sup>5</sup></code>&nbsp;。</li>\n\t<li><code>wordsQuery[i].length</code>&nbsp;的和至多为&nbsp;<code>5 * 10<sup>5</sup></code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3094.使用按位查询猜测数字 II",
        "hardRate": "MEDIUM",
        "passRate": "86.73%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-number-using-bitwise-questions-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-number-using-bitwise-questions-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3095.或值至少 K 的最短子数组 I",
        "hardRate": "EASY",
        "passRate": "58.91%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-i/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-i/solution",
        "problemsDesc": "<p>给你一个 <strong>非负</strong>&nbsp;整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果一个数组中所有元素的按位或运算 <code>OR</code>&nbsp;的值 <strong>至少</strong>&nbsp;为 <code>k</code>&nbsp;，那么我们称这个数组是 <strong>特别的</strong>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>最短特别非空</strong>&nbsp;<span data-keyword=\"subarray-nonempty\">子数组</span>的长度，如果特别子数组不存在，那么返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2,3], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>子数组&nbsp;<code>[3]</code>&nbsp;的按位&nbsp;<code>OR</code> 值为&nbsp;<code>3</code>&nbsp;，所以我们返回 <code>1</code>&nbsp;。</p>\n\n<p>注意，<code>[2]</code> 也是一个特别子数组。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,1,8], k = 10</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>子数组&nbsp;<code>[2,1,8]</code> 的按位&nbsp;<code>OR</code>&nbsp;值为 <code>11</code>&nbsp;，所以我们返回 <code>3</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2], k = 0</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><b>解释：</b></p>\n\n<p>子数组&nbsp;<code>[1]</code>&nbsp;的按位&nbsp;<code>OR</code>&nbsp;值为&nbsp;<code>1</code>&nbsp;，所以我们返回&nbsp;<code>1</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= k &lt; 64</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3096.得到更多分数的最少关卡数目",
        "hardRate": "MEDIUM",
        "passRate": "53.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-levels-to-gain-more-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-levels-to-gain-more-points/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的二进制数组&nbsp;<code>possible</code>&nbsp;。</p>\n\n<p>Alice 和 Bob 正在玩一个有 <code>n</code> 个关卡的游戏，游戏中有一些关卡是 <strong>困难</strong>&nbsp;模式，其他的关卡是 <strong>简单</strong>&nbsp;模式。如果&nbsp;<code>possible[i] == 0</code>&nbsp;，那么第&nbsp;<code>i</code> 个关卡是 <strong>困难</strong>&nbsp;模式，两个玩家&nbsp;<strong>都不可能</strong> 通过。一个玩家通过一个简单模式的关卡可以获得 <code>1</code>&nbsp;分，遇到困难模式的关卡将失去 <code>1</code>&nbsp;分。</p>\n\n<p>游戏的一开始，Alice 将从第 <code>0</code>&nbsp;级开始 <strong>按顺序</strong> 完成一些关卡，然后 Bob 会完成剩下的所有关卡。</p>\n\n<p>假设两名玩家都采取最优策略，目的是&nbsp;<strong>最大化</strong>&nbsp;自己的得分，Alice 想知道自己&nbsp;<strong>最少</strong> 需要完成多少个关卡，才能获得比 Bob 更多的分数。</p>\n\n<p>请你返回 Alice 获得比 Bob 更多的分数所需要完成的 <strong>最少</strong> 关卡数目，如果 <strong>无法</strong>&nbsp;达成，那么返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>注意</strong>，每个玩家都至少需要完成&nbsp;<code>1</code> 个关卡。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>possible = [1,0,1,0]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们来看一下 Alice 可以完成的关卡数目：</p>\n\n<ul>\n\t<li>如果 Alice 只完成关卡 0 ，Bob 完成剩下的所有关卡，那么 Alice 获得 1 分，Bob 获得 -1 + 1 - 1 = -1 分。</li>\n\t<li>如果 Alice 完成到关卡 1 ，Bob 完成剩下的所有关卡，那么 Alice 获得&nbsp;1 - 1 = 0 分，Bob 获得 1 - 1 = 0 分。</li>\n\t<li>如果 Alice 完成到关卡 2 ，Bob 完成剩下的所有关卡，那么 Alice 获得&nbsp;1 - 1 + 1 = 1 分，Bob 获得 -1 分。</li>\n</ul>\n\n<p>Alice 需要完成至少一个关卡获得更多的分数。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>possible = [1,1,1,1,1]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们来看一下 Alice 可以完成的关卡数目：</p>\n\n<ul>\n\t<li>如果 Alice 只完成关卡 0 ，Bob 完成剩下的所有关卡，那么 Alice 获得 1 分，Bob 获得 4 分。</li>\n\t<li>如果 Alice 完成到关卡 1 ，Bob 完成剩下的所有关卡，那么 Alice 获得&nbsp;2 分，Bob 获得 3 分。</li>\n\t<li>如果 Alice 完成到关卡 2 ，Bob 完成剩下的所有关卡，那么 Alice 获得&nbsp;3 分，Bob 获得 2&nbsp;分。</li>\n\t<li>如果 Alice 完成到关卡 3&nbsp;，Bob 完成剩下的所有关卡，那么 Alice 获得 4&nbsp;分，Bob 获得 1&nbsp;分。</li>\n</ul>\n\n<p>Alice 需要完成至少三个关卡获得更多的分数。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>possible = [0,0]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>-1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>两名玩家只能各完成 1 个关卡，Alice 完成关卡 0 得到 -1 分，Bob 完成关卡 1 得到 -1 分。两名玩家得分相同，所以 Alice 无法得到更多分数。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == possible.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>possible[i]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3097.或值至少为 K 的最短子数组 II",
        "hardRate": "MEDIUM",
        "passRate": "52.03%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/solution",
        "problemsDesc": "<p>给你一个 <strong>非负</strong>&nbsp;整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果一个数组中所有元素的按位或运算 <code>OR</code>&nbsp;的值 <strong>至少</strong>&nbsp;为 <code>k</code>&nbsp;，那么我们称这个数组是 <strong>特别的</strong>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>最短特别非空</strong>&nbsp;<span data-keyword=\"subarray-nonempty\">子数组</span>的长度，如果特别子数组不存在，那么返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2,3], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>子数组&nbsp;<code>[3]</code>&nbsp;的按位&nbsp;<code>OR</code> 值为&nbsp;<code>3</code>&nbsp;，所以我们返回 <code>1</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,1,8], k = 10</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>子数组&nbsp;<code>[2,1,8]</code> 的按位&nbsp;<code>OR</code>&nbsp;值为 <code>11</code>&nbsp;，所以我们返回 <code>3</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2], k = 0</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><b>解释：</b></p>\n\n<p>子数组&nbsp;<code>[1]</code>&nbsp;的按位&nbsp;<code>OR</code>&nbsp;值为&nbsp;<code>1</code>&nbsp;，所以我们返回&nbsp;<code>1</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup><font size=\"1\">9</font></sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3098.求出所有子序列的能量和",
        "hardRate": "HARD",
        "passRate": "54.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>一个 <span data-keyword=\"subsequence-array\">子序列</span> 的 <strong>能量</strong>&nbsp;定义为子序列中&nbsp;<strong>任意</strong>&nbsp;两个元素的差值绝对值的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;中长度 <strong>等于</strong>&nbsp;<code>k</code>&nbsp;的 <strong>所有</strong>&nbsp;子序列的 <strong>能量和</strong>&nbsp;。</p>\n\n<p>由于答案可能会很大，将答案对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2,3,4], k = 3</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>nums</code>&nbsp;中总共有 4 个长度为 3 的子序列：<code>[1,2,3]</code>&nbsp;，<code>[1,3,4]</code>&nbsp;，<code>[1,2,4]</code>&nbsp;和&nbsp;<code>[2,3,4]</code>&nbsp;。能量和为 <code>|2 - 3| + |3 - 4| + |2 - 1| + |3 - 4| = 4</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,2], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>0</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>nums</code>&nbsp;中唯一一个长度为 2 的子序列是&nbsp;<code>[2,2]</code>&nbsp;。能量和为&nbsp;<code>|2 - 2| = 0</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">nums = [4,3,-1], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>10</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>nums</code>&nbsp;总共有 3 个长度为 2 的子序列：<code>[4,3]</code>&nbsp;，<code>[4,-1]</code>&nbsp;和&nbsp;<code>[3,-1]</code>&nbsp;。能量和为&nbsp;<code>|4 - 3| + |4 - (-1)| + |3 - (-1)| = 10</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == nums.length &lt;= 50</code></li>\n\t<li><code>-10<sup>8</sup> &lt;= nums[i] &lt;= 10<sup>8</sup> </code></li>\n\t<li><code>2 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3099.哈沙德数",
        "hardRate": "EASY",
        "passRate": "85.28%",
        "problemsUrl": "https://leetcode.cn/problems/harshad-number/",
        "solutionsUrl": "https://leetcode.cn/problems/harshad-number/solution",
        "problemsDesc": "<p>如果一个整数能够被其各个数位上的数字之和整除，则称之为<strong> 哈沙德数</strong>（Harshad number）。给你一个整数 <code>x</code> 。如果 <code>x</code> 是 <strong>哈沙德数 </strong>，则返回<em> </em><code>x</code> 各个数位上的数字之和，否则，返回<em> </em><code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">x = 18</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">9</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>x</code> 各个数位上的数字之和为 <code>9</code> 。<code>18</code> 能被 <code>9</code> 整除。因此 <code>18</code> 是哈沙德数，答案是 <code>9</code> 。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">x = 23</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">-1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>x</code> 各个数位上的数字之和为 <code>5</code> 。<code>23</code> 不能被 <code>5</code> 整除。因此 <code>23</code> 不是哈沙德数，答案是 <code>-1</code> 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3100.换水问题 II",
        "hardRate": "MEDIUM",
        "passRate": "67.73%",
        "problemsUrl": "https://leetcode.cn/problems/water-bottles-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/water-bottles-ii/solution",
        "problemsDesc": "<p>给你两个整数 <code>numBottles</code> 和 <code>numExchange</code> 。</p>\n\n<p><code>numBottles</code> 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：</p>\n\n<ul>\n\t<li>喝掉任意数量的满水瓶，使它们变成空水瓶。</li>\n\t<li>用 <code>numExchange</code> 个空水瓶交换一个满水瓶。然后，将 <code>numExchange</code> 的值增加 1 。</li>\n</ul>\n\n<p>注意，你不能使用相同的 <code>numExchange</code> 值交换多批空水瓶。例如，如果 <code>numBottles == 3</code> 并且 <code>numExchange == 1</code> ，则不能用 <code>3</code> 个空水瓶交换成 <code>3</code> 个满水瓶。</p>\n\n<p>返回你 <strong>最多</strong> 可以喝到多少瓶水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/28/exampleone1.png\" style=\"width: 948px; height: 482px; padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>输入：</strong>numBottles = 13, numExchange = 6\n<strong>输出：</strong>15\n<strong>解释：</strong>上表显示了满水瓶的数量、空水瓶的数量、numExchange 的值，以及累计喝掉的水瓶数量。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/28/example231.png\" style=\"width: 990px; height: 642px; padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>输入：</strong>numBottles = 10, numExchange = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>上表显示了满水瓶的数量、空水瓶的数量、numExchange 的值，以及累计喝掉的水瓶数量。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numBottles &lt;= 100 </code></li>\n\t<li><code>1 &lt;= numExchange &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    }
]