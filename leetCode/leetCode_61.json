[
    {
        "problemsName": " 3001.捕获黑皇后需要的最少移动次数",
        "hardRate": "MEDIUM",
        "passRate": "31.33%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-capture-the-queen/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-capture-the-queen/solution",
        "problemsDesc": "<p>现有一个下标从 <strong>1</strong> 开始的 <code>8 x 8</code> 棋盘，上面有 <code>3</code> 枚棋子。</p>\n\n<p>给你 <code>6</code> 个整数 <code>a</code> 、<code>b</code> 、<code>c</code> 、<code>d</code> 、<code>e</code> 和 <code>f</code> ，其中：</p>\n\n<ul>\n\t<li><code>(a, b)</code> 表示白色车的位置。</li>\n\t<li><code>(c, d)</code> 表示白色象的位置。</li>\n\t<li><code>(e, f)</code> 表示黑皇后的位置。</li>\n</ul>\n\n<p>假定你只能移动白色棋子，返回捕获黑皇后所需的<strong>最少</strong>移动次数。</p>\n\n<p><strong>请注意</strong>：</p>\n\n<ul>\n\t<li>车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。</li>\n\t<li>象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。</li>\n\t<li>如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。</li>\n\t<li>皇后不能移动。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/21/ex1.png\" style=\"width: 600px; height: 600px; padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>输入：</strong>a = 1, b = 1, c = 8, d = 8, e = 2, f = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>将白色车先移动到 (1, 3) ，然后移动到 (2, 3) 来捕获黑皇后，共需移动 2 次。\n由于起始时没有任何棋子正在攻击黑皇后，要想捕获黑皇后，移动次数不可能少于 2 次。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/21/ex2.png\" style=\"width: 600px; height: 600px;padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>输入：</strong>a = 5, b = 3, c = 3, d = 4, e = 5, f = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>可以通过以下任一方式移动 1 次捕获黑皇后：\n- 将白色车移动到 (5, 2) 。\n- 将白色象移动到 (5, 2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a, b, c, d, e, f &lt;= 8</code></li>\n\t<li>两枚棋子不会同时出现在同一个格子上。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3002.移除后集合的最多元素数",
        "hardRate": "MEDIUM",
        "passRate": "41.87%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-size-of-a-set-after-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-size-of-a-set-after-removals/solution",
        "problemsDesc": "<p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们的长度都是偶数<code> n</code> 。</p>\n\n<p>你必须从 <code>nums1</code> 中移除 <code>n / 2</code> 个元素，同时从 <code>nums2</code> 中也移除 <code>n / 2</code> 个元素。移除之后，你将 <code>nums1</code> 和 <code>nums2</code> 中剩下的元素插入到集合 <code>s</code> 中。</p>\n\n<p>返回集合 <code>s</code>可能的<strong> 最多 </strong>包含多少元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,1,2], nums2 = [1,1,1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>从 nums1 和 nums2 中移除两个 1 。移除后，数组变为 nums1 = [2,2] 和 nums2 = [1,1] 。因此，s = {1,2} 。\n可以证明，在移除之后，集合 s 最多可以包含 2 个元素。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,4,5,6], nums2 = [2,3,2,3,2,3]\n<strong>输出：</strong>5\n<strong>解释：</strong>从 nums1 中移除 2、3 和 6 ，同时从 nums2 中移除两个 3 和一个 2 。移除后，数组变为 nums1 = [1,4,5] 和 nums2 = [2,3,2] 。因此，s = {1,2,3,4,5} 。\n可以证明，在移除之后，集合 s 最多可以包含 5 个元素。 \n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,1,2,2,3,3], nums2 = [4,4,5,5,6,6]\n<strong>输出：</strong>6\n<strong>解释：</strong>从 nums1 中移除 1、2 和 3 ，同时从 nums2 中移除 4、5 和 6 。移除后，数组变为 nums1 = [1,2,3] 和 nums2 = [4,5,6] 。因此，s = {1,2,3,4,5,6} 。\n可以证明，在移除之后，集合 s 最多可以包含 6 个元素。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n</code>是偶数。</li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3003.执行操作后的最大分割数量",
        "hardRate": "HARD",
        "passRate": "26.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串&nbsp;<code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>。</p>\n\n<p>你需要执行以下分割操作，直到字符串&nbsp;<code>s&nbsp;</code>变为&nbsp;<strong>空</strong>：</p>\n\n<ul>\n\t<li>选择&nbsp;<code>s</code>&nbsp;的最长&nbsp;<strong>前缀</strong>，该前缀最多包含&nbsp;<code>k&nbsp;</code>个&nbsp;<strong>不同&nbsp;</strong>字符。</li>\n\t<li><strong>删除&nbsp;</strong>这个前缀，并将分割数量加一。如果有剩余字符，它们在&nbsp;<code>s</code>&nbsp;中保持原来的顺序。</li>\n</ul>\n\n<p>执行操作之 <strong>前</strong> ，你可以将&nbsp;<code>s</code>&nbsp;中&nbsp;<strong>至多一处 </strong>下标的对应字符更改为另一个小写英文字母。</p>\n\n<p>在最优选择情形下改变至多一处下标对应字符后，用整数表示并返回操作结束时得到的 <strong>最大</strong> 分割数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"accca\", k = 2</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>最好的方式是把&nbsp;<code>s[2]</code>&nbsp;变为除了 a 和 c 之外的东西，比如&nbsp;b。然后它变成了&nbsp;<code>\"acbca\"</code>。</p>\n\n<p>然后我们执行以下操作：</p>\n\n<ol>\n\t<li>最多包含 2 个不同字符的最长前缀是 <code>\"ac\"</code>，我们删除它然后&nbsp;<code>s</code> 变为&nbsp;<code>\"bca\"</code>。</li>\n\t<li>现在最多包含 2 个不同字符的最长前缀是&nbsp;<code>\"bc\"</code>，所以我们删除它然后&nbsp;<code>s</code> 变为&nbsp;<code>\"a\"</code>。</li>\n\t<li>最后，我们删除&nbsp;<code>\"a\"</code>&nbsp;并且&nbsp;<code>s</code>&nbsp;变成空串，所以该过程结束。</li>\n</ol>\n\n<p>进行操作时，字符串被分成 3 个部分，所以答案是 3。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"aabaab\", k = 3</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>一开始&nbsp;<code>s</code>&nbsp;包含 2 个不同的字符，所以无论我们改变哪个，&nbsp;它最多包含 3 个不同字符，因此最多包含 3 个不同字符的最长前缀始终是所有字符，因此答案是 1。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"xxyz\", k = 1</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>最好的方式是将&nbsp;<code>s[0]</code>&nbsp;或&nbsp;<code>s[1]</code>&nbsp;变为&nbsp;<code>s</code>&nbsp;中字符以外的东西，例如将&nbsp;<code>s[0]</code>&nbsp;变为&nbsp;<code>w</code>。</p>\n\n<p>然后&nbsp;<code>s</code>&nbsp;变为&nbsp;<code>\"wxyz\"</code>，包含 4 个不同的字符，所以当&nbsp;<code>k</code>&nbsp;为 1，它将分为 4 个部分。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= k &lt;= 26</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3004.相同颜色的最大子树",
        "hardRate": "MEDIUM",
        "passRate": "52.60%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subtree-of-the-same-color/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subtree-of-the-same-color/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3005.最大频率元素计数",
        "hardRate": "EASY",
        "passRate": "70.10%",
        "problemsUrl": "https://leetcode.cn/problems/count-elements-with-maximum-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/count-elements-with-maximum-frequency/solution",
        "problemsDesc": "<p>给你一个由 <strong>正整数 </strong>组成的数组 <code>nums</code> 。</p>\n\n<p>返回数组 <code>nums</code> 中所有具有 <strong>最大 </strong>频率的元素的 <strong>总频率 </strong>。</p>\n\n<p>元素的 <strong>频率 </strong>是指该元素在数组中出现的次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3,1,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>元素 1 和 2 的频率为 2 ，是数组中的最大频率。\n因此具有最大频率的元素在数组中的数量是 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>数组中的所有元素的频率都为 1 ，是最大频率。\n因此具有最大频率的元素在数组中的数量是 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3006.找出数组中的美丽下标 I",
        "hardRate": "MEDIUM",
        "passRate": "43.85%",
        "problemsUrl": "https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-i/",
        "solutionsUrl": "https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 、字符串 <code>a</code> 、字符串 <code>b</code> 和一个整数 <code>k</code> 。</p>\n\n<p>如果下标 <code>i</code> 满足以下条件，则认为它是一个 <strong>美丽下标</strong>：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>\n\t<li><code>s[i..(i + a.length - 1)] == a</code></li>\n\t<li>存在下标 <code>j</code> 使得：\n\t<ul>\n\t\t<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>\n\t\t<li><code>s[j..(j + b.length - 1)] == b</code></li>\n\t\t<li><code>|j - i| &lt;= k</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>以数组形式按<strong> 从小到大排序 </strong>返回美丽下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n<strong>输出：</strong>[16,33]\n<strong>解释：</strong>存在 2 个美丽下标：[16,33]。\n- 下标 16 是美丽下标，因为 s[16..17] == \"my\" ，且存在下标 4 ，满足 s[4..11] == \"squirrel\" 且 |16 - 4| &lt;= 15 。\n- 下标 33 是美丽下标，因为 s[33..34] == \"my\" ，且存在下标 18 ，满足 s[18..25] == \"squirrel\" 且 |33 - 18| &lt;= 15 。\n因此返回 [16,33] 作为结果。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", a = \"a\", b = \"a\", k = 4\n<strong>输出：</strong>[0]\n<strong>解释：</strong>存在 1 个美丽下标：[0]。\n- 下标 0 是美丽下标，因为 s[0..0] == \"a\" ，且存在下标 0 ，满足 s[0..0] == \"a\" 且 |0 - 0| &lt;= 4 。\n因此返回 [0] 作为结果。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10</code></li>\n\t<li><code>s</code>、<code>a</code>、和 <code>b</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3007.价值和小于等于 K 的最大数字",
        "hardRate": "MEDIUM",
        "passRate": "50.58%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>k</code>&nbsp;和一个整数&nbsp;<code>x</code>&nbsp;。整数&nbsp;<code>num</code>&nbsp;的价值是它的二进制表示中在&nbsp;<code>x</code>，<code>2x</code>，<code>3x</code>&nbsp;等位置处&nbsp;<strong><span data-keyword=\"set-bit\">设置位</span></strong>&nbsp;的数目（从最低有效位开始）。下面的表格包含了如何计算价值的例子。</p>\n\n<table border=\"1\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>x</th>\n\t\t\t<th>num</th>\n\t\t\t<th>Binary Representation</th>\n\t\t\t<th>Price</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>13</td>\n\t\t\t<td><u>0</u><u>0</u><u>0</u><u>0</u><u>0</u><strong><u>1</u></strong><strong><u>1</u></strong><u>0</u><strong><u>1</u></strong></td>\n\t\t\t<td>3</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>13</td>\n\t\t\t<td>0<u>0</u>0<u>0</u>0<strong><u>1</u></strong>1<u>0</u>1</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>233</td>\n\t\t\t<td>0<strong><u>1</u></strong>1<strong><u>1</u></strong>0<strong><u>1</u></strong>0<u>0</u>1</td>\n\t\t\t<td>3</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3</td>\n\t\t\t<td>13</td>\n\t\t\t<td><u>0</u>00<u>0</u>01<strong><u>1</u></strong>01</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3</td>\n\t\t\t<td>362</td>\n\t\t\t<td><strong><u>1</u></strong>01<strong><u>1</u></strong>01<u>0</u>10</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><code>num</code>&nbsp;的 <strong>累加价值</strong> 是从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>num</code>&nbsp;的数字的 <strong>总</strong> 价值。如果&nbsp;<code>num</code>&nbsp;的累加价值小于或等于&nbsp;<code>k</code>&nbsp;则被认为是 <strong>廉价</strong> 的。</p>\n\n<p>请你返回<strong>&nbsp;最大</strong>&nbsp;的廉价数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>k = 9, x = 1\n<b>输出：</b>6\n<b>解释：</b>由下表所示，6 是最大的廉价数字。\n</pre>\n\n<table border=\"1\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>x</th>\n\t\t\t<th>num</th>\n\t\t\t<th>Binary Representation</th>\n\t\t\t<th>Price</th>\n\t\t\t<th>Accumulated Price</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td><u>0</u><u>0</u><strong><u>1</u></strong></td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>2</td>\n\t\t\t<td><u>0</u><strong><u>1</u></strong><u>0</u></td>\n\t\t\t<td>1</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>3</td>\n\t\t\t<td><u>0</u><strong><u>1</u></strong><strong><u>1</u></strong></td>\n\t\t\t<td>2</td>\n\t\t\t<td>4</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>4</td>\n\t\t\t<td><strong><u>1</u></strong><u>0</u><u>0</u></td>\n\t\t\t<td>1</td>\n\t\t\t<td>5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>5</td>\n\t\t\t<td><strong><u>1</u></strong><u>0</u><strong><u>1</u></strong></td>\n\t\t\t<td>2</td>\n\t\t\t<td>7</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>6</td>\n\t\t\t<td><strong><u>1</u></strong><strong><u>1</u></strong><u>0</u></td>\n\t\t\t<td>2</td>\n\t\t\t<td>9</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>7</td>\n\t\t\t<td><strong><u>1</u></strong><strong><u>1</u></strong><strong><u>1</u></strong></td>\n\t\t\t<td>3</td>\n\t\t\t<td>12</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>k = 7, x = 2\n<b>输出：</b>9\n<b>解释：</b>由下表所示，9 是最大的廉价数字。\n</pre>\n\n<table border=\"1\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>x</th>\n\t\t\t<th>num</th>\n\t\t\t<th>Binary Representation</th>\n\t\t\t<th>Price</th>\n\t\t\t<th>Accumulated Price</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>1</td>\n\t\t\t<td><u>0</u>0<u>0</u>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>0</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>2</td>\n\t\t\t<td><u>0</u>0<strong><u>1</u></strong>0</td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>3</td>\n\t\t\t<td><u>0</u>0<strong><u>1</u></strong>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>4</td>\n\t\t\t<td><u>0</u>1<u>0</u>0</td>\n\t\t\t<td>0</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>5</td>\n\t\t\t<td><u>0</u>1<u>0</u>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>6</td>\n\t\t\t<td><u>0</u>1<strong><u>1</u></strong>0</td>\n\t\t\t<td>1</td>\n\t\t\t<td>3</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>7</td>\n\t\t\t<td><u>0</u>1<strong><u>1</u></strong>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>4</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>8</td>\n\t\t\t<td><strong><u>1</u></strong>0<u>0</u>0</td>\n\t\t\t<td>1</td>\n\t\t\t<td>5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>9</td>\n\t\t\t<td><strong><u>1</u></strong>0<u>0</u>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>6</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>10</td>\n\t\t\t<td><strong><u>1</u></strong>0<strong><u>1</u></strong>0</td>\n\t\t\t<td>2</td>\n\t\t\t<td>8</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>\n\t<li><code>1 &lt;= x &lt;= 8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3008.找出数组中的美丽下标 II",
        "hardRate": "HARD",
        "passRate": "29.35%",
        "problemsUrl": "https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;、字符串&nbsp;<code>a</code>&nbsp;、字符串&nbsp;<code>b</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果下标 <code>i</code>&nbsp;满足以下条件，则认为它是一个 <strong>美丽下标</strong>&nbsp;：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= s.length - a.length</code></li>\n\t<li><code>s[i..(i + a.length - 1)] == a</code></li>\n\t<li>存在下标&nbsp;<code>j</code>&nbsp;使得：\n\t<ul>\n\t\t<li><code>0 &lt;= j &lt;= s.length - b.length</code></li>\n\t\t<li><code>s[j..(j + b.length - 1)] == b</code></li>\n\t\t<li><code>|j - i| &lt;= k</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>以数组形式按<strong>&nbsp;从小到大排序&nbsp;</strong>返回美丽下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\n<strong>输出：</strong>[16,33]\n<strong>解释：</strong>存在 2 个美丽下标：[16,33]。\n- 下标 16 是美丽下标，因为 s[16..17] == \"my\" ，且存在下标 4 ，满足 s[4..11] == \"squirrel\" 且 |16 - 4| &lt;= 15 。\n- 下标 33 是美丽下标，因为 s[33..34] == \"my\" ，且存在下标 18 ，满足 s[18..25] == \"squirrel\" 且 |33 - 18| &lt;= 15 。\n因此返回 [16,33] 作为结果。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcd\", a = \"a\", b = \"a\", k = 4\n<b>输出：</b>[0]\n<strong>解释：</strong>存在 1 个美丽下标：[0]。\n- 下标 0 是美丽下标，因为 s[0..0] == \"a\" ，且存在下标 0 ，满足 s[0..0] == \"a\" 且 |0 - 0| &lt;= 4 。\n因此返回 [0] 作为结果。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s</code>、<code>a</code>、和&nbsp;<code>b</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3009.折线图上的最大交点数量",
        "hardRate": "HARD",
        "passRate": "47.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-intersections-on-the-chart/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-intersections-on-the-chart/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3010.将数组分成最小总代价的子数组 I",
        "hardRate": "EASY",
        "passRate": "63.78%",
        "problemsUrl": "https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>一个数组的 <strong>代价</strong>&nbsp;是它的 <strong>第一个</strong>&nbsp;元素。比方说，<code>[1,2,3]</code>&nbsp;的代价是&nbsp;<code>1</code>&nbsp;，<code>[3,4,1]</code>&nbsp;的代价是&nbsp;<code>3</code>&nbsp;。</p>\n\n<p>你需要将&nbsp;<code>nums</code>&nbsp;分成&nbsp;<code>3</code>&nbsp;个&nbsp;<strong>连续且没有交集</strong>&nbsp;的子数组。</p>\n\n<p>请你返回这些<span data-keyword=\"subarray\">子数组</span>的 <strong>最小</strong>&nbsp;代价&nbsp;<b>总和</b>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,12]\n<b>输出：</b>6\n<b>解释：</b>最佳分割成 3 个子数组的方案是：[1] ，[2] 和 [3,12] ，总代价为 1 + 2 + 3 = 6 。\n其他得到 3 个子数组的方案是：\n- [1] ，[2,3] 和 [12] ，总代价是 1 + 2 + 12 = 15 。\n- [1,2] ，[3] 和 [12] ，总代价是 1 + 3 + 12 = 16 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,4,3]\n<b>输出：</b>12\n<b>解释：</b>最佳分割成 3 个子数组的方案是：[5] ，[4] 和 [3] ，总代价为 5 + 4 + 3 = 12 。\n12 是所有分割方案里的最小总代价。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,3,1,1]\n<b>输出：</b>12\n<b>解释：</b>最佳分割成 3 个子数组的方案是：[10,3] ，[1] 和 [1] ，总代价为 10 + 1 + 1 = 12 。\n12 是所有分割方案里的最小总代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3011.判断一个数组是否可以变为有序",
        "hardRate": "MEDIUM",
        "passRate": "62.13%",
        "problemsUrl": "https://leetcode.cn/problems/find-if-array-can-be-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/find-if-array-can-be-sorted/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始且全是 <strong>正</strong>&nbsp;整数的数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>一次 <b>操作</b>&nbsp;中，如果两个 <strong>相邻</strong>&nbsp;元素在二进制下 <span data-keyword=\"set-bit\">设置位</span> 的数目 <strong>相同</strong>&nbsp;，那么你可以将这两个元素交换。你可以执行这个操作 <strong>任意次</strong>&nbsp;（<strong>也可以 0 次</strong>）。</p>\n\n<p>如果你可以使数组变为非降序，请你返回&nbsp;<code>true</code> ，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [8,4,2,30,15]\n<b>输出：</b>true\n<b>解释：</b>我们先观察每个元素的二进制表示。 2 ，4 和 8 分别都只有一个数位为 1 ，分别为 \"10\" ，\"100\" 和 \"1000\" 。15 和 30 分别有 4 个数位为 1 ：\"1111\" 和 \"11110\" 。\n我们可以通过 4 个操作使数组非降序：\n- 交换 nums[0] 和 nums[1] 。8 和 4 分别只有 1 个数位为 1 。数组变为 [4,8,2,30,15] 。\n- 交换 nums[1] 和 nums[2] 。8 和 2 分别只有 1 个数位为 1 。数组变为 [4,2,8,30,15] 。\n- 交换 nums[0] 和 nums[1] 。4 和 2 分别只有 1 个数位为 1 。数组变为 [2,4,8,30,15] 。\n- 交换 nums[3] 和 nums[4] 。30 和 15 分别有 4 个数位为 1 ，数组变为 [2,4,8,15,30] 。\n数组变成有序的，所以我们返回 true 。\n注意我们还可以通过其他的操作序列使数组变得有序。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>true\n<b>解释：</b>数组已经是非降序的，所以我们返回 true 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,16,8,4,2]\n<b>输出：</b>false\n<b>解释：</b>无法通过操作使数组变为非降序。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3012.通过操作使数组长度最小",
        "hardRate": "MEDIUM",
        "passRate": "30.88%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-length-of-array-using-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-length-of-array-using-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它只包含 <strong>正</strong>&nbsp;整数。</p>\n\n<p>你的任务是通过进行以下操作&nbsp;<strong>任意次</strong>&nbsp;（可以是 0 次）&nbsp;<strong>最小化</strong>&nbsp;<code>nums</code>&nbsp;的长度：</p>\n\n<ul>\n\t<li>在 <code>nums</code>&nbsp;中选择 <strong>两个不同</strong>&nbsp;的下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;，满足&nbsp;<code>nums[i] &gt; 0</code>&nbsp;且&nbsp;<code>nums[j] &gt; 0</code>&nbsp;。</li>\n\t<li>将结果&nbsp;<code>nums[i] % nums[j]</code>&nbsp;插入&nbsp;<code>nums</code>&nbsp;的结尾。</li>\n\t<li>将 <code>nums</code>&nbsp;中下标为&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;的元素删除。</li>\n</ul>\n\n<p>请你返回一个整数，它表示进行任意次操作以后<em>&nbsp;</em><code>nums</code>&nbsp;的 <strong>最小长度</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,3,1]\n<b>输出：</b>1\n<b>解释：</b>使数组长度最小的一种方法是：\n操作 1 ：选择下标 2 和 1 ，插入 nums[2] % nums[1] 到数组末尾，得到 [1,4,3,1,3] ，然后删除下标为 2 和 1 的元素。\nnums 变为 [1,1,3] 。\n操作 2 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [1,1,3,1] ，然后删除下标为 1 和 2 的元素。\nnums 变为 [1,1] 。\n操作 3 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [1,1,0] ，然后删除下标为 1 和 0 的元素。\nnums 变为 [0] 。\nnums 的长度无法进一步减小，所以答案为 1 。\n1 是可以得到的最小长度。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,5,5,10,5]\n<b>输出：</b>2\n<b>解释：</b>使数组长度最小的一种方法是：\n操作 1 ：选择下标 0 和 3 ，插入 nums[0] % nums[3] 到数组末尾，得到 [5,5,5,10,5,5] ，然后删除下标为 0 和 3 的元素。\nnums 变为 [5,5,5,5] 。\n操作 2 ：选择下标 2 和 3 ，插入 nums[2] % nums[3] 到数组末尾，得到 [5,5,5,5,0] ，然后删除下标为 2 和 3 的元素。\nnums 变为 [5,5,0] 。\n操作 3 ：选择下标 0 和 1 ，插入 nums[0] % nums[1] 到数组末尾，得到 [5,5,0,0] ，然后删除下标为 0 和 1 的元素。\nnums 变为 [0,0] 。\nnums 的长度无法进一步减小，所以答案为 2 。\n2 是可以得到的最小长度。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,4]\n<b>输出：</b>1\n<b>解释：</b>使数组长度最小的一种方法是：\n操作 1 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [2,3,4,3] ，然后删除下标为 1 和 2 的元素。\nnums 变为 [2,3] 。\n操作 2 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [2,3,1] ，然后删除下标为 1 和 0 的元素。\nnums 变为 [1] 。\nnums 的长度无法进一步减小，所以答案为 1 。\n1 是可以得到的最小长度。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3013.将数组分成最小总代价的子数组 II",
        "hardRate": "HARD",
        "passRate": "36.28%",
        "problemsUrl": "https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和两个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code> 和&nbsp;<code>dist</code>&nbsp;。</p>\n\n<p>一个数组的 <strong>代价</strong>&nbsp;是数组中的 <strong>第一个</strong>&nbsp;元素。比方说，<code>[1,2,3]</code>&nbsp;的代价为&nbsp;<code>1</code>&nbsp;，<code>[3,4,1]</code>&nbsp;的代价为&nbsp;<code>3</code>&nbsp;。</p>\n\n<p>你需要将 <code>nums</code>&nbsp;分割成 <code>k</code>&nbsp;个 <strong>连续且互不相交</strong>&nbsp;的<span data-keyword=\"subarray\">子数组</span>，满足 <strong>第二</strong>&nbsp;个子数组与第 <code>k</code>&nbsp;个子数组中第一个元素的下标距离 <strong>不超过</strong>&nbsp;<code>dist</code>&nbsp;。换句话说，如果你将&nbsp;<code>nums</code>&nbsp;分割成子数组&nbsp;<code>nums[0..(i<sub>1</sub> - 1)], nums[i<sub>1</sub>..(i<sub>2</sub> - 1)], ..., nums[i<sub>k-1</sub>..(n - 1)]</code>&nbsp;，那么它需要满足&nbsp;<code>i<sub>k-1</sub> - i<sub>1</sub> &lt;= dist</code>&nbsp;。</p>\n\n<p>请你返回这些子数组的 <strong>最小</strong>&nbsp;总代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,2,6,4,2], k = 3, dist = 3\n<b>输出：</b>5\n<b>解释：</b>将数组分割成 3 个子数组的最优方案是：[1,3] ，[2,6,4] 和 [2] 。这是一个合法分割，因为 i<sub>k-1</sub> - i<sub>1</sub> 等于 5 - 2 = 3 ，等于 dist 。总代价为 nums[0] + nums[2] + nums[5] ，也就是 1 + 2 + 2 = 5 。\n5 是分割成 3 个子数组的最小总代价。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,1,2,2,2,1], k = 4, dist = 3\n<b>输出：</b>15\n<b>解释：</b>将数组分割成 4 个子数组的最优方案是：[10] ，[1] ，[2] 和 [2,2,1] 。这是一个合法分割，因为 i<sub>k-1</sub> - i<sub>1</sub> 等于 3 - 1 = 2 ，小于 dist 。总代价为 nums[0] + nums[1] + nums[2] + nums[3] ，也就是 10 + 1 + 2 + 2 = 15 。\n分割 [10] ，[1] ，[2,2,2] 和 [1] 不是一个合法分割，因为 i<sub>k-1</sub> 和 i<sub>1</sub> 的差为 5 - 1 = 4 ，大于 dist 。\n15 是分割成 4 个子数组的最小总代价。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,8,18,9], k = 3, dist = 1\n<b>输出：</b>36\n<b>解释：</b>将数组分割成 4 个子数组的最优方案是：[10] ，[8] 和 [18,9] 。这是一个合法分割，因为 i<sub>k-1</sub> - i<sub>1</sub> 等于 2 - 1 = 1 ，等于 dist 。总代价为 nums[0] + nums[1] + nums[2] ，也就是 10 + 8 + 18 = 36 。\n分割 [10] ，[8,18] 和 [9] 不是一个合法分割，因为 i<sub>k-1</sub> 和 i<sub>1</sub> 的差为 3 - 1 = 2 ，大于 dist 。\n36 是分割成 3 个子数组的最小总代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>3 &lt;= k &lt;= n</code></li>\n\t<li><code>k - 2 &lt;= dist &lt;= n - 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3014.输入单词需要的最少按键次数 I",
        "hardRate": "EASY",
        "passRate": "59.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-i/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-i/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code>，由 <strong>不同 </strong>小写英文字母组成。</p>\n\n<p>电话键盘上的按键与 <strong>不同 </strong>小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 <code>2</code> 对应 <code>[\"a\",\"b\",\"c\"]</code>，我们需要按一次键来输入 <code>\"a\"</code>，按两次键来输入 <code>\"b\"</code>，按三次键来输入 <code>\"c\"</code><em>。</em></p>\n\n<p>现在允许你将编号为 <code>2</code> 到 <code>9</code> 的按键重新映射到 <strong>不同 </strong>字母集合。每个按键可以映射到<strong> 任意数量 </strong>的字母，但每个字母 <strong>必须</strong> <strong>恰好</strong> 映射到 <strong>一个 </strong>按键上。你需要找到输入字符串 <code>word</code> 所需的<strong> 最少 </strong>按键次数。</p>\n\n<p>返回重新映射按键后输入 <code>word</code> 所需的 <strong>最少 </strong>按键次数。</p>\n\n<p>下面给出了一种电话键盘上字母到按键的映射作为示例。注意 <code>1</code>，<code>*</code>，<code>#</code> 和 <code>0</code> <strong>不</strong> 对应任何字母。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png\" style=\"width: 329px; height: 313px;\" />\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png\" style=\"width: 329px; height: 313px;\" />\n<pre>\n<strong>输入：</strong>word = \"abcde\"\n<strong>输出：</strong>5\n<strong>解释：</strong>图片中给出的重新映射方案的输入成本最小。\n\"a\" -&gt; 在按键 2 上按一次\n\"b\" -&gt; 在按键 3 上按一次\n\"c\" -&gt; 在按键 4 上按一次\n\"d\" -&gt; 在按键 5 上按一次\n\"e\" -&gt; 在按键 6 上按一次\n总成本为 1 + 1 + 1 + 1 + 1 = 5 。\n可以证明不存在其他成本更低的映射方案。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/26/keypadv1e2.png\" style=\"width: 329px; height: 313px;\" />\n<pre>\n<strong>输入：</strong>word = \"xycdefghij\"\n<strong>输出：</strong>12\n<strong>解释：</strong>图片中给出的重新映射方案的输入成本最小。\n\"x\" -&gt; 在按键 2 上按一次\n\"y\" -&gt; 在按键 2 上按两次\n\"c\" -&gt; 在按键 3 上按一次\n\"d\" -&gt; 在按键 3 上按两次\n\"e\" -&gt; 在按键 4 上按一次\n\"f\" -&gt; 在按键 5 上按一次\n\"g\" -&gt; 在按键 6 上按一次\n\"h\" -&gt; 在按键 7 上按一次\n\"i\" -&gt; 在按键 8 上按一次\n\"j\" -&gt; 在按键 9 上按一次\n总成本为 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12 。\n可以证明不存在其他成本更低的映射方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 26</code></li>\n\t<li><code>word</code> 仅由小写英文字母组成。</li>\n\t<li><code>word</code> 中的所有字母互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3015.按距离统计房屋对数目 I",
        "hardRate": "MEDIUM",
        "passRate": "44.42%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-i/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-i/solution",
        "problemsDesc": "<p>给你三个<strong> 正整数 </strong><code>n</code> 、<code>x</code> 和 <code>y</code> 。</p>\n\n<p>在城市中，存在编号从 <code>1</code> 到 <code>n</code> 的房屋，由 <code>n</code> 条街道相连。对所有 <code>1 &lt;= i &lt; n</code> ，都存在一条街道连接编号为 <code>i</code> 的房屋与编号为 <code>i + 1</code> 的房屋。另存在一条街道连接编号为 <code>x</code> 的房屋与编号为 <code>y</code> 的房屋。</p>\n\n<p>对于每个 <code>k</code>（<code>1 &lt;= k &lt;= n</code>），你需要找出所有满足要求的 <strong>房屋对 </strong><code>[house<sub>1</sub>, house<sub>2</sub>]</code> ，即从 <code>house<sub>1</sub></code> 到 <code>house<sub>2</sub></code> 需要经过的<strong> 最少</strong> 街道数为 <code>k</code> 。</p>\n\n<p>返回一个下标从 <strong>1</strong> 开始且长度为 <code>n</code> 的数组 <code>result</code> ，其中 <code>result[k]</code> 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的<strong> 最少 </strong>街道数为 <code>k</code> 。</p>\n\n<p><strong>注意</strong>，<code>x</code> 与 <code>y</code> 可以 <strong>相等 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example2.png\" style=\"width: 474px; height: 197px;\" />\n<pre>\n<strong>输入：</strong>n = 3, x = 1, y = 3\n<strong>输出：</strong>[6,0,0]\n<strong>解释：</strong>让我们检视每个房屋对\n- 对于房屋对 (1, 2)，可以直接从房屋 1 到房屋 2。\n- 对于房屋对 (2, 1)，可以直接从房屋 2 到房屋 1。\n- 对于房屋对 (1, 3)，可以直接从房屋 1 到房屋 3。\n- 对于房屋对 (3, 1)，可以直接从房屋 3 到房屋 1。\n- 对于房屋对 (2, 3)，可以直接从房屋 2 到房屋 3。\n- 对于房屋对 (3, 2)，可以直接从房屋 3 到房屋 2。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example3.png\" style=\"width: 668px; height: 174px;\" />\n<pre>\n<strong>输入：</strong>n = 5, x = 2, y = 4\n<strong>输出：</strong>[10,8,2,0,0]\n<strong>解释：</strong>对于每个距离 k ，满足要求的房屋对如下：\n- 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), 以及 (5, 4)。\n- 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), 以及 (5, 3)。\n- 对于 k == 3，满足要求的房屋对有 (1, 5)，以及 (5, 1) 。\n- 对于 k == 4 和 k == 5，不存在满足要求的房屋对。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example5.png\" style=\"width: 544px; height: 130px;\" />\n<pre>\n<strong>输入：</strong>n = 4, x = 1, y = 1\n<strong>输出：</strong>[6,4,2,0]\n<strong>解释：</strong>对于每个距离 k ，满足要求的房屋对如下：\n- 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), 以及 (4, 3)。\n- 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (2, 4), 以及 (4, 2)。\n- 对于 k == 3，满足要求的房屋对有 (1, 4), 以及 (4, 1)。\n- 对于 k == 4，不存在满足要求的房屋对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= x, y &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3016.输入单词需要的最少按键次数 II",
        "hardRate": "MEDIUM",
        "passRate": "67.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-ii/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code>，由小写英文字母组成。</p>\n\n<p>电话键盘上的按键与 <strong>不同 </strong>小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 <code>2</code> 对应 <code>[\"a\",\"b\",\"c\"]</code>，我们需要按一次键来输入 <code>\"a\"</code>，按两次键来输入 <code>\"b\"</code>，按三次键来输入 <code>\"c\"</code><em>。</em></p>\n\n<p>现在允许你将编号为 <code>2</code> 到 <code>9</code> 的按键重新映射到 <strong>不同 </strong>字母集合。每个按键可以映射到<strong> 任意数量 </strong>的字母，但每个字母 <strong>必须</strong> <strong>恰好</strong> 映射到 <strong>一个 </strong>按键上。你需要找到输入字符串 <code>word</code> 所需的<strong> 最少 </strong>按键次数。</p>\n\n<p>返回重新映射按键后输入 <code>word</code> 所需的 <strong>最少 </strong>按键次数。</p>\n\n<p>下面给出了一种电话键盘上字母到按键的映射作为示例。注意 <code>1</code>，<code>*</code>，<code>#</code> 和 <code>0</code> <strong>不</strong> 对应任何字母。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png\" style=\"width: 329px; height: 313px;\" />\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png\" style=\"width: 329px; height: 313px;\" />\n<pre>\n<strong>输入：</strong>word = \"abcde\"\n<strong>输出：</strong>5\n<strong>解释：</strong>图片中给出的重新映射方案的输入成本最小。\n\"a\" -&gt; 在按键 2 上按一次\n\"b\" -&gt; 在按键 3 上按一次\n\"c\" -&gt; 在按键 4 上按一次\n\"d\" -&gt; 在按键 5 上按一次\n\"e\" -&gt; 在按键 6 上按一次\n总成本为 1 + 1 + 1 + 1 + 1 = 5 。\n可以证明不存在其他成本更低的映射方案。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/26/keypadv2e2.png\" style=\"width: 329px; height: 313px;\" />\n<pre>\n<strong>输入：</strong>word = \"xyzxyzxyzxyz\"\n<strong>输出：</strong>12\n<strong>解释：</strong>图片中给出的重新映射方案的输入成本最小。\n\"x\" -&gt; 在按键 2 上按一次\n\"y\" -&gt; 在按键 3 上按一次\n\"z\" -&gt; 在按键 4 上按一次\n总成本为 1 * 4 + 1 * 4 + 1 * 4 = 12 。\n可以证明不存在其他成本更低的映射方案。\n注意按键 9 没有映射到任何字母：不必让每个按键都存在与之映射的字母，但是每个字母都必须映射到按键上。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/27/keypadv2.png\" style=\"width: 329px; height: 313px;\" />\n<pre>\n<strong>输入：</strong>word = \"aabbccddeeffgghhiiiiii\"\n<strong>输出：</strong>24\n<strong>解释：</strong>图片中给出的重新映射方案的输入成本最小。\n\"a\" -&gt; 在按键 2 上按一次\n\"b\" -&gt; 在按键 3 上按一次\n\"c\" -&gt; 在按键 4 上按一次\n\"d\" -&gt; 在按键 5 上按一次\n\"e\" -&gt; 在按键 6 上按一次\n\"f\" -&gt; 在按键 7 上按一次\n\"g\" -&gt; 在按键 8 上按一次\n\"h\" -&gt; 在按键 9 上按两次\n\"i\" -&gt; 在按键 9 上按一次\n总成本为 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24 。\n可以证明不存在其他成本更低的映射方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3017.按距离统计房屋对数目 II",
        "hardRate": "HARD",
        "passRate": "27.04%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-ii/solution",
        "problemsDesc": "<p>给你三个<strong> 正整数 </strong><code>n</code> 、<code>x</code> 和 <code>y</code> 。</p>\n\n<p>在城市中，存在编号从 <code>1</code> 到 <code>n</code> 的房屋，由 <code>n</code> 条街道相连。对所有 <code>1 &lt;= i &lt; n</code> ，都存在一条街道连接编号为 <code>i</code> 的房屋与编号为 <code>i + 1</code> 的房屋。另存在一条街道连接编号为 <code>x</code> 的房屋与编号为 <code>y</code> 的房屋。</p>\n\n<p>对于每个 <code>k</code>（<code>1 &lt;= k &lt;= n</code>），你需要找出所有满足要求的 <strong>房屋对 </strong><code>[house<sub>1</sub>, house<sub>2</sub>]</code> ，即从 <code>house<sub>1</sub></code> 到 <code>house<sub>2</sub></code> 需要经过的<strong> 最少</strong> 街道数为 <code>k</code> 。</p>\n\n<p>返回一个下标从 <strong>1</strong> 开始且长度为 <code>n</code> 的数组 <code>result</code> ，其中 <code>result[k]</code> 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的<strong> 最少 </strong>街道数为 <code>k</code> 。</p>\n\n<p><strong>注意</strong>，<code>x</code> 与 <code>y</code> 可以 <strong>相等 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example2.png\" style=\"width: 474px; height: 197px;\" />\n<pre>\n<strong>输入：</strong>n = 3, x = 1, y = 3\n<strong>输出：</strong>[6,0,0]\n<strong>解释：</strong>让我们检视每个房屋对\n- 对于房屋对 (1, 2)，可以直接从房屋 1 到房屋 2。\n- 对于房屋对 (2, 1)，可以直接从房屋 2 到房屋 1。\n- 对于房屋对 (1, 3)，可以直接从房屋 1 到房屋 3。\n- 对于房屋对 (3, 1)，可以直接从房屋 3 到房屋 1。\n- 对于房屋对 (2, 3)，可以直接从房屋 2 到房屋 3。\n- 对于房屋对 (3, 2)，可以直接从房屋 3 到房屋 2。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example3.png\" style=\"width: 668px; height: 174px;\" />\n<pre>\n<strong>输入：</strong>n = 5, x = 2, y = 4\n<strong>输出：</strong>[10,8,2,0,0]\n<strong>解释：</strong>对于每个距离 k ，满足要求的房屋对如下：\n- 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), 以及 (5, 4)。\n- 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), 以及 (5, 3)。\n- 对于 k == 3，满足要求的房屋对有 (1, 5)，以及 (5, 1) 。\n- 对于 k == 4 和 k == 5，不存在满足要求的房屋对。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/20/example5.png\" style=\"width: 544px; height: 130px;\" />\n<pre>\n<strong>输入：</strong>n = 4, x = 1, y = 1\n<strong>输出：</strong>[6,4,2,0]\n<strong>解释：</strong>对于每个距离 k ，满足要求的房屋对如下：\n- 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), 以及 (4, 3)。\n- 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (2, 4), 以及 (4, 2)。\n- 对于 k == 3，满足要求的房屋对有 (1, 4), 以及 (4, 1)。\n- 对于 k == 4，不存在满足要求的房屋对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, y &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3018.可处理的最大删除操作数 I",
        "hardRate": "HARD",
        "passRate": "61.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-removal-queries-that-can-be-processed-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-removal-queries-that-can-be-processed-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3019.按键变更的次数",
        "hardRate": "EASY",
        "passRate": "85.07%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-changing-keys/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-changing-keys/solution",
        "problemsDesc": "<p>给你一个下标从<strong> 0</strong> 开始的字符串 <code>s</code> ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 <code>s = \"ab\"</code> 表示按键变更一次，而 <code>s = \"bBBb\"</code> 不存在按键变更。</p>\n\n<p>返回用户输入过程中按键变更的次数。</p>\n\n<p><strong>注意：</strong><code>shift</code> 或 <code>caps lock</code> 等修饰键不计入按键变更，也就是说，如果用户先输入字母 <code>'a'</code> 然后输入字母 <code>'A'</code> ，不算作按键变更。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aAbBcC\"\n<strong>输出：</strong>2\n<strong>解释：</strong> \n从 s[0] = 'a' 到 s[1] = 'A'，不存在按键变更，因为不计入 caps lock 或 shift 。\n从 s[1] = 'A' 到 s[2] = 'b'，按键变更。\n从 s[2] = 'b' 到 s[3] = 'B'，不存在按键变更，因为不计入 caps lock 或 shift 。\n从 s[3] = 'B' 到 s[4] = 'c'，按键变更。\n从 s[4] = 'c' 到 s[5] = 'C'，不存在按键变更，因为不计入 caps lock 或 shift 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AaAaAaaA\"\n<strong>输出：</strong>0\n<strong>解释：</strong> 不存在按键变更，因为这个过程中只按下字母 'a' 和 'A' ，不需要进行按键变更。<!-- notionvc: 8849fe75-f31e-41dc-a2e0-b7d33d8427d2 -->\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由英文大写字母和小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3020.子集中元素的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "27.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-elements-in-subset/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-elements-in-subset/solution",
        "problemsDesc": "<p>给你一个<strong> 正整数 </strong>数组 <code>nums</code> 。</p>\n\n<p>你需要从数组中选出一个满足下述条件的<span data-keyword=\"subset\">子集</span>：</p>\n\n<ul>\n\t<li>你可以将选中的元素放置在一个下标从 <strong>0</strong> 开始的数组中，并使其遵循以下模式：<code>[x, x<sup>2</sup>, x<sup>4</sup>, ..., x<sup>k/2</sup>, x<sup>k</sup>, x<sup>k/2</sup>, ..., x<sup>4</sup>, x<sup>2</sup>, x]</code>（<strong>注意</strong>，<code>k</code> 可以是任何 <strong>非负</strong> 的 2 的幂）。例如，<code>[2, 4, 16, 4, 2]</code> 和 <code>[3, 9, 3]</code> 都符合这一模式，而 <code>[2, 4, 8, 4, 2]</code> 则不符合。</li>\n</ul>\n\n<p>返回满足这些条件的子集中，元素数量的 <strong>最大值 </strong><em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,4,1,2,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>选择子集 {4,2,2} ，将其放在数组 [2,4,2] 中，它遵循该模式，且 2<sup>2</sup> == 4 。因此答案是 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>选择子集 {1}，将其放在数组 [1] 中，它遵循该模式。因此答案是 1 。注意我们也可以选择子集 {2} 、{4} 或 {3} ，可能存在多个子集都能得到相同的答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3021.Alice 和 Bob 玩鲜花游戏",
        "hardRate": "MEDIUM",
        "passRate": "49.09%",
        "problemsUrl": "https://leetcode.cn/problems/alice-and-bob-playing-flower-game/",
        "solutionsUrl": "https://leetcode.cn/problems/alice-and-bob-playing-flower-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到&nbsp;Bob 之间顺时针有 <code>x</code>&nbsp;朵鲜花，逆时针有 <code>y</code>&nbsp;朵鲜花。</p>\n\n<p>游戏过程如下：</p>\n\n<ol>\n\t<li>Alice 先行动。</li>\n\t<li>每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。</li>\n\t<li>一次行动结束后，如果所有鲜花都被摘完了，那么 <strong>当前</strong>&nbsp;玩家抓住对手并赢得游戏的胜利。</li>\n</ol>\n\n<p>给你两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>m</code>&nbsp;，你的任务是求出满足以下条件的所有&nbsp;<code>(x, y)</code>&nbsp;对：</p>\n\n<ul>\n\t<li>按照上述规则，Alice 必须赢得游戏。</li>\n\t<li>Alice 顺时针方向上的鲜花数目&nbsp;<code>x</code>&nbsp;必须在区间&nbsp;<code>[1,n]</code>&nbsp;之间。</li>\n\t<li>Alice 逆时针方向上的鲜花数目 <code>y</code>&nbsp;必须在区间&nbsp;<code>[1,m]</code>&nbsp;之间。</li>\n</ul>\n\n<p>请你返回满足题目描述的数对&nbsp;<code>(x, y)</code>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, m = 2\n<b>输出：</b>3\n<b>解释：</b>以下数对满足题目要求：(1,2) ，(3,2) ，(2,1) 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1, m = 1\n<b>输出：</b>0\n<b>解释：</b>没有数对满足题目要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3022.给定操作次数内使剩余元素的或值最小",
        "hardRate": "HARD",
        "passRate": "38.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-or-of-remaining-elements-using-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-or-of-remaining-elements-using-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>一次操作中，你可以选择 <code>nums</code>&nbsp;中满足&nbsp;<code>0 &lt;= i &lt; nums.length - 1</code>&nbsp;的一个下标 <code>i</code>&nbsp;，并将&nbsp;<code>nums[i]</code> 和&nbsp;<code>nums[i + 1]</code>&nbsp;替换为数字&nbsp;<code>nums[i] &amp; nums[i + 1]</code>&nbsp;，其中&nbsp;<code>&amp;</code>&nbsp;表示按位&nbsp;<code>AND</code>&nbsp;操作。</p>\n\n<p>请你返回 <strong>至多</strong>&nbsp;<code>k</code>&nbsp;次操作以内，使 <code>nums</code>&nbsp;中所有剩余元素按位 <code>OR</code>&nbsp;结果的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,5,3,2,7], k = 2\n<b>输出：</b>3\n<b>解释：</b>执行以下操作：\n1. 将 nums[0] 和 nums[1] 替换为 (nums[0] &amp; nums[1]) ，得到 nums 为 [1,3,2,7] 。\n2. 将 nums[2] 和 nums[3] 替换为 (nums[2] &amp; nums[3]) ，得到 nums 为 [1,3,2] 。\n最终数组的按位或值为 3 。\n3 是 k 次操作以内，可以得到的剩余元素的最小按位或值。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,3,15,14,2,8], k = 4\n<b>输出：</b>2\n<b>解释：</b>执行以下操作：\n1. 将 nums[0] 和 nums[1] 替换为 (nums[0] &amp; nums[1]) ，得到 nums 为 [3,15,14,2,8] 。\n2. 将 nums[0] 和 nums[1] 替换为 (nums[0] &amp; nums[1]) ，得到 nums 为 [3,14,2,8] 。\n3. 将 nums[0] 和 nums[1] 替换为 (nums[0] &amp; nums[1]) ，得到 nums 为 [2,2,8] 。\n4. 将 nums[1] 和 nums[2] 替换为 (nums[1] &amp; nums[2]) ，得到 nums 为 [2,0] 。\n最终数组的按位或值为 2 。\n2 是 k 次操作以内，可以得到的剩余元素的最小按位或值。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,7,10,3,9,14,9,4], k = 1\n<b>输出：</b>15\n<b>解释：</b>不执行任何操作，nums 的按位或值为 15 。\n15 是 k 次操作以内，可以得到的剩余元素的最小按位或值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>30</sup></code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3023.在无限流中寻找模式 I",
        "hardRate": "MEDIUM",
        "passRate": "48.78%",
        "problemsUrl": "https://leetcode.cn/problems/find-pattern-in-infinite-stream-i/",
        "solutionsUrl": "https://leetcode.cn/problems/find-pattern-in-infinite-stream-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3024.三角形类型",
        "hardRate": "EASY",
        "passRate": "64.06%",
        "problemsUrl": "https://leetcode.cn/problems/type-of-triangle/",
        "solutionsUrl": "https://leetcode.cn/problems/type-of-triangle/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>3</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，需要用它们来构造三角形。</p>\n\n<ul>\n\t<li>如果一个三角形的所有边长度相等，那么这个三角形称为&nbsp;<strong>equilateral</strong>&nbsp;。</li>\n\t<li>如果一个三角形恰好有两条边长度相等，那么这个三角形称为&nbsp;<strong>isosceles</strong>&nbsp;。</li>\n\t<li>如果一个三角形三条边的长度互不相同，那么这个三角形称为&nbsp;<strong>scalene</strong>&nbsp;。</li>\n</ul>\n\n<p>如果这个数组无法构成一个三角形，请你返回字符串&nbsp;<code>\"none\"</code>&nbsp;，否则返回一个字符串表示这个三角形的类型。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,3,3]\n<b>输出：</b>\"equilateral\"\n<b>解释：</b>由于三条边长度相等，所以可以构成一个等边三角形，返回 \"equilateral\" 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,4,5]\n<b>输出：</b>\"scalene\"\n<b>解释：</b>\nnums[0] + nums[1] = 3 + 4 = 7 ，大于 nums[2] = 5 <span style=\"text-wrap: wrap;\">。</span>\nnums[0] + nums[2] = 3 + 5 = 8 ，大于 nums[1] = 4 。\nnums[1] + nums[2] = 4 + 5 = 9 ，大于 nums[0] = 3 。\n由于任意两边之和都大于第三边，所以可以构成一个三角形，因为三条边的长度互不相等，所以返回 \"scalene\"。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 3</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3025.人员站位的方案数 I",
        "hardRate": "MEDIUM",
        "passRate": "46.11%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/solution",
        "problemsDesc": "<p>给你一个&nbsp;&nbsp;<code>n x 2</code>&nbsp;的二维数组 <code>points</code>&nbsp;，它表示二维平面上的一些点坐标，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p>计算点对&nbsp;<code>(A, B)</code>&nbsp;的数量，其中</p>\n\n<ul>\n\t<li><code>A</code> 在 <code>B</code> 的左上角，并且</li>\n\t<li>它们形成的长方形中（或直线上）没有其它点（<strong>包括边界</strong>）。</li>\n</ul>\n\n<p>返回数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>points = [[1,1],[2,2],[3,3]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>0</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2024/01/04/example1alicebob.png\" style=\"width: 427px; height: 350px;\" /></p>\n\n<p>没有办法选择&nbsp;<code>A</code> 和&nbsp;<code>B</code>，使得&nbsp;<code>A</code>&nbsp;在&nbsp;<code>B</code>&nbsp;的左上角。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b></span><span class=\"example-io\">points = [[6,2],[4,4],[2,6]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b></span><span class=\"example-io\">2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><img height=\"365\" src=\"https://assets.leetcode.com/uploads/2024/06/25/t2.jpg\" width=\"1321\" /></p>\n\n<ul>\n\t<li>左边的是点对&nbsp;<code>(points[1], points[0])</code>，其中&nbsp;<code>points[1]</code>&nbsp;在&nbsp;<code>points[0]</code>&nbsp;的左上角，并且形成的长方形内部是空的。</li>\n\t<li>中间的是点对&nbsp;<code>(points[2], points[1])</code>，和左边的一样是合法的点对。</li>\n\t<li>右边的是点对 <code>(points[2], points[0])</code>，其中 <code>points[2]</code> 在 <code>points[0]</code>&nbsp;的左上角，但&nbsp;<code>points[1]</code>&nbsp;在长方形内部，所以不是一个合法的点对。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b></span><span class=\"example-io\">points = [[3,1],[1,3],[1,1]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b></span><span class=\"example-io\">2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2024/06/25/t3.jpg\" style=\"width: 1269px; height: 350px;\" /></p>\n\n<ul>\n\t<li>左边的是点对 <code>(points[2], points[0])</code>，其中&nbsp;<code>points[2]</code>&nbsp;在&nbsp;<code>points[0]</code>&nbsp;的左上角并且在它们形成的直线上没有其它点。注意两个点形成一条线的情况是合法的。</li>\n\t<li>中间的是点对 <code>(points[1], points[2])</code>，和左边一样也是合法的点对。</li>\n\t<li>右边的是点对 <code>(points[1], points[0])</code>，它不是合法的点对，因为&nbsp;<code>points[2]</code>&nbsp;在长方形的边上。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 50</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= points[i][0], points[i][1] &lt;= 50</code></li>\n\t<li><code>points[i]</code>&nbsp;点对两两不同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3026.最大好子数组和",
        "hardRate": "MEDIUM",
        "passRate": "26.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-good-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-good-subarray-sum/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果&nbsp;<code>nums</code>&nbsp;的一个<span data-keyword=\"subarray\">子数组</span>中，第一个元素和最后一个元素 <strong>差的绝对值恰好</strong>&nbsp;为&nbsp;<code>k</code>&nbsp;，我们称这个子数组为&nbsp;<strong>好</strong>&nbsp;的。换句话说，如果子数组&nbsp;<code>nums[i..j]</code>&nbsp;满足&nbsp;<code>|nums[i] - nums[j]| == k</code>&nbsp;，那么它是一个好子数组。</p>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>好</strong>&nbsp;子数组的&nbsp;<strong>最大</strong>&nbsp;和，如果没有好子数组，返回<em>&nbsp;</em><code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5,6], k = 1\n<b>输出：</b>11\n<b>解释：</b>好子数组中第一个元素和最后一个元素的差的绝对值必须为 1 。好子数组有 [1,2] ，[2,3] ，[3,4] ，[4,5] 和 [5,6] 。最大子数组和为 11 ，对应的子数组为 [5,6] 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-1,3,2,4,5], k = 3\n<b>输出：</b>11\n<b>解释：</b>好子数组中第一个元素和最后一个元素的差的绝对值必须为 3 。好子数组有 [-1,3,2] 和 [2,4,5] 。最大子数组和为 11 ，对应的子数组为 [2,4,5] 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-1,-2,-3,-4], k = 2\n<b>输出：</b>-6\n<b>解释：</b>好子数组中第一个元素和最后一个元素的差的绝对值必须为 2 。好子数组有 [-1,-2,-3] 和 [-2,-3,-4] 。最大子数组和为 -6 ，对应的子数组为 [-1,-2,-3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3027.人员站位的方案数 II",
        "hardRate": "HARD",
        "passRate": "43.36%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/solution",
        "problemsDesc": "<p>给你一个&nbsp;&nbsp;<code>n x 2</code>&nbsp;的二维数组 <code>points</code>&nbsp;，它表示二维平面上的一些点坐标，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>我们定义 x 轴的正方向为 <strong>右</strong>&nbsp;（<strong>x 轴递增的方向</strong>），x 轴的负方向为 <strong>左</strong>&nbsp;（<strong>x 轴递减的方向</strong>）。类似的，我们定义 y 轴的正方向为 <strong>上</strong>&nbsp;（<strong>y 轴递增的方向</strong>），y 轴的负方向为 <strong>下</strong>&nbsp;（<strong>y 轴递减的方向</strong>）。</p>\n\n<p>你需要安排这 <code>n</code>&nbsp;个人的站位，这 <code>n</code>&nbsp;个人中包括 Alice 和 Bob 。你需要确保每个点处&nbsp;<strong>恰好</strong>&nbsp;有&nbsp;<strong>一个</strong>&nbsp;人。同时，Alice 想跟 Bob 单独玩耍，所以&nbsp;Alice 会以 Alice<b>&nbsp;</b>的坐标为 <strong>左上角</strong>&nbsp;，Bob 的坐标为 <strong>右下角</strong>&nbsp;建立一个矩形的围栏（<strong>注意</strong>，围栏可能&nbsp;<strong>不</strong> 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 <strong>内部</strong>&nbsp;或者 <strong>边缘</strong>&nbsp;上有任何其他人，Alice 都会难过。</p>\n\n<p>请你在确保 Alice&nbsp;<strong>不会</strong> 难过的前提下，返回 Alice 和 Bob 可以选择的 <strong>点对</strong>&nbsp;数目。</p>\n\n<p><b>注意</b>，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以&nbsp;<code>(1, 1)</code>&nbsp;，<code>(1, 3)</code>&nbsp;，<code>(3, 1)</code>&nbsp;和&nbsp;<code>(3, 3)</code>&nbsp;为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：</p>\n\n<ul>\n\t<li>图一中，Alice 在&nbsp;<code>(3, 3)</code>&nbsp;且 Bob 在&nbsp;<code>(1, 1)</code>&nbsp;，Alice 的位置不是左上角且 Bob 的位置不是右下角。</li>\n\t<li>图二中，Alice 在&nbsp;<code>(1, 3)</code>&nbsp;且 Bob 在&nbsp;<code>(1, 1)</code>&nbsp;，Bob 的位置不是在围栏的右下角。</li>\n</ul>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/04/example0alicebob-1.png\" style=\"width: 750px; height: 308px;padding: 10px; background: #fff; border-radius: .5rem;\" />\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/04/example1alicebob.png\" style=\"width: 376px; height: 308px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem;\" /></p>\n\n<pre>\n<b>输入：</b>points = [[1,1],[2,2],[3,3]]\n<b>输出：</b>0\n<strong>解释：</strong>没有办法可以让 Alice 的围栏以 Alice 的位置为左上角且 Bob 的位置为右下角。所以我们返回 0 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><strong class=\"example\"><a href=\"https://pic.leetcode.cn/1706880313-YelabI-example2.jpeg\"><img alt=\"\" src=\"https://pic.leetcode.cn/1708226715-CxjXKb-20240218-112338.jpeg\" style=\"width: 900px; height: 248px;\" /></a></strong></p>\n\n<pre>\n<b>输入：</b>points = [[6,2],[4,4],[2,6]]\n<b>输出：</b>2\n<b>解释：</b>总共有 2 种方案安排 Alice 和 Bob 的位置，使得 Alice 不会难过：\n- Alice 站在 (4, 4) ，Bob 站在 (6, 2) 。\n- Alice 站在 (2, 6) ，Bob 站在 (4, 4) 。\n不能安排 Alice 站在 (2, 6) 且 Bob 站在 (6, 2) ，因为站在 (4, 4) 的人处于围栏内。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<p><strong class=\"example\"><a href=\"https://pic.leetcode.cn/1706880311-mtPGYC-example3.jpeg\"><img alt=\"\" src=\"https://pic.leetcode.cn/1708226721-wTbEuK-20240218-112351.jpeg\" style=\"width: 911px; height: 250px;\" /></a></strong></p>\n\n<pre>\n<b>输入：</b>points = [[3,1],[1,3],[1,1]]\n<b>输出：</b>2\n<b>解释：</b>总共有 2 种方案安排 Alice 和 Bob 的位置，使得 Alice 不会难过：\n- Alice 站在 (1, 1) ，Bob 站在 (3, 1) 。\n- Alice 站在 (1, 3) ，Bob 站在 (1, 1) 。\n不能安排 Alice 站在 (1, 3) 且 Bob 站在 (3, 1) ，因为站在 (1, 1) 的人处于围栏内。\n注意围栏是可以不包含任何面积的，上图中第一和第二个围栏都是合法的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= points[i][0], points[i][1] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>points[i]</code>&nbsp;点对两两不同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3028.边界上的蚂蚁",
        "hardRate": "EASY",
        "passRate": "82.38%",
        "problemsUrl": "https://leetcode.cn/problems/ant-on-the-boundary/",
        "solutionsUrl": "https://leetcode.cn/problems/ant-on-the-boundary/solution",
        "problemsDesc": "<p>边界上有一只蚂蚁，它有时向 <strong>左 </strong>走，有时向 <strong>右 </strong>走。</p>\n\n<p>给你一个 <strong>非零</strong> 整数数组 <code>nums</code> 。蚂蚁会按顺序读取 <code>nums</code> 中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：</p>\n\n<ul>\n\t<li>如果 <code>nums[i] &lt; 0</code> ，向 <strong>左</strong> 移动<!-- notionvc: 55fee232-4fc9-445f-952a-f1b979415864 --> <code>-nums[i]</code>单位。</li>\n\t<li>如果 <code>nums[i] &gt; 0</code> ，向 <strong>右</strong> 移动 <code>nums[i]</code>单位。</li>\n</ul>\n\n<p>返回蚂蚁 <strong>返回 </strong>到边界上的次数。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>边界两侧有无限的空间。</li>\n\t<li>只有在蚂蚁移动了 <code>|nums[i]|</code> 单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。<!-- notionvc: 5ff95338-8634-4d02-a085-1e83c0be6fcd --></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,-5]\n<strong>输出：</strong>1\n<strong>解释：</strong>第 1 步后，蚂蚁距边界右侧 2 单位远<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->。\n第 2 步后，蚂蚁距边界右侧 5 单位远<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->。\n第 3 步后，蚂蚁位于边界上。\n所以答案是 1 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,-3,-4]\n<strong>输出：</strong>0\n<strong>解释：</strong>第 1 步后，蚂蚁距边界右侧 3 单位远<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->。\n第 2 步后，蚂蚁距边界右侧 5 单位远<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->。\n第 3 步后，蚂蚁距边界右侧 2 单位远<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->。\n第 4 步后，蚂蚁距边界左侧 2 单位远<!-- notionvc: 61ace51c-559f-4bc6-800f-0a0db2540433 -->。\n蚂蚁从未返回到边界上，所以答案是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3029.将单词恢复初始状态所需的最短时间 I",
        "hardRate": "MEDIUM",
        "passRate": "42.65%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-i/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个整数 <code>k</code> 。</p>\n\n<p>在每一秒，你必须执行以下操作：</p>\n\n<ul>\n\t<li>移除 <code>word</code> 的前 <code>k</code> 个字符。</li>\n\t<li>在 <code>word</code> 的末尾添加 <code>k</code> 个任意字符。</li>\n</ul>\n\n<p><strong>注意 </strong>添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 <strong>两种 </strong>操作。</p>\n\n<p>返回将 <code>word</code> 恢复到其 <strong>初始 </strong>状态所需的 <strong>最短 </strong>时间（该时间必须大于零）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abacaba\", k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n第 1 秒，移除 word 的前缀 \"aba\"，并在末尾添加 \"bac\" 。因此，word 变为 \"cababac\"。\n第 2 秒，移除 word 的前缀 \"cab\"，并在末尾添加 \"aba\" 。因此，word 变为 \"abacaba\" 并恢复到始状态。\n可以证明，2 秒是 word 恢复到其初始状态所需的最短时间。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abacaba\", k = 4\n<strong>输出：</strong>1\n<strong>解释：\n</strong>第 1 秒，移除 word 的前缀 \"abac\"，并在末尾添加 \"caba\" 。因此，word 变为 \"abacaba\" 并恢复到初始状态。\n可以证明，1 秒是 word 恢复到其初始状态所需的最短时间。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abcbabcd\", k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>\n每一秒，我们都移除 word 的前 2 个字符，并在 word 末尾添加相同的字符。\n4 秒后，word 变为 \"abcbabcd\" 并恢复到初始状态。\n可以证明，4 秒是 word 恢复到其初始状态所需的最短时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= k &lt;= word.length</code></li>\n\t<li><code>word</code>仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3030.找出网格的区域平均强度",
        "hardRate": "MEDIUM",
        "passRate": "42.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-grid-of-region-average/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-grid-of-region-average/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的网格 <code>image</code> ，表示一个灰度图像，其中 <code>image[i][j]</code> 表示在范围 <code>[0..255]</code> 内的某个像素强度。另给你一个<strong> 非负 </strong>整数 <code>threshold</code> 。</p>\n\n<p>如果 <code>image[a][b]</code> 和 <code>image[c][d]</code> 满足 <code>|a - c| + |b - d| == 1</code> ，则称这两个像素是<strong> 相邻像素</strong> 。</p>\n\n<p><strong>区域 </strong>是一个 <code>3 x 3</code> 的子网格，且满足区域中任意两个 <strong>相邻</strong> 像素之间，像素强度的<strong> 绝对差 </strong><strong> 小于或等于 </strong><code>threshold</code> 。</p>\n\n<p><strong>区域</strong> 内的所有像素都认为属于该区域，而一个像素 <strong>可以 </strong>属于 <strong>多个</strong> 区域。</p>\n\n<p>你需要计算一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的网格 <code>result</code> ，其中 <code>result[i][j]</code> 是 <code>image[i][j]</code> 所属区域的 <strong>平均 </strong>强度，<strong>向下取整 </strong>到最接近的整数。如果 <code>image[i][j]</code> 属于多个区域，<code>result[i][j]</code> 是这些区域的<strong> </strong><strong>“取整后的平均强度”</strong> 的<strong> 平均值</strong>，也 <strong>向下取整 </strong>到最接近的整数。如果 <code>image[i][j]</code> 不属于任何区域，则 <code>result[i][j]</code><strong> 等于 </strong><code>image[i][j]</code> 。</p>\n\n<p>返回网格 <code>result</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/21/example0corrected.png\" style=\"width: 832px; height: 275px;\" />\n<pre>\n<strong>输入：</strong>image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n<strong>输出：</strong>[[9,9,9,9],[9,9,9,9],[9,9,9,9]]\n<strong>解释：</strong>图像中存在两个区域，如图片中的阴影区域所示。第一个区域的平均强度为 9 ，而第二个区域的平均强度为 9.67 ，向下取整为 9 。两个区域的平均强度为 (9 + 9) / 2 = 9 。由于所有像素都属于区域 1 、区域 2 或两者，因此 result 中每个像素的强度都为 9 。\n注意，在计算多个区域的平均值时使用了向下取整的值，因此使用区域 2 的平均强度 9 来进行计算，而不是 9.67 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/21/example1corrected.png\" style=\"width: 805px; height: 377px;\" />\n<pre>\n<strong>输入：</strong>image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n<strong>输出：</strong>[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n<strong>解释：</strong>图像中存在两个区域，如图片中的阴影区域所示。第一个区域的平均强度为 25 ，而第二个区域的平均强度为 30 。两个区域的平均强度为 (25 + 30) / 2 = 27.5 ，向下取整为 27 。图像中第 0 行的所有像素属于区域 1 ，因此 result 中第 0 行的所有像素为 25 。同理，result 中第 3 行的所有像素为 30 。图像中第 1 行和第 2 行的像素属于区域 1 和区域 2 ，因此它们在 result 中的值为 27 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1\n<strong>输出：</strong>[[5,6,7],[8,9,10],[11,12,13]]\n<strong>解释：</strong>图像中不存在任何区域，因此对于所有像素，result[i][j] == image[i][j] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n, m &lt;= 500</code></li>\n\t<li><code>0 &lt;= image[i][j] &lt;= 255</code></li>\n\t<li><code>0 &lt;= threshold &lt;= 255</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3031.将单词恢复初始状态所需的最短时间 II",
        "hardRate": "HARD",
        "passRate": "37.95%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个整数 <code>k</code> 。</p>\n\n<p>在每一秒，你必须执行以下操作：</p>\n\n<ul>\n\t<li>移除 <code>word</code> 的前 <code>k</code> 个字符。</li>\n\t<li>在 <code>word</code> 的末尾添加 <code>k</code> 个任意字符。</li>\n</ul>\n\n<p><strong>注意 </strong>添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行 <strong>两种 </strong>操作。</p>\n\n<p>返回将 <code>word</code> 恢复到其 <strong>初始 </strong>状态所需的 <strong>最短 </strong>时间（该时间必须大于零）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abacaba\", k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n第 1 秒，移除 word 的前缀 \"aba\"，并在末尾添加 \"bac\" 。因此，word 变为 \"cababac\"。\n第 2 秒，移除 word 的前缀 \"cab\"，并在末尾添加 \"aba\" 。因此，word 变为 \"abacaba\" 并恢复到始状态。\n可以证明，2 秒是 word 恢复到其初始状态所需的最短时间。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abacaba\", k = 4\n<strong>输出：</strong>1\n<strong>解释：\n</strong>第 1 秒，移除 word 的前缀 \"abac\"，并在末尾添加 \"caba\" 。因此，word 变为 \"abacaba\" 并恢复到初始状态。\n可以证明，1 秒是 word 恢复到其初始状态所需的最短时间。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abcbabcd\", k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>\n每一秒，我们都移除 word 的前 2 个字符，并在 word 末尾添加相同的字符。\n4 秒后，word 变为 \"abcbabcd\" 并恢复到初始状态。\n可以证明，4 秒是 word 恢复到其初始状态所需的最短时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= word.length</code></li>\n\t<li><code>word</code>仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3032.统计各位数字都不同的数字个数 II",
        "hardRate": "EASY",
        "passRate": "83.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-numbers-with-unique-digits-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-numbers-with-unique-digits-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3033.修改矩阵",
        "hardRate": "EASY",
        "passRate": "83.13%",
        "problemsUrl": "https://leetcode.cn/problems/modify-the-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/modify-the-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>matrix</code> ，新建一个下标从 <strong>0</strong> 开始、名为 <code>answer</code> 的矩阵。使 <code>answer</code> 与 <code>matrix</code> 相等，接着将其中每个值为 <code>-1</code> 的元素替换为所在列的 <strong>最大</strong> 元素。</p>\n\n<p>返回矩阵 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/24/matrix1.png\" style=\"width: 491px; height: 161px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\n<strong>输出：</strong>[[1,2,9],[4,8,6],[7,8,9]]\n<strong>解释：</strong>上图显示了发生替换的元素（蓝色区域）。\n- 将单元格 [1][1] 中的值替换为列 1 中的最大值 8 。\n- 将单元格 [0][2] 中的值替换为列 2 中的最大值 9 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/12/24/matrix2.png\" style=\"width: 411px; height: 111px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[3,-1],[5,2]]\n<strong>输出：</strong>[[3,2],[5,2]]\n<strong>解释：</strong>上图显示了发生替换的元素（蓝色区域）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>-1 &lt;= matrix[i][j] &lt;= 100</code></li>\n\t<li>测试用例中生成的输入满足每列至少包含一个非负整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3034.匹配模式数组的子数组数目 I",
        "hardRate": "MEDIUM",
        "passRate": "71.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-that-match-a-pattern-i/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-that-match-a-pattern-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，和一个下标从 <code>0</code>&nbsp;开始长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>pattern</code>&nbsp;，<code>pattern</code>&nbsp;数组只包含整数&nbsp;<code>-1</code>&nbsp;，<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>大小为 <code>m + 1</code>&nbsp;的<span data-keyword=\"subarray\">子数组</span>&nbsp;<code>nums[i..j]</code>&nbsp;如果对于每个元素 <code>pattern[k]</code>&nbsp;都满足以下条件，那么我们说这个子数组匹配模式数组&nbsp;<code>pattern</code>&nbsp;：</p>\n\n<ul>\n\t<li>如果 <code>pattern[k] == 1</code> ，那么 <code>nums[i + k + 1] &gt; nums[i + k]</code></li>\n\t<li>如果&nbsp;<code>pattern[k] == 0</code>&nbsp;，那么&nbsp;<code>nums[i + k + 1] == nums[i + k]</code></li>\n\t<li>如果&nbsp;<code>pattern[k] == -1</code>&nbsp;，那么&nbsp;<code>nums[i + k + 1] &lt; nums[i + k]</code></li>\n</ul>\n\n<p>请你返回匹配 <code>pattern</code>&nbsp;的 <code>nums</code>&nbsp;子数组的 <strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5,6], pattern = [1,1]\n<b>输出：</b>4\n<b>解释：</b>模式 [1,1] 说明我们要找的子数组是长度为 3 且严格上升的。在数组 nums 中，子数组 [1,2,3] ，[2,3,4] ，[3,4,5] 和 [4,5,6] 都匹配这个模式。\n所以 nums 中总共有 4 个子数组匹配这个模式。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n<b>输出：</b>2\n<strong>解释：</strong>这里，模式数组 [1,0,-1] 说明我们需要找的子数组中，第一个元素小于第二个元素，第二个元素等于第三个元素，第三个元素大于第四个元素。在 nums 中，子数组 [1,4,4,1] 和 [3,5,5,3] 都匹配这个模式。\n所以 nums 中总共有 2 个子数组匹配这个模式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m == pattern.length &lt; n</code></li>\n\t<li><code>-1 &lt;= pattern[i] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3035.回文字符串的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "45.50%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-palindromes-after-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-palindromes-after-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> ，数组的长度为 <code>n</code> ，且包含下标从 <strong>0</strong> 开始的若干字符串。</p>\n\n<p>你可以执行以下操作 <strong>任意 </strong>次数（<strong>包括零次</strong>）：</p>\n\n<ul>\n\t<li>选择整数<code>i</code>、<code>j</code>、<code>x</code>和<code>y</code>，满足<code>0 &lt;= i, j &lt; n</code>，<code>0 &lt;= x &lt; words[i].length</code>，<code>0 &lt;= y &lt; words[j].length</code>，<strong>交换 </strong>字符 <code>words[i][x]</code> 和 <code>words[j][y]</code> 。</li>\n</ul>\n\n<p>返回一个整数，表示在执行一些操作后，<code>words</code> 中可以包含的<span data-keyword=\"palindrome-string\">回文串</span>的 <strong>最大 </strong>数量。</p>\n\n<p><strong>注意：</strong>在操作过程中，<code>i</code> 和 <code>j</code> 可以相等。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abbb\",\"ba\",\"aa\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>在这个例子中，获得最多回文字符串的一种方式是：\n选择 i = 0, j = 1, x = 0, y = 0，交换 words[0][0] 和 words[1][0] 。words 变成了 [\"bbbb\",\"aa\",\"aa\"] 。\nwords 中的所有字符串都是回文。\n因此，可实现的回文字符串的最大数量是 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abc\",\"ab\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>在这个例子中，获得最多回文字符串的一种方式是： \n选择 i = 0, j = 1, x = 1, y = 0，交换 words[0][1] 和 words[1][0] 。words 变成了 [\"aac\",\"bb\"] 。\n选择 i = 0, j = 0, x = 1, y = 2，交换 words[0][1] 和 words[0][2] 。words 变成了 [\"aca\",\"bb\"] 。\n两个字符串都是回文 。\n因此，可实现的回文字符串的最大数量是 2。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"cd\",\"ef\",\"a\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>在这个例子中，没有必要执行任何操作。\nwords 中有一个回文 \"a\" 。\n可以证明，在执行任何次数操作后，无法得到更多回文。\n因此，答案是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3036.匹配模式数组的子数组数目 II",
        "hardRate": "HARD",
        "passRate": "44.20%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-that-match-a-pattern-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-that-match-a-pattern-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，和一个下标从 <code>0</code>&nbsp;开始长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>pattern</code>&nbsp;，<code>pattern</code>&nbsp;数组只包含整数&nbsp;<code>-1</code>&nbsp;，<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>大小为 <code>m + 1</code>&nbsp;的<span data-keyword=\"subarray\">子数组</span>&nbsp;<code>nums[i..j]</code>&nbsp;如果对于每个元素 <code>pattern[k]</code>&nbsp;都满足以下条件，那么我们说这个子数组匹配模式数组&nbsp;<code>pattern</code>&nbsp;：</p>\n\n<ul>\n\t<li>如果 <code>pattern[k] == 1</code> ，那么 <code>nums[i + k + 1] &gt; nums[i + k]</code></li>\n\t<li>如果&nbsp;<code>pattern[k] == 0</code>&nbsp;，那么&nbsp;<code>nums[i + k + 1] == nums[i + k]</code></li>\n\t<li>如果&nbsp;<code>pattern[k] == -1</code>&nbsp;，那么&nbsp;<code>nums[i + k + 1] &lt; nums[i + k]</code></li>\n</ul>\n\n<p>请你返回匹配 <code>pattern</code>&nbsp;的 <code>nums</code>&nbsp;子数组的 <strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5,6], pattern = [1,1]\n<b>输出：</b>4\n<b>解释：</b>模式 [1,1] 说明我们要找的子数组是长度为 3 且严格上升的。在数组 nums 中，子数组 [1,2,3] ，[2,3,4] ，[3,4,5] 和 [4,5,6] 都匹配这个模式。\n所以 nums 中总共有 4 个子数组匹配这个模式。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\n<b>输出：</b>2\n<strong>解释：</strong>这里，模式数组 [1,0,-1] 说明我们需要找的子数组中，第一个元素小于第二个元素，第二个元素等于第三个元素，第三个元素大于第四个元素。在 nums 中，子数组 [1,4,4,1] 和 [3,5,5,3] 都匹配这个模式。\n所以 nums 中总共有 2 个子数组匹配这个模式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == nums.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m == pattern.length &lt; n</code></li>\n\t<li><code>-1 &lt;= pattern[i] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3037.在无限流中寻找模式 II",
        "hardRate": "HARD",
        "passRate": "55.11%",
        "problemsUrl": "https://leetcode.cn/problems/find-pattern-in-infinite-stream-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-pattern-in-infinite-stream-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3038.相同分数的最大操作数目 I",
        "hardRate": "EASY",
        "passRate": "66.59%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-i/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，如果&nbsp;<code>nums</code>&nbsp;<strong>至少</strong>&nbsp;包含&nbsp;<code>2</code>&nbsp;个元素，你可以执行以下操作：</p>\n\n<ul>\n\t<li>选择 <code>nums</code>&nbsp;中的前两个元素并将它们删除。</li>\n</ul>\n\n<p>一次操作的 <strong>分数</strong>&nbsp;是被删除元素的和。</p>\n\n<p>在确保<strong>&nbsp;所有操作分数相同</strong>&nbsp;的前提下，请你求出 <strong>最多</strong>&nbsp;能进行多少次操作。</p>\n\n<p>请你返回按照上述要求 <strong>最多</strong>&nbsp;可以进行的操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,1,4,5]\n<b>输出：</b>2\n<b>解释：</b>我们执行以下操作：\n- 删除前两个元素，分数为 3 + 2 = 5 ，nums = [1,4,5] 。\n- 删除前两个元素，分数为 1 + 4 = 5 ，nums = [5] 。\n由于只剩下 1 个元素，我们无法继续进行任何操作。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,6,1,4]\n<b>输出：1</b>\n<b>解释：</b>我们执行以下操作：\n- 删除前两个元素，分数为 3 + 2 = 5 ，nums = [6,1,4] 。\n由于下一次操作的分数与前一次不相等，我们无法继续进行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3039.进行操作使字符串为空",
        "hardRate": "MEDIUM",
        "passRate": "55.23%",
        "problemsUrl": "https://leetcode.cn/problems/apply-operations-to-make-string-empty/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-operations-to-make-string-empty/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;。</p>\n\n<p>请你进行以下操作直到 <code>s</code>&nbsp;为 <strong>空</strong>&nbsp;：</p>\n\n<ul>\n\t<li>每次操作 <strong>依次</strong> 遍历 <code>'a'</code> 到 <code>'z'</code>，如果当前字符出现在 <code>s</code> 中，那么删除出现位置&nbsp;<strong>最早</strong>&nbsp;的该字符（如果存在的话）。</li>\n</ul>\n\n<p>例如，最初 <code>s = \"aabcbbca\"</code>。我们执行下述操作：</p>\n\n<ul>\n\t<li>移除下划线的字符&nbsp; <code>s = \"<u><strong>a</strong></u>a<u><strong>bc</strong></u>bbca\"</code>。结果字符串为 <code>s = \"abbca\"</code>。</li>\n\t<li>移除下划线的字符&nbsp; <code>s = \"<u><strong>ab</strong></u>b<u><strong>c</strong></u>a\"</code>。结果字符串为 <code>s = \"ba\"</code>。</li>\n\t<li>移除下划线的字符&nbsp; <code>s = \"<u><strong>ba</strong></u>\"</code>。结果字符串为 <code>s = \"\"</code>。</li>\n</ul>\n\n<p>请你返回进行 <strong>最后</strong>&nbsp;一次操作 <strong>之前</strong>&nbsp;的字符串<em>&nbsp;</em><code>s</code><em>&nbsp;</em>。在上面的例子中，答案是&nbsp;<code>\"ba\"</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabcbbca\"\n<b>输出：</b>\"ba\"\n<b>解释：</b>已经在题目描述中解释。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcd\"\n<b>输出：</b>\"abcd\"\n<b>解释：</b>我们进行以下操作：\n- 删除 s = \"<em><strong>abcd</strong></em>\" 中加粗加斜字符，得到字符串 s = \"\" 。\n进行最后一次操作之前的字符串为 \"abcd\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3040.相同分数的最大操作数目 II",
        "hardRate": "MEDIUM",
        "passRate": "44.66%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，如果&nbsp;<code>nums</code>&nbsp;<strong>至少</strong>&nbsp;包含 <code>2</code>&nbsp;个元素，你可以执行以下操作中的&nbsp;<strong>任意</strong>&nbsp;一个：</p>\n\n<ul>\n\t<li>选择 <code>nums</code>&nbsp;中最前面两个元素并且删除它们。</li>\n\t<li>选择 <code>nums</code>&nbsp;中最后两个元素并且删除它们。</li>\n\t<li>选择 <code>nums</code>&nbsp;中第一个和最后一个元素并且删除它们。</li>\n</ul>\n\n<p>一次操作的&nbsp;<strong>分数</strong>&nbsp;是被删除元素的和。</p>\n\n<p>在确保<strong>&nbsp;所有操作分数相同</strong>&nbsp;的前提下，请你求出&nbsp;<strong>最多</strong>&nbsp;能进行多少次操作。</p>\n\n<p>请你返回按照上述要求&nbsp;<strong>最多</strong>&nbsp;可以进行的操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,1,2,3,4]\n<b>输出：</b>3\n<b>解释：</b>我们执行以下操作：\n- 删除前两个元素，分数为 3 + 2 = 5 ，nums = [1,2,3,4] 。\n- 删除第一个元素和最后一个元素，分数为 1 + 4 = 5 ，nums = [2,3] 。\n- 删除第一个元素和最后一个元素，分数为 2 + 3 = 5 ，nums = [] 。\n由于 nums 为空，我们无法继续进行任何操作。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,6,1,4]\n<b>输出：</b>2\n<b>解释：</b>我们执行以下操作：\n- 删除前两个元素，分数为 3 + 2 = 5 ，nums = [6,1,4] 。\n- 删除最后两个元素，分数为 1 + 4 = 5 ，nums = [6] 。\n至多进行 2 次操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3041.修改数组后最大化数组中的连续元素数目",
        "hardRate": "HARD",
        "passRate": "38.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-consecutive-elements-in-an-array-after-modification/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-consecutive-elements-in-an-array-after-modification/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始只包含 <strong>正</strong>&nbsp;整数的数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>一开始，你可以将数组中 <strong>任意数量</strong> 元素增加 <strong>至多</strong> <code>1</code> 。</p>\n\n<p>修改后，你可以从最终数组中选择 <strong>一个或者更多</strong>&nbsp;元素，并确保这些元素升序排序后是 <strong>连续</strong>&nbsp;的。比方说，<code>[3, 4, 5]</code> 是连续的，但是&nbsp;<code>[3, 4, 6]</code> 和&nbsp;<code>[1, 1, 2, 3]</code>&nbsp;不是连续的。<!-- notionvc: 312f8c5d-40d0-4cd1-96cc-9e96a846735b --></p>\n\n<p>请你返回 <strong>最多</strong>&nbsp;可以选出的元素数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,5,1,1]\n<b>输出：</b>3\n<b>解释：</b>我们将下标 0 和 3 处的元素增加 1 ，得到结果数组 nums = [3,1,5,2,1] 。\n我们选择元素 [<em><strong>3</strong></em>,<em><strong>1</strong></em>,5,<em><strong>2</strong></em>,1] 并将它们排序得到 [1,2,3] ，是连续元素。\n最多可以得到 3 个连续元素。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,7,10]\n<b>输出：</b>1\n<b>解释：</b>我们可以选择的最多元素数目是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3042.统计前后缀下标对 I",
        "hardRate": "EASY",
        "passRate": "69.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-prefix-and-suffix-pairs-i/",
        "solutionsUrl": "https://leetcode.cn/problems/count-prefix-and-suffix-pairs-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 。</p>\n\n<p>定义一个 <strong>布尔 </strong>函数 <code>isPrefixAndSuffix</code> ，它接受两个字符串参数 <code>str1</code> 和 <code>str2</code> ：</p>\n\n<ul>\n\t<li>当 <code>str1</code> 同时是 <code>str2</code> 的前缀（<span data-keyword=\"string-prefix\">prefix</span>）和后缀（<span data-keyword=\"string-suffix\">suffix</span>）时，<code>isPrefixAndSuffix(str1, str2)</code> 返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n\n<p>例如，<code>isPrefixAndSuffix(\"aba\", \"ababa\")</code> 返回 <code>true</code>，因为 <code>\"aba\"</code> 既是 <code>\"ababa\"</code> 的前缀，也是 <code>\"ababa\"</code> 的后缀，但是 <code>isPrefixAndSuffix(\"abc\", \"abcd\")</code> 返回<code> false</code>。</p>\n\n<p>以整数形式，返回满足 <code>i &lt; j</code> 且 <code>isPrefixAndSuffix(words[i], words[j])</code> 为 <code>true</code> 的下标对 <code>(i, j)</code> 的<strong> 数量 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>在本示例中，计数的下标对包括：\ni = 0 且 j = 1 ，因为 isPrefixAndSuffix(\"a\", \"aba\") 为 true 。\ni = 0 且 j = 2 ，因为 isPrefixAndSuffix(\"a\", \"ababa\") 为 true 。\ni = 0 且 j = 3 ，因为 isPrefixAndSuffix(\"a\", \"aa\") 为 true 。\ni = 1 且 j = 2 ，因为 isPrefixAndSuffix(\"aba\", \"ababa\") 为 true 。\n因此，答案是 4 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>在本示例中，计数的下标对包括：\ni = 0 且 j = 1 ，因为 isPrefixAndSuffix(\"pa\", \"papa\") 为 true 。\ni = 2 且 j = 3 ，因为 isPrefixAndSuffix(\"ma\", \"mama\") 为 true 。\n因此，答案是 2 。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abab\",\"ab\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>在本示例中，唯一有效的下标对是 i = 0 且 j = 1 ，但是 isPrefixAndSuffix(\"abab\", \"ab\") 为 false 。\n因此，答案是 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3043.最长公共前缀的长度",
        "hardRate": "MEDIUM",
        "passRate": "38.98%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-length-of-the-longest-common-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-length-of-the-longest-common-prefix/solution",
        "problemsDesc": "<p>给你两个 <strong>正整数 </strong>数组 <code>arr1</code> 和 <code>arr2</code> 。</p>\n\n<p>正整数的 <strong>前缀 </strong>是其 <strong>最左边 </strong>的一位或多位数字组成的整数。例如，<code>123</code> 是整数 <code>12345</code> 的前缀，而 <code>234</code><strong> 不是 </strong>。</p>\n\n<p>设若整数 <code>c</code> 是整数 <code>a</code> 和 <code>b</code> 的<strong> 公共前缀 </strong>，那么 <code>c</code> 需要同时是 <code>a</code> 和 <code>b</code> 的前缀。例如，<code>5655359</code> 和 <code>56554</code> 有公共前缀 <code>565</code>&nbsp;和 <code>5655</code>，而 <code>1223</code> 和 <code>43456</code><strong> 没有 </strong>公共前缀。</p>\n\n<p>你需要找出属于 <code>arr1</code> 的整数 <code>x</code> 和属于 <code>arr2</code> 的整数 <code>y</code> 组成的所有数对 <code>(x, y)</code> 之中最长的公共前缀的长度。</p>\n\n<p>返回所有数对之中最长公共前缀的长度。如果它们之间不存在公共前缀，则返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,10,100], arr2 = [1000]\n<strong>输出：</strong>3\n<strong>解释：</strong>存在 3 个数对 (arr1[i], arr2[j]) ：\n- (1, 1000) 的最长公共前缀是 1 。\n- (10, 1000) 的最长公共前缀是 10 。\n- (100, 1000) 的最长公共前缀是 100 。\n最长的公共前缀是 100 ，长度为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,2,3], arr2 = [4,4,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>任何数对 (arr1[i], arr2[j]) 之中都不存在公共前缀，因此返回 0 。\n请注意，同一个数组内元素之间的公共前缀不在考虑范围内。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr1[i], arr2[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3044.出现频率最高的质数",
        "hardRate": "MEDIUM",
        "passRate": "55.24%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-prime/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-prime/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 、下标从 <strong>0</strong> 开始的二维矩阵 <code>mat</code> 。在每个单元格，你可以按以下方式生成数字：</p>\n\n<ul>\n\t<li>最多有 <code>8</code> 条路径可以选择：东，东南，南，西南，西，西北，北，东北。</li>\n\t<li>选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。</li>\n\t<li>注意，每一步都会生成数字，例如，如果路径上的数字是 <code>1, 9, 1</code>，那么在这个方向上会生成三个数字：<code>1, 19, 191</code> 。</li>\n</ul>\n\n<p>返回在遍历矩阵所创建的所有数字中，出现频率最高的、<strong>大于</strong> <code>10</code>的<span data-keyword=\"prime-number\">质数</span>；如果不存在这样的质数，则返回 <code>-1</code><em> </em>。如果存在多个出现频率最高的质数，那么返回其中最大的那个。</p>\n\n<p><strong>注意：</strong>移动过程中不允许改变方向。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/02/15/south\" style=\"width: 641px; height: 291px;\" /> </strong>\n\n<pre>\n<strong>\n输入：</strong>mat = [[1,1],[9,9],[1,1]]\n<strong>输出：</strong>19\n<strong>解释：</strong> \n从单元格 (0,0) 出发，有 3 个可能的方向，这些方向上可以生成的大于 10 的数字有：\n东方向: [11], 东南方向: [19], 南方向: [19,191] 。\n从单元格 (0,1) 出发，所有可能方向上生成的大于 10 的数字有：[19,191,19,11] 。\n从单元格 (1,0) 出发，所有可能方向上生成的大于 10 的数字有：[99,91,91,91,91] 。\n从单元格 (1,1) 出发，所有可能方向上生成的大于 10 的数字有：[91,91,99,91,91] 。\n从单元格 (2,0) 出发，所有可能方向上生成的大于 10 的数字有：[11,19,191,19] 。\n从单元格 (2,1) 出发，所有可能方向上生成的大于 10 的数字有：[11,19,19,191] 。\n在所有生成的数字中，出现频率最高的质数是 19 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[7]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>唯一可以生成的数字是 7 。它是一个质数，但不大于 10 ，所以返回 -1 。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[9,7,8],[4,6,5],[2,8,6]]\n<strong>输出：</strong>97\n<strong>解释：</strong> \n从单元格 (0,0) 出发，所有可能方向上生成的大于 10 的数字有: [97,978,96,966,94,942] 。\n从单元格 (0,1) 出发，所有可能方向上生成的大于 10 的数字有: [78,75,76,768,74,79] 。\n从单元格 (0,2) 出发，所有可能方向上生成的大于 10 的数字有: [85,856,86,862,87,879] 。\n从单元格 (1,0) 出发，所有可能方向上生成的大于 10 的数字有: [46,465,48,42,49,47] 。\n从单元格 (1,1) 出发，所有可能方向上生成的大于 10 的数字有: [65,66,68,62,64,69,67,68] 。\n从单元格 (1,2) 出发，所有可能方向上生成的大于 10 的数字有: [56,58,56,564,57,58] 。\n从单元格 (2,0) 出发，所有可能方向上生成的大于 10 的数字有: [28,286,24,249,26,268] 。\n从单元格 (2,1) 出发，所有可能方向上生成的大于 10 的数字有: [86,82,84,86,867,85] 。\n从单元格 (2,2) 出发，所有可能方向上生成的大于 10 的数字有: [68,682,66,669,65,658] 。\n在所有生成的数字中，出现频率最高的质数是 97 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3045.统计前后缀下标对 II",
        "hardRate": "HARD",
        "passRate": "32.89%",
        "problemsUrl": "https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 。</p>\n\n<p>定义一个 <strong>布尔 </strong>函数 <code>isPrefixAndSuffix</code> ，它接受两个字符串参数 <code>str1</code> 和 <code>str2</code> ：</p>\n\n<ul>\n\t<li>当 <code>str1</code> 同时是 <code>str2</code> 的前缀（<span data-keyword=\"string-prefix\">prefix</span>）和后缀（<span data-keyword=\"string-suffix\">suffix</span>）时，<code>isPrefixAndSuffix(str1, str2)</code> 返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n\n<p>例如，<code>isPrefixAndSuffix(\"aba\", \"ababa\")</code> 返回 <code>true</code>，因为 <code>\"aba\"</code> 既是 <code>\"ababa\"</code> 的前缀，也是 <code>\"ababa\"</code> 的后缀，但是 <code>isPrefixAndSuffix(\"abc\", \"abcd\")</code> 返回<code> false</code>。</p>\n\n<p>以整数形式，返回满足 <code>i &lt; j</code> 且 <code>isPrefixAndSuffix(words[i], words[j])</code> 为 <code>true</code> 的下标对 <code>(i, j)</code> 的<strong> 数量 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"aba\",\"ababa\",\"aa\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>在本示例中，计数的下标对包括：\ni = 0 且 j = 1 ，因为 isPrefixAndSuffix(\"a\", \"aba\") 为 true 。\ni = 0 且 j = 2 ，因为 isPrefixAndSuffix(\"a\", \"ababa\") 为 true 。\ni = 0 且 j = 3 ，因为 isPrefixAndSuffix(\"a\", \"aa\") 为 true 。\ni = 1 且 j = 2 ，因为 isPrefixAndSuffix(\"aba\", \"ababa\") 为 true 。\n因此，答案是 4 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"pa\",\"papa\",\"ma\",\"mama\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>在本示例中，计数的下标对包括：\ni = 0 且 j = 1 ，因为 isPrefixAndSuffix(\"pa\", \"papa\") 为 true 。\ni = 2 且 j = 3 ，因为 isPrefixAndSuffix(\"ma\", \"mama\") 为 true 。\n因此，答案是 2 。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abab\",\"ab\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>在本示例中，唯一有效的下标对是 i = 0 且 j = 1 ，但是 isPrefixAndSuffix(\"abab\", \"ab\") 为 false 。\n因此，答案是 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成。</li>\n\t<li>所有 <code>words[i]</code> 的长度之和不超过 <code>5 * 10<sup>5</sup></code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3046.分割数组",
        "hardRate": "EASY",
        "passRate": "71.52%",
        "problemsUrl": "https://leetcode.cn/problems/split-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/split-the-array/solution",
        "problemsDesc": "<p>给你一个长度为 <strong>偶数 </strong>的整数数组 <code>nums</code> 。你需要将这个数组分割成 <code>nums1</code> 和 <code>nums2</code> 两部分，要求：</p>\n\n<ul>\n\t<li><code>nums1.length == nums2.length == nums.length / 2</code> 。</li>\n\t<li><code>nums1</code> 应包含 <strong>互不相同</strong><strong> </strong>的元素。</li>\n\t<li><code>nums2</code>也应包含<strong> 互不相同</strong> 的元素。</li>\n</ul>\n\n<p>如果能够分割数组就返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,2,3,4]\n<strong>输出：</strong>true\n<strong>解释：</strong>分割 nums 的可行方案之一是 nums1 = [1,2,3] 和 nums2 = [1,2,4] 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>分割 nums 的唯一可行方案是 nums1 = [1,1] 和 nums2 = [1,1] 。但 nums1 和 nums2 都不是由互不相同的元素构成。因此，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>nums.length % 2 == 0</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3047.求交集区域内的最大正方形面积",
        "hardRate": "MEDIUM",
        "passRate": "48.86%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-largest-area-of-square-inside-two-rectangles/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-largest-area-of-square-inside-two-rectangles/solution",
        "problemsDesc": "<p>在二维平面上存在 <code>n</code> 个矩形。给你两个下标从 <strong>0</strong> 开始的二维整数数组 <code>bottomLeft</code> 和 <code>topRight</code>，两个数组的大小都是 <code>n x 2</code> ，其中 <code>bottomLeft[i]</code> 和 <code>topRight[i]</code> 分别代表第 <code>i</code> 个矩形的<strong> 左下角 </strong>和 <strong>右上角 </strong>坐标。</p>\n\n<p>我们定义 <strong>向右 </strong>的方向为 x 轴正半轴（<strong>x 坐标增加</strong>），<strong>向左 </strong>的方向为 x 轴负半轴（<strong>x 坐标减少</strong>）。同样地，定义 <strong>向上 </strong>的方向为 y 轴正半轴（<strong>y 坐标增加</strong>）<strong>，向下 </strong>的方向为 y 轴负半轴（<strong>y 坐标减少</strong>）。</p>\n\n<p>你可以选择一个区域，该区域由两个矩形的 <strong>交集</strong>&nbsp;形成。你需要找出能够放入该区域 <strong>内 </strong>的<strong> 最大 </strong>正方形面积，并选择最优解。</p>\n\n<p>返回能够放入交集区域的正方形的 <strong>最大 </strong>可能面积，如果矩形之间不存在任何交集区域，则返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/05/example12.png\" style=\"width: 443px; height: 364px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem;\" />\n<pre>\n<strong>输入：</strong>bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n<strong>输出：</strong>1\n<strong>解释：</strong>边长为 1 的正方形可以放入矩形 0 和矩形 1 的交集区域，或矩形 1 和矩形 2 的交集区域。因此最大面积是边长 * 边长，即 1 * 1 = 1。\n可以证明，边长更大的正方形无法放入任何交集区域。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/04/rectanglesexample2.png\" style=\"padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 445px; height: 365px;\" />\n<pre>\n<strong>输入：</strong>bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n<strong>输出：</strong>1\n<strong>解释：</strong>边长为 1 的正方形可以放入矩形 0 和矩形 1，矩形 1 和矩形 2，或所有三个矩形的交集区域。因此最大面积是边长 * 边长，即 1 * 1 = 1。\n可以证明，边长更大的正方形无法放入任何交集区域。\n请注意，区域可以由多于两个矩形的交集构成。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/01/04/rectanglesexample3.png\" style=\"padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem; width: 444px; height: 364px;\" />\n<pre>\n<strong>输入：</strong>bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在相交的矩形，因此，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == bottomLeft.length == topRight.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>3</sup></code></li>\n\t<li><code>bottomLeft[i].length == topRight[i].length == 2</code></li>\n\t<li><code>1 &lt;= bottomLeft[i][0], bottomLeft[i][1] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>1 &lt;= topRight[i][0], topRight[i][1] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>bottomLeft[i][0] &lt; topRight[i][0]</code></li>\n\t<li><code>bottomLeft[i][1] &lt; topRight[i][1]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3048.标记所有下标的最早秒数 I",
        "hardRate": "MEDIUM",
        "passRate": "44.41%",
        "problemsUrl": "https://leetcode.cn/problems/earliest-second-to-mark-indices-i/",
        "solutionsUrl": "https://leetcode.cn/problems/earliest-second-to-mark-indices-i/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>1</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和&nbsp;<code>changeIndices</code>&nbsp;，数组的长度分别为&nbsp;<code>n</code> 和&nbsp;<code>m</code>&nbsp;。</p>\n\n<p>一开始，<code>nums</code>&nbsp;中所有下标都是未标记的，你的任务是标记 <code>nums</code>&nbsp;中 <strong>所有</strong>&nbsp;下标。</p>\n\n<p>从第 <code>1</code>&nbsp;秒到第 <code>m</code>&nbsp;秒（<b>包括&nbsp;</b>第&nbsp;<code>m</code>&nbsp;秒），对于每一秒 <code>s</code>&nbsp;，你可以执行以下操作 <strong>之一</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择范围&nbsp;<code>[1, n]</code>&nbsp;中的一个下标 <code>i</code>&nbsp;，并且将&nbsp;<code>nums[i]</code> <strong>减少</strong>&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>nums[changeIndices[s]]</code>&nbsp;<strong>等于</strong>&nbsp;<code>0</code>&nbsp;，<strong>标记</strong>&nbsp;下标&nbsp;<code>changeIndices[s]</code>&nbsp;。</li>\n\t<li>什么也不做。</li>\n</ul>\n\n<p>请你返回范围 <code>[1, m]</code>&nbsp;中的一个整数，表示最优操作下，标记&nbsp;<code>nums</code>&nbsp;中 <strong>所有</strong>&nbsp;下标的 <strong>最早秒数</strong>&nbsp;，如果无法标记所有下标，返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]\n<b>输出：</b>8\n<b>解释：</b>这个例子中，我们总共有 8 秒。按照以下操作标记所有下标：\n第 1 秒：选择下标 1 ，将 nums[1] 减少 1 。nums 变为 [1,2,0] 。\n第 2 秒：选择下标 1 ，将 nums[1] 减少 1 。nums 变为 [0,2,0] 。\n第 3 秒：选择下标 2 ，将 nums[2] 减少 1 。nums 变为 [0,1,0] 。\n第 4 秒：选择下标 2 ，将 nums[2] 减少 1 。nums 变为 [0,0,0] 。\n第 5 秒，标​​​​​记 changeIndices[5] ，也就是标记下标 3 ，因为 nums[3] 等于 0 。\n第 6 秒，标​​​​​记 changeIndices[6] ，也就是标记下标 2 ，因为 nums[2] 等于 0 。\n第 7 秒，什么也不做。\n第 8 秒，标记 changeIndices[8] ，也就是标记下标 1 ，因为 nums[1] 等于 0 。\n现在所有下标已被标记。\n最早可以在第 8 秒标记所有下标。\n所以答案是 8 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3], changeIndices = [1,1,1,2,1,1,1]\n<b>输出：</b>6\n<b>解释：</b>这个例子中，我们总共有 7 秒。按照以下操作标记所有下标：\n第 1 秒：选择下标 2 ，将 nums[2] 减少 1 。nums 变为 [1,2] 。\n第 2 秒：选择下标 2 ，将 nums[2] 减少 1 。nums 变为 [1,1] 。\n第 3 秒：选择下标 2 ，将 nums[2] 减少 1 。nums 变为 [1,0] 。\n第 4 秒：标​​​​​记 changeIndices[4] ，也就是标记下标 2 ，因为 nums[2] 等于 0 。\n第 5 秒：选择下标 1 ，将 nums[1] 减少 1 。nums 变为 [0,0] 。\n第 6 秒：标​​​​​记 changeIndices[6] ，也就是标记下标 1 ，因为 nums[1] 等于 0 。\n现在所有下标已被标记。\n最早可以在第 6 秒标记所有下标。\n所以答案是 6 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1], changeIndices = [2,2,2]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> 这个例子中，无法标记所有下标，因为下标 1 不在 changeIndices 中。\n所以答案是 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m == changeIndices.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= changeIndices[i] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3049.标记所有下标的最早秒数 II",
        "hardRate": "HARD",
        "passRate": "26.15%",
        "problemsUrl": "https://leetcode.cn/problems/earliest-second-to-mark-indices-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/earliest-second-to-mark-indices-ii/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>1</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和&nbsp;<code>changeIndices</code>&nbsp;，数组的长度分别为&nbsp;<code>n</code> 和&nbsp;<code>m</code>&nbsp;。</p>\n\n<p>一开始，<code>nums</code>&nbsp;中所有下标都是未标记的，你的任务是标记 <code>nums</code>&nbsp;中 <strong>所有</strong>&nbsp;下标。</p>\n\n<p>从第 <code>1</code>&nbsp;秒到第 <code>m</code>&nbsp;秒（<b>包括&nbsp;</b>第&nbsp;<code>m</code>&nbsp;秒），对于每一秒 <code>s</code>&nbsp;，你可以执行以下操作 <strong>之一</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择范围&nbsp;<code>[1, n]</code>&nbsp;中的一个下标 <code>i</code>&nbsp;，并且将&nbsp;<code>nums[i]</code> <strong>减少</strong>&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>将&nbsp;<code>nums[changeIndices[s]]</code>&nbsp;设置成任意的 <strong>非负</strong>&nbsp;整数。</li>\n\t<li>选择范围&nbsp;<code>[1, n]</code>&nbsp;中的一个下标&nbsp;<code>i</code>&nbsp;， 满足&nbsp;<code>nums[i]</code> <strong>等于</strong> <code>0</code>, 并 <strong>标记</strong>&nbsp;下标&nbsp;<code>i</code> 。</li>\n\t<li>什么也不做。</li>\n</ul>\n\n<p>请你返回范围 <code>[1, m]</code>&nbsp;中的一个整数，表示最优操作下，标记&nbsp;<code>nums</code>&nbsp;中 <strong>所有</strong>&nbsp;下标的 <strong>最早秒数</strong>&nbsp;，如果无法标记所有下标，返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3]\n<b>输出：</b>6\n<b>解释：</b>这个例子中，我们总共有 7 秒。按照以下操作标记所有下标：\n第 1 秒：将 nums[changeIndices[1]] 变为 0 。nums 变为 [0,2,3] 。\n第 2 秒：将 nums[changeIndices[2]] 变为 0 。nums 变为 [0,2,0] 。\n第 3 秒：将 nums[changeIndices[3]] 变为 0 。nums 变为 [0,0,0] 。\n第 4 秒：标记下标 1 ，因为 nums[1] 等于 0 。\n第 5 秒：标记下标 2 ，因为 nums[2] 等于 0 。\n第 6 秒：标记下标 3 ，因为 nums[3] 等于 0 。\n现在所有下标已被标记。\n最早可以在第 6 秒标记所有下标。\n所以答案是 6 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2]\n<b>输出：</b>7\n<b>解释：</b>这个例子中，我们总共有 8 秒。按照以下操作标记所有下标：\n第 1 秒：标记下标 1 ，因为 nums[1] 等于 0 。\n第 2 秒：标记下标 2 ，因为 nums[2] 等于 0 。\n第 3 秒：将 nums[4] 减少 1 。nums 变为 [0,0,1,1] 。\n第 4 秒：将 nums[4] 减少 1 。nums 变为 [0,0,1,0] 。\n第 5 秒：将 nums[3] 减少 1 。nums 变为 [0,0,0,0] 。\n第 6 秒：标记下标 3 ，因为 nums[3] 等于 0 。\n第 7 秒：标记下标 4 ，因为 nums[4] 等于 0 。\n现在所有下标已被标记。\n最早可以在第 7 秒标记所有下标。\n所以答案是 7 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3], changeIndices = [1,2,3]\n<b>输出：</b>-1\n<strong>解释：</strong>这个例子中，无法标记所有下标，因为我们没有足够的秒数。\n所以答案是 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m == changeIndices.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= changeIndices[i] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3050.披萨配料成本分析",
        "hardRate": "MEDIUM",
        "passRate": "64.90%",
        "problemsUrl": "https://leetcode.cn/problems/pizza-toppings-cost-analysis/",
        "solutionsUrl": "https://leetcode.cn/problems/pizza-toppings-cost-analysis/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]