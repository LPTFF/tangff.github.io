[
    {
        "problemsName": " 3751.设计机械累加器",
        "hardRate": "MEDIUM",
        "passRate": "85.59%",
        "problemsUrl": "https://leetcode.cn/problems/qiu-12n-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/qiu-12n-lcof/solution",
        "problemsDesc": "<p>请设计一个机械累加器，计算从 1、2... 一直累加到目标数值 <code>target</code> 的总和。注意这是一个只能进行加法操作的程序，不具备乘除、if-else、switch-case、for 循环、while 循环，及条件判断语句等高级功能。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 5\n<strong>输出:&nbsp;</strong>15\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 7\n<strong>输出:&nbsp;</strong>28\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target&nbsp;&lt;= 10000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3752.加密运算",
        "hardRate": "EASY",
        "passRate": "60.64%",
        "problemsUrl": "https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution",
        "problemsDesc": "<p>计算机安全专家正在开发一款高度安全的加密通信软件，需要在进行数据传输时对数据进行加密和解密操作。假定 <code>dataA</code> 和 <code>dataB</code> 分别为随机抽样的两次通信的数据量：</p>\n\n<ul>\n\t<li>正数为发送量</li>\n\t<li>负数为接受量</li>\n\t<li>0 为数据遗失</li>\n</ul>\n\n<p>请不使用四则运算符的情况下实现一个函数计算两次通信的数据量之和（三种情况均需被统计），以确保在数据传输过程中的高安全性和保密性。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dataA = 5, dataB = -1\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>dataA</code>&nbsp;和 <code>dataB</code>&nbsp;均可能是负数或 0</li>\n\t<li>结果不会溢出 32 位整数</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3753.按规则计算统计结果",
        "hardRate": "MEDIUM",
        "passRate": "56.89%",
        "problemsUrl": "https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/solution",
        "problemsDesc": "<p>为了深入了解这些生物群体的生态特征，你们进行了大量的实地观察和数据采集。数组 <code>arrayA</code> 记录了各个生物群体数量数据，其中 <code>arrayA[i]</code> 表示第 <code>i</code> 个生物群体的数量。请返回一个数组 <code>arrayB</code>，该数组为基于数组 <code>arrayA</code> 中的数据计算得出的结果，其中 <code>arrayB[i]</code> 表示将第 <code>i</code> 个生物群体的数量从总体中排除后的其他数量的乘积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arrayA = [2, 4, 6, 8, 10]\n<strong>输出：</strong>[1920, 960, 640, 480, 384]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>所有元素乘积之和不会溢出 32 位整数</li>\n\t<li><code>arrayA.length &lt;= 100000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3754.把字符串转换成整数 (atoi)",
        "hardRate": "MEDIUM",
        "passRate": "27.31%",
        "problemsUrl": "https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution",
        "problemsDesc": "<p>请你来实现一个&nbsp;<code>myAtoi(string s)</code>&nbsp;函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>\n\n<p>函数&nbsp;<code>myAtoi(string s)</code> 的算法如下：</p>\n\n<ol>\n\t<li>读入字符串并丢弃无用的前导空格</li>\n\t<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>\n\t<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>\n\t<li>将前面步骤读入的这些数字转换为整数（即，\"123\" -&gt; 123， \"0032\" -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>\n\t<li>如果整数数超过 32 位有符号整数范围 <code>[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2<sup>31</sup></code> 的整数应该被固定为 <code>−2<sup>31</sup></code> ，大于 <code>2<sup>31&nbsp;</sup>− 1</code> 的整数应该被固定为 <code>2<sup>31&nbsp;</sup>− 1</code> 。</li>\n\t<li>返回整数作为最终结果。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>\n\t<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"42\"\n<strong>输出：</strong>42\n<strong>解释：</strong>加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"<u>42</u>\"（读入 \"42\"）\n           ^\n解析得到整数 42 。\n由于 \"42\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 42 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"   -42\"\n<strong>输出：</strong>-42\n<strong>解释：</strong>\n第 1 步：\"<u><strong>   </strong></u>-42\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   <u><strong>-</strong></u>42\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   <u><strong>-42</strong></u>\"（读入 \"42\"）\n               ^\n解析得到整数 -42 。\n由于 \"-42\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 -42 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"4193 with words\"\n<strong>输出：</strong>4193\n<strong>解释：</strong>\n第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"<u>4193</u> with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 \"4193\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 4193 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 8 题相同：<a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/\">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3755.二叉搜索树的最近公共祖先",
        "hardRate": "EASY",
        "passRate": "69.05%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution",
        "problemsDesc": "<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n\n<p>例如，给定如下二叉搜索树:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>输出：</strong>6 \n<strong>解释：</strong>节点 <code>2 </code>和节点 <code>8 </code>的最近公共祖先是 <code>6。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>节点 <code>2</code> 和节点 <code>4</code> 的最近公共祖先是 <code>2</code>, 因为根据定义最近公共祖先节点可以为节点本身。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>所有节点的值都是唯一的。</li>\n\t<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>\n</ul>\n\n<p>注意：本题与主站 235 题相同：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3756.二叉树的最近公共祖先",
        "hardRate": "EASY",
        "passRate": "69.98%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution",
        "problemsDesc": "<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n\n<p>例如，给定如下二叉树:&nbsp; root =&nbsp;[3,5,1,6,2,0,8,null,null,7,4]</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3。</code>\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出：</strong>5\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5。</code>因为根据定义最近公共祖先节点可以为节点本身。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>所有节点的值都是唯一的。</li>\n\t<li>p、q 为不同节点且均存在于给定的二叉树中。</li>\n</ul>\n\n<p>注意：本题与主站 236 题相同：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3757.下载插件",
        "hardRate": "EASY",
        "passRate": "53.51%",
        "problemsUrl": "https://leetcode.cn/problems/Ju9Xwi/",
        "solutionsUrl": "https://leetcode.cn/problems/Ju9Xwi/solution",
        "problemsDesc": "小扣打算给自己的 **VS code** 安装使用插件，初始状态下带宽每分钟可以完成 `1` 个插件的下载。假定每分钟选择以下两种策略之一:\r\n- 使用当前带宽下载插件\r\n- 将带宽加倍（下载插件数量随之加倍）\r\n\r\n请返回小扣完成下载 `n` 个插件最少需要多少分钟。\r\n\r\n注意：实际的下载的插件数量可以超过 `n` 个\r\n\r\n\r\n**示例 1：**\r\n>输入：`n = 2`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：\r\n> 以下两个方案，都能实现 2 分钟内下载 2 个插件\r\n>- 方案一：第一分钟带宽加倍，带宽可每分钟下载 2 个插件；第二分钟下载 2 个插件\r\n>- 方案二：第一分钟下载 1 个插件，第二分钟下载 1 个插件\r\n\r\n**示例 2：**\r\n>输入：`n = 4`\r\n>\r\n>输出：`3`\r\n>\r\n>解释：\r\n> 最少需要 3 分钟可完成 4 个插件的下载，以下是其中一种方案:\r\n> 第一分钟带宽加倍，带宽可每分钟下载 2 个插件;\r\n> 第二分钟下载 2 个插件;\r\n> 第三分钟下载 2 个插件。\r\n\r\n\r\n\r\n**提示：**\r\n- `1 <= n <= 10^5`\r\n",
        "isPlus": false
    },
    {
        "problemsName": " 3758.完成一半题目",
        "hardRate": "EASY",
        "passRate": "64.87%",
        "problemsUrl": "https://leetcode.cn/problems/WqXACV/",
        "solutionsUrl": "https://leetcode.cn/problems/WqXACV/solution",
        "problemsDesc": "有 `N` 位扣友参加了微软与力扣举办了「以扣会友」线下活动。主办方提供了 `2*N` 道题目，整型数组 `questions` 中每个数字对应了每道题目所涉及的知识点类型。\r\n若每位扣友选择不同的一题，请返回被选的 `N` 道题目至少包含多少种知识点类型。\r\n\r\n\r\n**示例 1：**\r\n>输入：`questions = [2,1,6,2]`\r\n>\r\n>输出：`1`\r\n>\r\n>解释：有 2 位扣友在 4 道题目中选择 2 题。\r\n> 可选择完成知识点类型为 2 的题目时，此时仅一种知识点类型\r\n> 因此至少包含 1 种知识点类型。\r\n\r\n**示例 2：**\r\n>输入：`questions = [1,5,1,3,4,5,2,5,3,3,8,6]`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：有 6 位扣友在 12 道题目中选择题目，需要选择 6 题。\r\n> 选择完成知识点类型为 3、5 的题目，因此至少包含 2 种知识点类型。\r\n\r\n\r\n\r\n**提示：**\r\n- `questions.length == 2*n`\r\n- `2 <= questions.length <= 10^5`\r\n- `1 <= questions[i] <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 3759.主题空间",
        "hardRate": "MEDIUM",
        "passRate": "42.53%",
        "problemsUrl": "https://leetcode.cn/problems/YesdPw/",
        "solutionsUrl": "https://leetcode.cn/problems/YesdPw/solution",
        "problemsDesc": "「以扣会友」线下活动所在场地由若干主题空间与走廊组成，场地的地图记作由一维字符串型数组 `grid`，字符串中仅包含 `\"0\"～\"5\"` 这 6 个字符。地图上每一个字符代表面积为 1 的区域，其中 `\"0\"` 表示走廊，其他字符表示主题空间。相同且连续（连续指上、下、左、右四个方向连接）的字符组成同一个主题空间。\n\n假如整个 `grid` 区域的外侧均为走廊。请问，不与走廊直接相邻的主题空间的最大面积是多少？如果不存在这样的空间请返回 `0`。\n\n**示例 1：**\n>输入：`grid = [\"110\",\"231\",\"221\"]`\n>\n>输出：`1`\n>\n>解释：4 个主题空间中，只有 1 个不与走廊相邻，面积为 1。\n>![image.png](https://pic.leetcode-cn.com/1613708145-rscctN-image.png)\n\n\n**示例 2：**\n>输入：`grid = [\"11111100000\",\"21243101111\",\"21224101221\",\"11111101111\"]`\n>\n>输出：`3`\n>\n>解释：8 个主题空间中，有 5 个不与走廊相邻，面积分别为 3、1、1、1、2，最大面积为 3。\n>![image.png](https://pic.leetcode-cn.com/1613707985-KJyiXJ-image.png)\n\n\n**提示：**\n- `1 <= grid.length <= 500`\n- `1 <= grid[i].length <= 500`\n- `grid[i][j]` 仅可能为 `\"0\"～\"5\"`\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 3760.判定字符是否唯一",
        "hardRate": "EASY",
        "passRate": "71.38%",
        "problemsUrl": "https://leetcode.cn/problems/is-unique-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/is-unique-lcci/solution",
        "problemsDesc": "<p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s</code> = \"leetcode\"\n<strong>输出:</strong> false \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s</code> = \"abc\"\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(s) &lt;= 100 </code></li>\n\t<li><code>s[i]</code>仅包含小写字母</li>\n\t<li>如果你不使用额外的数据结构，会很加分。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3761.判定是否互为字符重排",
        "hardRate": "EASY",
        "passRate": "65.65%",
        "problemsUrl": "https://leetcode.cn/problems/check-permutation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-permutation-lcci/solution",
        "problemsDesc": "<p>给定两个由小写字母组成的字符串 <code>s1</code> 和 <code>s2</code>，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s1</code> = \"abc\", <code>s2</code> = \"bca\"\n<strong>输出:</strong> true \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s1</code> = \"abc\", <code>s2</code> = \"bad\"\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(s1) &lt;= 100 </code></li>\n\t<li><code>0 &lt;= len(s2) &lt;= 100 </code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3762.URL化",
        "hardRate": "EASY",
        "passRate": "57.78%",
        "problemsUrl": "https://leetcode.cn/problems/string-to-url-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/string-to-url-lcci/solution",
        "problemsDesc": "<p>URL化。编写一种方法，将字符串中的空格全部替换为<code>%20</code>。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用<code>Java</code>实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>：\"Mr John Smith    \", 13\n<strong>输出</strong>：\"Mr%20John%20Smith\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>：\"               \", 5\n<strong>输出</strong>：\"%20%20%20%20%20\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>字符串长度在 [0, 500000] 范围内。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3763.回文排列",
        "hardRate": "EASY",
        "passRate": "53.13%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-permutation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-permutation-lcci/solution",
        "problemsDesc": "<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>\n\n<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>\n\n<p>回文串不一定是字典当中的单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre><strong>输入：&quot;</strong>tactcoa&quot;\n<strong>输出：</strong>true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）\n</pre>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3764.一次编辑",
        "hardRate": "MEDIUM",
        "passRate": "34.66%",
        "problemsUrl": "https://leetcode.cn/problems/one-away-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/one-away-lcci/solution",
        "problemsDesc": "<p>字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nfirst = \"pale\"\nsecond = \"ple\"\n<strong>输出：</strong>True</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nfirst = \"pales\"\nsecond = \"pal\"\n<strong>输出：</strong>False\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3765.字符串压缩",
        "hardRate": "EASY",
        "passRate": "45.84%",
        "problemsUrl": "https://leetcode.cn/problems/compress-string-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/compress-string-lcci/solution",
        "problemsDesc": "<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>：\"aabcccccaaa\"\n<strong>输出</strong>：\"a2b1c5a3\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>：\"abbccd\"\n<strong>输出</strong>：\"abbccd\"\n<strong>解释</strong>：\"abbccd\"压缩后为\"a1b2c2d1\"，比原字符串长度更长。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>字符串长度在 <code>[0, 50000]</code> 范围内。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3766.旋转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "71.92%",
        "problemsUrl": "https://leetcode.cn/problems/rotate-matrix-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/rotate-matrix-lcci/solution",
        "problemsDesc": "<p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>\n\n<p>不占用额外内存空间能否做到？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n给定 <strong>matrix</strong> = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n<strong>原地</strong>旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n给定 <strong>matrix</strong> =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n<strong>原地</strong>旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n</pre>\n\n<p><strong>注意</strong>：本题与主站 48&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/rotate-image/\">https://leetcode-cn.com/problems/rotate-image/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3767.零矩阵",
        "hardRate": "MEDIUM",
        "passRate": "62.96%",
        "problemsUrl": "https://leetcode.cn/problems/zero-matrix-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/zero-matrix-lcci/solution",
        "problemsDesc": "<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n<strong>输出：</strong>\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>\n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n<strong>输出：</strong>\n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3768.字符串轮转",
        "hardRate": "EASY",
        "passRate": "53.55%",
        "problemsUrl": "https://leetcode.cn/problems/string-rotation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/string-rotation-lcci/solution",
        "problemsDesc": "<p>字符串轮转。给定两个字符串<code>s1</code>和<code>s2</code>，请编写代码检查<code>s2</code>是否为<code>s1</code>旋转而成（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串）。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：s1 = \"waterbottle\", s2 = \"erbottlewat\"\n<strong> 输出</strong>：True\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：s1 = \"aa\", s2 = \"aba\"\n<strong> 输出</strong>：False\n</pre>\n\n<ol>\n</ol>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>字符串长度在[0, 100000]范围内。</li>\n</ol>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>你能只调用一次检查子串的方法吗？</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3769.移除重复节点",
        "hardRate": "EASY",
        "passRate": "66.34%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicate-node-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicate-node-lcci/solution",
        "problemsDesc": "<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：[1, 2, 3, 3, 2, 1]\n<strong> 输出</strong>：[1, 2, 3]\n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：[1, 1, 1, 1, 2]\n<strong> 输出</strong>：[1, 2]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>链表长度在[0, 20000]范围内。</li>\n\t<li>链表元素在[0, 20000]范围内。</li>\n</ol>\n\n<p><strong>进阶：</strong></p>\n\n<p>如果不得使用临时缓冲区，该怎么解决？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3770.返回倒数第 k 个节点",
        "hardRate": "EASY",
        "passRate": "77.03%",
        "problemsUrl": "https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/solution",
        "problemsDesc": "<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5 和 <em>k</em> = 2\n<strong>输出： </strong>4</pre>\n\n<p><strong>说明：</strong></p>\n\n<p>给定的 <em>k</em>&nbsp;保证是有效的。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3771.删除中间节点",
        "hardRate": "EASY",
        "passRate": "85.97%",
        "problemsUrl": "https://leetcode.cn/problems/delete-middle-node-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-middle-node-lcci/solution",
        "problemsDesc": "<p>若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。</p>\n\n<p>假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。</p>\n\n<p>例如，传入节点 <code>c</code>（位于单向链表 <code>a->b->c->d->e->f</code> 中），将其删除后，剩余链表为 <code>a->b->d->e->f</code></p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>节点 5 （位于单向链表 4->5->1->9 中）\n<strong>输出：</strong>不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9\n</pre>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3772.分割链表",
        "hardRate": "MEDIUM",
        "passRate": "59.16%",
        "problemsUrl": "https://leetcode.cn/problems/partition-list-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-list-lcci/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 和一个特定值<em> </em><code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>\n\n<p>你不需要&nbsp;<strong>保留</strong>&nbsp;每个分区中各节点的初始相对位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,4,3,2,5,2], x = 3\n<strong>输出</strong>：[1,2,2,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1], x = 2\n<strong>输出</strong>：[1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3773.链表求和",
        "hardRate": "MEDIUM",
        "passRate": "46.92%",
        "problemsUrl": "https://leetcode.cn/problems/sum-lists-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-lists-lcci/solution",
        "problemsDesc": "<p>给定两个用链表表示的整数，每个节点包含一个数位。</p>\n\n<p>这些数位是反向存放的，也就是个位排在链表首部。</p>\n\n<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295\n<strong>输出：</strong>2 -&gt; 1 -&gt; 9，即912\n</pre>\n\n<p><strong>进阶：</strong>思考一下，假设这些数位是正向存放的，又该如何解决呢?</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295\n<strong>输出：</strong>9 -&gt; 1 -&gt; 2，即912\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3774.回文链表",
        "hardRate": "EASY",
        "passRate": "49.28%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-linked-list-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-linked-list-lcci/solution",
        "problemsDesc": "<p>编写一个函数，检查输入的链表是否是回文的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入： </strong>1-&gt;2\n<strong>输出：</strong> false \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入： </strong>1-&gt;2-&gt;2-&gt;1\n<strong>输出：</strong> true \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong><br>\n你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3775.链表相交",
        "hardRate": "EASY",
        "passRate": "67.18%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solution",
        "problemsDesc": "<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at '8'\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at '2'\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>0 <= m, n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= skipA <= m</code></li>\n\t<li><code>0 <= skipB <= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3776.环路检测",
        "hardRate": "MEDIUM",
        "passRate": "56.44%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-cycle-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-cycle-lcci/solution",
        "problemsDesc": "<p>给定一个链表，如果它是有环链表，实现一个算法返回环路的<code>开头节点</code>。若环不存在，请返回 <code>null</code>。</p>\n\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>tail connects to node index 1\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>tail connects to node index 0\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>no cycle\n<strong>解释：</strong>链表中没有环。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你是否可以不用额外空间解决此题？</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3777.三合一",
        "hardRate": "EASY",
        "passRate": "53.63%",
        "problemsUrl": "https://leetcode.cn/problems/three-in-one-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/three-in-one-lcci/solution",
        "problemsDesc": "<p>三合一。描述如何只用一个数组来实现三个栈。</p>\n\n<p>你应该实现<code>push(stackNum, value)</code>、<code>pop(stackNum)</code>、<code>isEmpty(stackNum)</code>、<code>peek(stackNum)</code>方法。<code>stackNum</code>表示栈下标，<code>value</code>表示压入的值。</p>\n\n<p>构造函数会传入一个<code>stackSize</code>参数，代表每个栈的大小。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"TripleInOne\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"isEmpty\"]\n[[1], [0, 1], [0, 2], [0], [0], [0], [0]]\n<strong> 输出</strong>：\n[null, null, null, 1, -1, -1, true]\n<strong>说明</strong>：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"TripleInOne\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"peek\"]\n[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]\n<strong> 输出</strong>：\n[null, null, null, null, 2, 1, -1, -1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= stackNum &lt;= 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3778.栈的最小值",
        "hardRate": "EASY",
        "passRate": "62.70%",
        "problemsUrl": "https://leetcode.cn/problems/min-stack-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/min-stack-lcci/solution",
        "problemsDesc": "<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p><br><p><strong>示例：</strong><pre>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   --> 返回 -3.<br>minStack.pop();<br>minStack.top();      --> 返回 0.<br>minStack.getMin();   --> 返回 -2.</pre></p>",
        "isPlus": false
    },
    {
        "problemsName": " 3779.堆盘子",
        "hardRate": "MEDIUM",
        "passRate": "38.65%",
        "problemsUrl": "https://leetcode.cn/problems/stack-of-plates-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/stack-of-plates-lcci/solution",
        "problemsDesc": "<p>堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行pop操作。</p>\n\n<p>当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，<code>pop</code>，<code>popAt</code>&nbsp;应返回 -1.</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"StackOfPlates\", \"push\", \"push\", \"popAt\", \"pop\", \"pop\"]\n[[1], [1], [2], [1], [], []]\n<strong> 输出</strong>：\n[null, null, null, 2, 1, -1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"StackOfPlates\", \"push\", \"push\", \"push\", \"popAt\", \"popAt\", \"popAt\"]\n[[2], [1], [2], [3], [0], [0], [0]]\n<strong> 输出</strong>：\n[null, null, null, null, 2, 1, 3]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3780.化栈为队",
        "hardRate": "EASY",
        "passRate": "71.92%",
        "problemsUrl": "https://leetcode.cn/problems/implement-queue-using-stacks-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-queue-using-stacks-lcci/solution",
        "problemsDesc": "<p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p><br><p><strong>示例：</strong><pre>MyQueue queue = new MyQueue();<br><br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false</pre></p><br><p><strong>说明：</strong><br><ul><li>你只能使用标准的栈操作 -- 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul></p>",
        "isPlus": false
    },
    {
        "problemsName": " 3781.栈排序",
        "hardRate": "MEDIUM",
        "passRate": "53.69%",
        "problemsUrl": "https://leetcode.cn/problems/sort-of-stacks-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-of-stacks-lcci/solution",
        "problemsDesc": "<p>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：<code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>isEmpty</code>。当栈为空时，<code>peek</code>&nbsp;返回 -1。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"SortedStack\", \"push\", \"push\", \"peek\", \"pop\", \"peek\"]\n[[], [1], [2], [], [], []]\n<strong> 输出</strong>：\n[null,null,null,1,null,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>： \n[\"SortedStack\", \"pop\", \"pop\", \"push\", \"pop\", \"isEmpty\"]\n[[], [], [], [1], [], []]\n<strong> 输出</strong>：\n[null,null,null,null,null,true]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>栈中的元素数目在[0, 5000]范围内。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3782.动物收容所",
        "hardRate": "EASY",
        "passRate": "58.27%",
        "problemsUrl": "https://leetcode.cn/problems/animal-shelter-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/animal-shelter-lcci/solution",
        "problemsDesc": "<p>动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如<code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和<code>dequeueCat</code>。允许使用Java内置的LinkedList数据结构。</p>\n\n<p><code>enqueue</code>方法有一个<code>animal</code>参数，<code>animal[0]</code>代表动物编号，<code>animal[1]</code>代表动物种类，其中 0 代表猫，1 代表狗。</p>\n\n<p><code>dequeue*</code>方法返回一个列表<code>[动物编号, 动物种类]</code>，若没有可以收养的动物，则返回<code>[-1,-1]</code>。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"AnimalShelf\", \"enqueue\", \"enqueue\", \"dequeueCat\", \"dequeueDog\", \"dequeueAny\"]\n[[], [[0, 0]], [[1, 0]], [], [], []]\n<strong> 输出</strong>：\n[null,null,null,[0,0],[-1,-1],[1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"AnimalShelf\", \"enqueue\", \"enqueue\", \"enqueue\", \"dequeueDog\", \"dequeueCat\", \"dequeueAny\"]\n[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]\n<strong> 输出</strong>：\n[null,null,null,null,[2,1],[0,0],[1,0]]\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>收纳所的最大容量为20000</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3783.节点间通路",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/route-between-nodes-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/route-between-nodes-lcci/solution",
        "problemsDesc": "<p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2\n<strong> 输出</strong>：true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4\n<strong> 输出</strong>：true\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>节点数量n在[0, 1e5]范围内。</li>\n\t<li>节点编号大于等于 0 小于 n。</li>\n\t<li>图中可能存在自环和平行边。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3784.最小高度树",
        "hardRate": "EASY",
        "passRate": "79.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-height-tree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-height-tree-lcci/solution",
        "problemsDesc": "<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>\n<strong>示例：</strong>\n\n<pre>\n给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n          0 \n         / \\ \n       -3   9 \n       /   / \n     -10  5 \n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3785.特定深度节点链表",
        "hardRate": "MEDIUM",
        "passRate": "80.93%",
        "problemsUrl": "https://leetcode.cn/problems/list-of-depth-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/list-of-depth-lcci/solution",
        "problemsDesc": "<p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[1,2,3,4,5,null,7,8]\n\n        1\n       /  \\ \n      2    3\n     / \\    \\ \n    4   5    7\n   /\n  8\n\n<strong>输出：</strong>[[1],[2,3],[4,5,7],[8]]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3786.检查平衡性",
        "hardRate": "EASY",
        "passRate": "60.10%",
        "problemsUrl": "https://leetcode.cn/problems/check-balance-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-balance-lcci/solution",
        "problemsDesc": "<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>\n<br />\n<strong>示例 1：</strong>\n\n<pre>\n给定二叉树 [3,9,20,null,null,15,7]\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回 true 。</pre>\n<strong>示例 2：</strong>\n\n<pre>\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n      1\n     / \\\n    2   2\n   / \\\n  3   3\n / \\\n4   4\n返回&nbsp;false 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3787.合法二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "36.10%",
        "problemsUrl": "https://leetcode.cn/problems/legal-binary-search-tree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/legal-binary-search-tree-lcci/solution",
        "problemsDesc": "<p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>\n<strong>示例 1：</strong>\n\n<pre>\n<strong>输入：</strong>\n    2\n   / \\\n  1   3\n<strong>输出：</strong>true\n</pre>\n<strong>示例 2：</strong>\n\n<pre>\n<strong>输入：</strong>\n    5\n   / \\\n  1   4\n&nbsp;    / \\\n&nbsp;   3   6\n<strong>输出：</strong>false\n<strong>解释：</strong>输入为: [5,1,4,null,null,3,6]。\n&nbsp;    根节点的值为 5 ，但是其右子节点值为 4 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3788.后继者",
        "hardRate": "MEDIUM",
        "passRate": "62.53%",
        "problemsUrl": "https://leetcode.cn/problems/successor-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/successor-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>\n\n<p>如果指定节点没有对应的“下一个”节点，则返回<code>null</code>。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = <code>[2,1,3], p = 1\n\n  2\n / \\\n1   3\n</code>\n<strong>输出：</strong>2</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = <code>[5,3,6,2,4,null,null,1], p = 6\n\n      5\n     / \\\n    3   6\n   / \\\n  2   4\n /   \n1\n</code>\n<strong>输出：</strong>null</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3789.首个共同祖先",
        "hardRate": "MEDIUM",
        "passRate": "71.78%",
        "problemsUrl": "https://leetcode.cn/problems/first-common-ancestor-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/first-common-ancestor-lcci/solution",
        "problemsDesc": "<p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>\n\n<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>\n\n<pre>\n    3\n   / \\\n  5   1\n / \\ / \\\n6  2 0  8\n  / \\\n 7   4\n</pre>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 5 和节点 1 的最近公共祖先是节点 3。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出：</strong>5\n<strong>解释：</strong>节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</pre>\n\n<p><strong>提示：</strong></p>\n\n<pre>\n所有节点的值都是唯一的。\np、q 为不同节点且均存在于给定的二叉树中。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3790.二叉搜索树序列",
        "hardRate": "HARD",
        "passRate": "49.40%",
        "problemsUrl": "https://leetcode.cn/problems/bst-sequences-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/bst-sequences-lcci/solution",
        "problemsDesc": "<p>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。</p>\n\n<p>给定一个由<strong>不同节点</strong>组成的二叉搜索树 <code>root</code>，输出所有可能生成此树的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>[[2,1,3],[2,3,1]]\n<strong>解释：</strong>数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树\n&nbsp;      2 \n&nbsp;     / \\ \n&nbsp;    1   3\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例&nbsp;</strong><strong>2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,1,null,null,3,2]\n<strong>输出：</strong>[[4,1,3,2]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉搜索树中的节点数在<meta charset=\"UTF-8\" />&nbsp;<code>[0, 1000]</code>&nbsp;的范围内</li>\n\t<li><code>1 &lt;= 节点值&nbsp;&lt;= 10<sup>6</sup></code></li>\n\t<li>\n\t<p>用例保证符合要求的数组数量不超过 <code>5000</code></p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3791.检查子树",
        "hardRate": "MEDIUM",
        "passRate": "64.38%",
        "problemsUrl": "https://leetcode.cn/problems/check-subtree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-subtree-lcci/solution",
        "problemsDesc": "<p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>\n\n<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>\n\n<p><strong>注意：</strong>此题相对书上原题略有改动。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：t1 = [1, 2, 3], t2 = [2]\n<strong> 输出</strong>：true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：t1 = [1, null, 2, 4], t2 = [3, 2]\n<strong> 输出</strong>：false\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>树的节点数目范围为 <code>[0, 20000]</code>。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3792.求和路径",
        "hardRate": "MEDIUM",
        "passRate": "49.24%",
        "problemsUrl": "https://leetcode.cn/problems/paths-with-sum-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-with-sum-lcci/solution",
        "problemsDesc": "<p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>\n\n<p><strong>示例：</strong><br />\n给定如下二叉树，以及目标和&nbsp;<code>sum = 22</code>，</p>\n\n<pre>\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n</pre>\n\n<p>输出：</p>\n\n<pre>\n3\n<strong>解释：</strong>和为 22&nbsp;的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>节点总数 &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3793.插入",
        "hardRate": "EASY",
        "passRate": "51.91%",
        "problemsUrl": "https://leetcode.cn/problems/insert-into-bits-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-into-bits-lcci/solution",
        "problemsDesc": "<p>给定两个整型数字 <code>N</code> 与 <code>M</code>，以及表示比特位置的 <code>i</code> 与 <code>j</code>（<code>i &lt;= j</code>，且从 0 位开始计算）。</p>\n\n<p>编写一种方法，使 <code>M</code> 对应的二进制数字插入 <code>N</code> 对应的二进制数字的第 <code>i ~ j</code> 位区域，不足之处用 <code>0</code> 补齐。具体插入过程如图所示。</p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1610104070-NuLVQi-05.01.gif\" style=\"width: 267px; height: 200px;\" /></p>\n\n<p>题目保证从 <code>i</code> 位到 <code>j</code> 位足以容纳 <code>M</code>， 例如： <code>M = 10011</code>，则 <code>i～j</code> 区域至少可容纳 5 位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：N = 1024(10000000000), M = 19(10011), i = 2, j = 6\n<strong> 输出</strong>：N = 1100(10001001100)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：N = 0, M = 31(11111), i = 0, j = 4\n<strong> 输出</strong>：N = 31(11111)\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3794.二进制数转字符串",
        "hardRate": "MEDIUM",
        "passRate": "76.68%",
        "problemsUrl": "https://leetcode.cn/problems/binary-number-to-string-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-number-to-string-lcci/solution",
        "problemsDesc": "<p>二进制数转字符串。给定一个介于 0 和 1 之间的实数（如 0.72），类型为 double，打印它的二进制表达式。如果该数字无法精确地用 32 位以内的二进制表示，则打印“ERROR”。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>：0.625\n<strong>输出</strong>：\"0.101\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>：0.1\n<strong>输出</strong>：\"ERROR\"\n<strong>提示</strong>：0.1 无法被二进制准确表示\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>32位包括输出中的 <code>\"0.\"</code> 这两位。</li>\n\t<li>题目保证输入用例的小数位数最多只有 <code>6</code> 位</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3795.翻转数位",
        "hardRate": "EASY",
        "passRate": "37.88%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-bits-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-bits-lcci/solution",
        "problemsDesc": "<p>给定一个32位整数 <code>num</code>，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> <code>num</code> = 1775(11011101111<sub>2</sub>)\n<strong>输出:</strong> 8\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> <code>num</code> = 7(0111<sub>2</sub>)\n<strong>输出:</strong> 4\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3796.下一个数",
        "hardRate": "MEDIUM",
        "passRate": "35.31%",
        "problemsUrl": "https://leetcode.cn/problems/closed-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/closed-number-lcci/solution",
        "problemsDesc": "<p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 2（或者0b10）\n<strong> 输出</strong>：[4, 1] 或者（[0b100, 0b1]）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 1\n<strong> 输出</strong>：[2, -1]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>num</code>&nbsp;的范围在[1, 2147483647]之间；</li>\n\t<li>如果找不到前一个或者后一个满足条件的正数，那么输出 -1。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3797.整数转换",
        "hardRate": "EASY",
        "passRate": "51.22%",
        "problemsUrl": "https://leetcode.cn/problems/convert-integer-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-integer-lcci/solution",
        "problemsDesc": "<p>整数转换。编写一个函数，确定需要改变几个位才能将整数 A 转成整数 B。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 29 （或者 0b11101）, B = 15（或者 0b01111）\n<strong> 输出</strong>：2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 1，B = 2\n<strong> 输出</strong>：2\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>A，B范围在[-2147483648, 2147483647]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3798.配对交换",
        "hardRate": "EASY",
        "passRate": "70.82%",
        "problemsUrl": "https://leetcode.cn/problems/exchange-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/exchange-lcci/solution",
        "problemsDesc": "<p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位 0 与位 1 交换，位 2 与位 3 交换，以此类推）。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 2（或者 0b10）\n<strong> 输出：</strong>1 (或者 0b01)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 3\n<strong> 输出</strong>：3\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li><code>num</code>&nbsp;的范围在[0, 2<sup>30</sup> - 1]之间，不会发生整数溢出。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3799.绘制直线",
        "hardRate": "MEDIUM",
        "passRate": "53.18%",
        "problemsUrl": "https://leetcode.cn/problems/draw-line-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/draw-line-lcci/solution",
        "problemsDesc": "<p>已知一个由像素点组成的单色屏幕，每行均有 <code>w</code> 个像素点，所有像素点初始为 <code>0</code>，左上角位置为 <code>(0,0)</code>。</p>\n\n<p>现将每行的像素点按照「每 <code>32</code> 个像素点」为一组存放在一个 <code>int</code> 中，再依次存入长度为 <code>length</code> 的一维数组中。</p>\n\n<p>我们将在屏幕上绘制一条从点 <code>(x1,y)</code> 到点 <code>(x2,y)</code> 的直线（即像素点修改为 <code>1</code>），请返回绘制过后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>用例保证屏幕宽度 <code>w</code> 可被 32 整除（即一个 <code>int</code> 不会分布在两行上）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：length = 1, w = 32, x1 = 30, x2 = 31, y = 0\n<strong> 输出</strong>：[3]\n<strong> 解释</strong>：在第 0 行的第 30 位到第 31 位画一条直线，屏幕二进制形式表示为 [00000000000000000000000000000011]，因此返回 [3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：length = 3, w = 96, x1 = 0, x2 = 95, y = 0\n<strong> 输出</strong>：[-1, -1, -1]\n<strong> 解释</strong>：由于二进制 <strong>11111111111111111111111111111111</strong> 的 int 类型代表 -1，因此返回 [-1,-1,-1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= w &lt;= 3 * 10^5</code></li>\n\t<li><code>0 &lt;= x1 &lt;= x2 &lt; w</code></li>\n\t<li><code>0 &lt;= y &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3800.三步问题",
        "hardRate": "EASY",
        "passRate": "36.38%",
        "problemsUrl": "https://leetcode.cn/problems/three-steps-problem-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/three-steps-problem-lcci/solution",
        "problemsDesc": "<p>三步问题。有个小孩正在上楼梯，楼梯有 n 阶台阶，小孩一次可以上 1 阶、2 阶或 3 阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模 1000000007。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 3 \n<strong> 输出</strong>：4\n<strong> 说明：</strong>有四种走法\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 5\n<strong> 输出</strong>：13\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>n 范围在[1, 1000000]之间</li>\n</ol>\n",
        "isPlus": false
    }
]