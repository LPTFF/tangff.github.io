[
    {
        "problemsName": " 3251.单调数组对的数目 II",
        "hardRate": "HARD",
        "passRate": "61.14%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-ii/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的&nbsp;<strong>正</strong>&nbsp;整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>如果两个&nbsp;<strong>非负</strong>&nbsp;整数数组&nbsp;<code>(arr1, arr2)</code>&nbsp;满足以下条件，我们称它们是&nbsp;<strong>单调</strong>&nbsp;数组对：</p>\n\n<ul>\n\t<li>两个数组的长度都是&nbsp;<code>n</code>&nbsp;。</li>\n\t<li><code>arr1</code>&nbsp;是单调<strong>&nbsp;非递减</strong>&nbsp;的，换句话说&nbsp;<code>arr1[0] &lt;= arr1[1] &lt;= ... &lt;= arr1[n - 1]</code>&nbsp;。</li>\n\t<li><code>arr2</code>&nbsp;是单调 <strong>非递增</strong>&nbsp;的，换句话说&nbsp;<code>arr2[0] &gt;= arr2[1] &gt;= ... &gt;= arr2[n - 1]</code>&nbsp;。</li>\n\t<li>对于所有的&nbsp;<code>0 &lt;= i &lt;= n - 1</code>&nbsp;都有&nbsp;<code>arr1[i] + arr2[i] == nums[i]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回所有 <strong>单调</strong>&nbsp;数组对的数目。</p>\n\n<p>由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,3,2]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>单调数组对包括：</p>\n\n<ol>\n\t<li><code>([0, 1, 1], [2, 2, 1])</code></li>\n\t<li><code>([0, 1, 2], [2, 2, 0])</code></li>\n\t<li><code>([0, 2, 2], [2, 1, 0])</code></li>\n\t<li><code>([1, 2, 2], [1, 1, 0])</code></li>\n</ol>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [5,5,5,5]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>126</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3252.英超积分榜排名 II",
        "hardRate": "MEDIUM",
        "passRate": "54.07%",
        "problemsUrl": "https://leetcode.cn/problems/premier-league-table-ranking-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/premier-league-table-ranking-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3253.最小代价构造字符串（简单）",
        "hardRate": "MEDIUM",
        "passRate": "60.00%",
        "problemsUrl": "https://leetcode.cn/problems/construct-string-with-minimum-cost-easy/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-string-with-minimum-cost-easy/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3254.长度为 K 的子数组的能量值 I",
        "hardRate": "MEDIUM",
        "passRate": "55.12%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-i/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-i/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>一个数组的 <strong>能量值</strong> 定义为：</p>\n\n<ul>\n\t<li>如果 <strong>所有</strong>&nbsp;元素都是依次&nbsp;<strong>连续</strong> 且 <strong>上升</strong> 的，那么能量值为 <strong>最大</strong>&nbsp;的元素。</li>\n\t<li>否则为 -1 。</li>\n</ul>\n\n<p>你需要求出 <code>nums</code>&nbsp;中所有长度为 <code>k</code>&nbsp;的&nbsp;<span data-keyword=\"subarray-nonempty\">子数组</span>&nbsp;的能量值。</p>\n\n<p>请你返回一个长度为 <code>n - k + 1</code>&nbsp;的整数数组&nbsp;<code>results</code>&nbsp;，其中&nbsp;<code>results[i]</code>&nbsp;是子数组&nbsp;<code>nums[i..(i + k - 1)]</code>&nbsp;的能量值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2,3,4,3,2,5], k = 3</span></p>\n\n<p><b>输出：</b>[3,4,-1,-1,-1]</p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>nums</code>&nbsp;中总共有 5 个长度为 3 的子数组：</p>\n\n<ul>\n\t<li><code>[1, 2, 3]</code>&nbsp;中最大元素为 3 。</li>\n\t<li><code>[2, 3, 4]</code>&nbsp;中最大元素为 4 。</li>\n\t<li><code>[3, 4, 3]</code>&nbsp;中元素 <strong>不是</strong>&nbsp;连续的。</li>\n\t<li><code>[4, 3, 2]</code>&nbsp;中元素 <b>不是</b>&nbsp;上升的。</li>\n\t<li><code>[3, 2, 5]</code>&nbsp;中元素 <strong>不是</strong>&nbsp;连续的。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,2,2,2,2], k = 4</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[-1,-1]</span></p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [3,2,3,2,3,2], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[-1,3,-1,3,-1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3255.长度为 K 的子数组的能量值 II",
        "hardRate": "MEDIUM",
        "passRate": "56.75%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-ii/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>一个数组的 <strong>能量值</strong> 定义为：</p>\n\n<ul>\n\t<li>如果 <strong>所有</strong>&nbsp;元素都是依次&nbsp;<strong>连续</strong>（即 <code>nums[i] + 1 = nums[i + 1]</code>，<code>i &lt; n</code>）且 <strong>上升</strong> 的，那么能量值为 <strong>最大</strong>&nbsp;的元素。</li>\n\t<li>否则为 -1 。</li>\n</ul>\n\n<p>你需要求出 <code>nums</code>&nbsp;中所有长度为 <code>k</code>&nbsp;的&nbsp;<span data-keyword=\"subarray-nonempty\">子数组</span>&nbsp;的能量值。</p>\n\n<p>请你返回一个长度为 <code>n - k + 1</code>&nbsp;的整数数组&nbsp;<code>results</code>&nbsp;，其中&nbsp;<code>results[i]</code>&nbsp;是子数组&nbsp;<code>nums[i..(i + k - 1)]</code>&nbsp;的能量值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2,3,4,3,2,5], k = 3</span></p>\n\n<p><b>输出：</b>[3,4,-1,-1,-1]</p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>nums</code>&nbsp;中总共有 5 个长度为 3 的子数组：</p>\n\n<ul>\n\t<li><code>[1, 2, 3]</code>&nbsp;中最大元素为 3 。</li>\n\t<li><code>[2, 3, 4]</code>&nbsp;中最大元素为 4 。</li>\n\t<li><code>[3, 4, 3]</code>&nbsp;中元素 <strong>不是</strong>&nbsp;连续的。</li>\n\t<li><code>[4, 3, 2]</code>&nbsp;中元素 <b>不是</b>&nbsp;上升的。</li>\n\t<li><code>[3, 2, 5]</code>&nbsp;中元素 <strong>不是</strong>&nbsp;连续的。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,2,2,2,2], k = 4</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[-1,-1]</span></p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [3,2,3,2,3,2], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[-1,3,-1,3,-1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3256.放三个车的价值之和最大 I",
        "hardRate": "HARD",
        "passRate": "25.72%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-i/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>board</code>&nbsp;，它表示一个国际象棋棋盘，其中&nbsp;<code>board[i][j]</code>&nbsp;表示格子 <code>(i, j)</code>&nbsp;的 <strong>价值</strong>&nbsp;。</p>\n\n<p>处于 <strong>同一行</strong>&nbsp;或者 <strong>同一列</strong>&nbsp;车会互相 <strong>攻击</strong>&nbsp;。你需要在棋盘上放三个车，确保它们两两之间都&nbsp;<b>无法互相攻击</b>&nbsp;。</p>\n\n<p>请你返回满足上述条件下，三个车所在格子 <strong>值</strong>&nbsp;之和 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>board = </span>[[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]</p>\n\n<p><b>输出：</b>4</p>\n\n<p><strong>解释：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/08/rooks2.png\" style=\"width: 294px; height: 450px;\" /></p>\n\n<p>我们可以将车分别放在格子&nbsp;<code>(0, 2)</code>&nbsp;，<code>(1, 3)</code>&nbsp;和&nbsp;<code>(2, 1)</code>&nbsp;处，价值之和为&nbsp;<code>1 + 1 + 2 = 4</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>board = [[1,2,3],[4,5,6],[7,8,9]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>15</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们可以将车分别放在格子&nbsp;<code>(0, 0)</code>&nbsp;，<code>(1, 1)</code>&nbsp;和&nbsp;<code>(2, 2)</code>&nbsp;处，价值之和为&nbsp;<code>1 + 5 + 9 = 15</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>board = [[1,1,1],[1,1,1],[1,1,1]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们可以将车分别放在格子&nbsp;<code>(0, 2)</code>&nbsp;，<code>(1, 1)</code>&nbsp;和&nbsp;<code>(2, 0)</code>&nbsp;处，价值之和为&nbsp;<code>1 + 1 + 1 = 3</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= m == board.length &lt;= 100</code></li>\n\t<li><code>3 &lt;= n == board[i].length &lt;= 100</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= board[i][j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3257.放三个车的价值之和最大 II",
        "hardRate": "HARD",
        "passRate": "33.37%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>board</code>&nbsp;，它表示一个国际象棋棋盘，其中&nbsp;<code>board[i][j]</code>&nbsp;表示格子 <code>(i, j)</code>&nbsp;的 <strong>价值</strong>&nbsp;。</p>\n\n<p>处于 <strong>同一行</strong>&nbsp;或者 <strong>同一列</strong>&nbsp;车会互相 <strong>攻击</strong>&nbsp;。你需要在棋盘上放三个车，确保它们两两之间都&nbsp;<b>无法互相攻击</b>&nbsp;。</p>\n\n<p>请你返回满足上述条件下，三个车所在格子 <strong>值</strong>&nbsp;之和 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>board = </span>[[-3,1,1,1],[-3,1,-3,1],[-3,2,1,1]]</p>\n\n<p><b>输出：</b>4</p>\n\n<p><strong>解释：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/08/rooks2.png\" style=\"width: 294px; height: 450px;\" /></p>\n\n<p>我们可以将车分别放在格子&nbsp;<code>(0, 2)</code>&nbsp;，<code>(1, 3)</code>&nbsp;和&nbsp;<code>(2, 1)</code>&nbsp;处，价值之和为&nbsp;<code>1 + 1 + 2 = 4</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>board = [[1,2,3],[4,5,6],[7,8,9]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>15</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们可以将车分别放在格子&nbsp;<code>(0, 0)</code>&nbsp;，<code>(1, 1)</code>&nbsp;和&nbsp;<code>(2, 2)</code>&nbsp;处，价值之和为&nbsp;<code>1 + 5 + 9 = 15</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>board = [[1,1,1],[1,1,1],[1,1,1]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们可以将车分别放在格子&nbsp;<code>(0, 2)</code>&nbsp;，<code>(1, 1)</code>&nbsp;和&nbsp;<code>(2, 0)</code>&nbsp;处，价值之和为&nbsp;<code>1 + 1 + 1 = 3</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= m == board.length &lt;= 500</code></li>\n\t<li><code>3 &lt;= n == board[i].length &lt;= 500</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= board[i][j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3258.统计满足 K 约束的子字符串数量 I",
        "hardRate": "EASY",
        "passRate": "83.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/solution",
        "problemsDesc": "<p>给你一个 <strong>二进制</strong> 字符串 <code>s</code> 和一个整数 <code>k</code>。</p>\n\n<p>如果一个 <strong>二进制字符串</strong> 满足以下任一条件，则认为该字符串满足 <strong>k 约束</strong>：</p>\n\n<ul>\n\t<li>字符串中 <code>0</code> 的数量最多为 <code>k</code>。</li>\n\t<li>字符串中 <code>1</code> 的数量最多为 <code>k</code>。</li>\n</ul>\n\n<p>返回一个整数，表示 <code>s</code> 的所有满足 <strong>k 约束 </strong>的<span data-keyword=\"substring-nonempty\">子字符串</span>的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"10101\", k = 1</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">12</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>s</code> 的所有子字符串中，除了 <code>\"1010\"</code>、<code>\"10101\"</code> 和 <code>\"0101\"</code> 外，其余子字符串都满足 k 约束。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"1010101\", k = 2</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">25</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>s</code> 的所有子字符串中，除了长度大于 5 的子字符串外，其余子字符串都满足 k 约束。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"11111\", k = 1</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">15</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>s</code> 的所有子字符串都满足 k 约束。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n\t<li><code>s[i]</code> 是 <code>'0'</code> 或 <code>'1'</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3259.超级饮料的最大强化能量",
        "hardRate": "MEDIUM",
        "passRate": "63.73%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-energy-boost-from-two-drinks/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-energy-boost-from-two-drinks/solution",
        "problemsDesc": "<p>来自未来的体育科学家给你两个整数数组 <code>energyDrinkA</code> 和 <code>energyDrinkB</code>，数组长度都等于 <code>n</code>。这两个数组分别代表 A、B 两种不同能量饮料每小时所能提供的强化能量。</p>\n\n<p>你需要每小时饮用一种能量饮料来 <strong>最大化 </strong>你的总强化能量。然而，如果从一种能量饮料切换到另一种，你需要等待一小时来梳理身体的能量体系（在那个小时里你将不会获得任何强化能量）。</p>\n\n<p>返回在接下来的 <code>n</code> 小时内你能获得的<strong> 最大 </strong>总强化能量。</p>\n\n<p><strong>注意 </strong>你可以选择从饮用任意一种能量饮料开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong>energyDrinkA<span class=\"example-io\"> = [1,3,1], </span>energyDrinkB<span class=\"example-io\"> = [3,1,1]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">5</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>要想获得 5 点强化能量，需要选择只饮用能量饮料 A（或者只饮用 B）。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong>energyDrinkA<span class=\"example-io\"> = [4,1,1], </span>energyDrinkB<span class=\"example-io\"> = [1,1,3]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">7</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>第一个小时饮用能量饮料 A。</li>\n\t<li>切换到能量饮料 B ，在第二个小时无法获得强化能量。</li>\n\t<li>第三个小时饮用能量饮料 B ，并获得强化能量。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == energyDrinkA.length == energyDrinkB.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= energyDrinkA[i], energyDrinkB[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3260.找出最大的 N 位 K 回文数",
        "hardRate": "HARD",
        "passRate": "28.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-largest-palindrome-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-largest-palindrome-divisible-by-k/solution",
        "problemsDesc": "<p>给你两个 <strong>正整数</strong> <code>n</code> 和 <code>k</code>。</p>\n\n<p>如果整数 <code>x</code> 满足以下全部条件，则该整数是一个 <strong>k 回文数</strong>：</p>\n\n<ul>\n\t<li><code>x</code> 是一个 <span data-keyword=\"palindrome-integer\">回文数</span>。</li>\n\t<li><code>x</code> 可以被 <code>k</code> 整除。</li>\n</ul>\n\n<p>以字符串形式返回 <strong>最大的&nbsp;</strong> <code>n</code> 位 <strong>k 回文数</strong>。</p>\n\n<p><strong>注意</strong>，该整数 <strong>不 </strong>含前导零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">n = 3, k = 5</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">\"595\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>595 是最大的 3 位 k 回文数。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">n = 1, k = 4</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">\"8\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>1 位 k 回文数只有 4 和 8。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">n = 5, k = 6</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">\"89898\"</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3261.统计满足 K 约束的子字符串数量 II",
        "hardRate": "HARD",
        "passRate": "52.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-ii/solution",
        "problemsDesc": "<p>给你一个 <strong>二进制</strong> 字符串 <code>s</code> 和一个整数 <code>k</code>。</p>\n\n<p>另给你一个二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 。</p>\n\n<p>如果一个 <strong>二进制字符串</strong> 满足以下任一条件，则认为该字符串满足 <strong>k 约束</strong>：</p>\n\n<ul>\n\t<li>字符串中 <code>0</code> 的数量最多为 <code>k</code>。</li>\n\t<li>字符串中 <code>1</code> 的数量最多为 <code>k</code>。</li>\n</ul>\n\n<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 表示 <code>s[l<sub>i</sub>..r<sub>i</sub>]</code> 中满足 <strong>k 约束</strong> 的 <span data-keyword=\"substring-nonempty\">子字符串</span> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"0001111\", k = 2, queries = [[0,6]]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">[26]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>对于查询 <code>[0, 6]</code>， <code>s[0..6] = \"0001111\"</code> 的所有子字符串中，除 <code>s[0..5] = \"000111\"</code> 和 <code>s[0..6] = \"0001111\"</code> 外，其余子字符串都满足 k 约束。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">s = \"010101\", k = 1, queries = [[0,5],[1,4],[2,3]]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">[15,9,3]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>s</code> 的所有子字符串中，长度大于 3 的子字符串都不满足 k 约束。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 是 <code>'0'</code> 或 <code>'1'</code></li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i] == [l<sub>i</sub>, r<sub>i</sub>]</code></li>\n\t<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt; s.length</code></li>\n\t<li>所有查询互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3262.查找重叠的班次",
        "hardRate": "MEDIUM",
        "passRate": "56.40%",
        "problemsUrl": "https://leetcode.cn/problems/find-overlapping-shifts/",
        "solutionsUrl": "https://leetcode.cn/problems/find-overlapping-shifts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3263.将双链表转换为数组 I",
        "hardRate": "EASY",
        "passRate": "92.46%",
        "problemsUrl": "https://leetcode.cn/problems/convert-doubly-linked-list-to-array-i/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-doubly-linked-list-to-array-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3264.K 次乘运算后的最终数组 I",
        "hardRate": "EASY",
        "passRate": "82.86%",
        "problemsUrl": "https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-i/",
        "solutionsUrl": "https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-i/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，一个整数&nbsp;<code>k</code>&nbsp;&nbsp;和一个整数&nbsp;<code>multiplier</code>&nbsp;。</p>\n\n<p>你需要对 <code>nums</code>&nbsp;执行 <code>k</code>&nbsp;次操作，每次操作中：</p>\n\n<ul>\n\t<li>找到 <code>nums</code>&nbsp;中的 <strong>最小</strong>&nbsp;值&nbsp;<code>x</code>&nbsp;，如果存在多个最小值，选择最 <strong>前面</strong>&nbsp;的一个。</li>\n\t<li>将 <code>x</code>&nbsp;替换为&nbsp;<code>x * multiplier</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回执行完 <code>k</code>&nbsp;次乘运算之后，最终的 <code>nums</code>&nbsp;数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,1,3,5,6], k = 5, multiplier = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[8,4,6,5,6]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<table>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>操作</th>\n\t\t\t<th>结果</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1 次操作后</td>\n\t\t\t<td>[2, 2, 3, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2 次操作后</td>\n\t\t\t<td>[4, 2, 3, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3 次操作后</td>\n\t\t\t<td>[4, 4, 3, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>4 次操作后</td>\n\t\t\t<td>[4, 4, 6, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>5 次操作后</td>\n\t\t\t<td>[8, 4, 6, 5, 6]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b></span>nums = [1,2], k = 3, multiplier = 4</p>\n\n<p><span class=\"example-io\"><b>输出：</b></span>[16,8]</p>\n\n<p><strong>解释：</strong></p>\n\n<table>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>操作</th>\n\t\t\t<th>结果</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1 次操作后</td>\n\t\t\t<td>[4, 2]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2 次操作后</td>\n\t\t\t<td>[4, 8]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3 次操作后</td>\n\t\t\t<td>[16, 8]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>1 &lt;= multiplier &lt;= 5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3265.统计近似相等数对 I",
        "hardRate": "MEDIUM",
        "passRate": "43.07%",
        "problemsUrl": "https://leetcode.cn/problems/count-almost-equal-pairs-i/",
        "solutionsUrl": "https://leetcode.cn/problems/count-almost-equal-pairs-i/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>如果我们执行以下操作 <strong>至多一次</strong>&nbsp;可以让两个整数&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;相等，那么我们称这个数对是 <strong>近似相等</strong>&nbsp;的：</p>\n\n<ul>\n\t<li>选择&nbsp;<code>x</code> <strong>或者</strong>&nbsp;<code>y</code> &nbsp;之一，将这个数字中的两个数位交换。</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中，下标 <code>i</code>&nbsp;和 <code>j</code>&nbsp;满足&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i]</code> 和&nbsp;<code>nums[j]</code> <strong>近似相等</strong>&nbsp;的数对数目。</p>\n\n<p><b>注意</b>&nbsp;，执行操作后一个整数可以有前导 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [3,12,30,17,21]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>近似相等数对包括：</p>\n\n<ul>\n\t<li>3 和 30 。交换 30 中的数位 3 和 0 ，得到 3 。</li>\n\t<li>12 和 21 。交换12 中的数位 1 和 2 ，得到 21 。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,1,1,1,1]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>10</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>数组中的任意两个元素都是近似相等的。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [123,231]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>0</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>我们无法通过交换 123&nbsp;或者 231 中的两个数位得到另一个数。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3266.K 次乘运算后的最终数组 II",
        "hardRate": "HARD",
        "passRate": "38.23%",
        "problemsUrl": "https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，一个整数&nbsp;<code>k</code>&nbsp;&nbsp;和一个整数&nbsp;<code>multiplier</code>&nbsp;。</p>\n\n<p>你需要对 <code>nums</code>&nbsp;执行 <code>k</code>&nbsp;次操作，每次操作中：</p>\n\n<ul>\n\t<li>找到 <code>nums</code>&nbsp;中的 <strong>最小</strong>&nbsp;值&nbsp;<code>x</code>&nbsp;，如果存在多个最小值，选择最 <strong>前面</strong>&nbsp;的一个。</li>\n\t<li>将 <code>x</code>&nbsp;替换为&nbsp;<code>x * multiplier</code>&nbsp;。</li>\n</ul>\n\n<p><code>k</code>&nbsp;次操作以后，你需要将 <code>nums</code>&nbsp;中每一个数值对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余。</p>\n\n<p>请你返回执行完 <code>k</code>&nbsp;次乘运算以及取余运算之后，最终的 <code>nums</code>&nbsp;数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,1,3,5,6], k = 5, multiplier = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[8,4,6,5,6]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<table>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>操作</th>\n\t\t\t<th>结果</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1 次操作后</td>\n\t\t\t<td>[2, 2, 3, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2 次操作后</td>\n\t\t\t<td>[4, 2, 3, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3 次操作后</td>\n\t\t\t<td>[4, 4, 3, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>4 次操作后</td>\n\t\t\t<td>[4, 4, 6, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>5 次操作后</td>\n\t\t\t<td>[8, 4, 6, 5, 6]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>取余操作后</td>\n\t\t\t<td>[8, 4, 6, 5, 6]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [100000,2000], k = 2, multiplier = 1000000</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[999999307,999999993]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<table>\n\t<tbody>\n\t\t<tr>\n\t\t\t<th>操作</th>\n\t\t\t<th>结果</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1 次操作后</td>\n\t\t\t<td>[100000, 2000000000]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2 次操作后</td>\n\t\t\t<td>[100000000000, 2000000000]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>取余操作后</td>\n\t\t\t<td>[999999307, 999999993]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= multiplier &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3267.统计近似相等数对 II",
        "hardRate": "HARD",
        "passRate": "39.09%",
        "problemsUrl": "https://leetcode.cn/problems/count-almost-equal-pairs-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-almost-equal-pairs-ii/solution",
        "problemsDesc": "<p><strong>注意：</strong>在这个问题中，操作次数增加为至多&nbsp;<strong>两次</strong>&nbsp;。</p>\n\n<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>如果我们执行以下操作 <strong>至多<u>两次</u></strong>&nbsp;可以让两个整数&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;相等，那么我们称这个数对是 <strong>近似相等</strong>&nbsp;的：</p>\n\n<ul>\n\t<li>选择&nbsp;<code>x</code> <strong>或者</strong>&nbsp;<code>y</code> &nbsp;之一，将这个数字中的两个数位交换。</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中，下标 <code>i</code>&nbsp;和 <code>j</code>&nbsp;满足&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i]</code> 和&nbsp;<code>nums[j]</code> <strong>近似相等</strong>&nbsp;的数对数目。</p>\n\n<p><b>注意</b>&nbsp;，执行操作后得到的整数可以有前导 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1023,2310,2130,213]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>近似相等数对包括：</p>\n\n<ul>\n\t<li>1023 和 2310 。交换 1023 中数位 1 和 2 ，然后交换数位 0 和 3 ，得到 2310 。</li>\n\t<li>1023 和 213 。交换 1023 中数位 1 和 0 ，然后交换数位 1 和 2 ，得到 0213 ，也就是 213 。</li>\n\t<li>2310 和 213 。交换 2310 中数位 2 和 0 ，然后交换数位 3 和 2 ，得到 0213 ，也就是 213 。</li>\n\t<li>2310 和 2130 。交换 2310 中数位 3 和 1 ，得到 2130 。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,10,100]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>近似相等数对包括：</p>\n\n<ul>\n\t<li>1 和 10 。交换 10 中数位 1 和 0&nbsp;，得到 01 ，也就是 1&nbsp;。</li>\n\t<li>1 和 100 。交换 100 中数位 1 和从左往右的第二个 0 ，得到 001 ，也就是 1 。</li>\n\t<li>10 和 100 。交换 100 中数位 1 和从左往右的第一个 0 ，得到 010 ，也就是 10 。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;&nbsp;10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3268.查找重叠的班次 II",
        "hardRate": "HARD",
        "passRate": "64.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-overlapping-shifts-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-overlapping-shifts-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3269.构建两个递增数组",
        "hardRate": "HARD",
        "passRate": "63.54%",
        "problemsUrl": "https://leetcode.cn/problems/constructing-two-increasing-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/constructing-two-increasing-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3270.求出数字答案",
        "hardRate": "EASY",
        "passRate": "85.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-key-of-the-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-key-of-the-numbers/solution",
        "problemsDesc": "<p>给你三个 <strong>正</strong>&nbsp;整数&nbsp;<code>num1</code>&nbsp;，<code>num2</code>&nbsp;和&nbsp;<code>num3</code>&nbsp;。</p>\n\n<p>数字 <code>num1</code>&nbsp;，<code>num2</code>&nbsp;和 <code>num3</code>&nbsp;的数字答案 <code>key</code>&nbsp;是一个四位数，定义如下：</p>\n\n<ul>\n\t<li>一开始，如果有数字 <strong>少于</strong>&nbsp;四位数，给它补 <strong>前导 0 </strong>。</li>\n\t<li>答案 <code>key</code>&nbsp;的第&nbsp;<code>i</code>&nbsp;个数位（<code>1 &lt;= i &lt;= 4</code>）为&nbsp;<code>num1</code>&nbsp;，<code>num2</code>&nbsp;和&nbsp;<code>num3</code>&nbsp;第&nbsp;<code>i</code>&nbsp;个数位中的&nbsp;<strong>最小</strong>&nbsp;值。</li>\n</ul>\n\n<p>请你返回三个数字 <strong>没有</strong>&nbsp;前导 0 的数字答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>num1 = 1, num2 = 10, num3 = 1000</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>0</span></p>\n\n<p><b>解释：</b></p>\n\n<p>补前导 0 后，<code>num1</code>&nbsp;变为&nbsp;<code>\"0001\"</code>&nbsp;，<code>num2</code> 变为&nbsp;<code>\"0010\"</code>&nbsp;，<code>num3</code>&nbsp;保持不变，为&nbsp;<code>\"1000\"</code>&nbsp;。</p>\n\n<ul>\n\t<li>数字答案 <code>key</code>&nbsp;的第&nbsp;<code>1</code>&nbsp;个数位为&nbsp;<code>min(0, 0, 1)</code>&nbsp;。</li>\n\t<li>数字答案 <code>key</code>&nbsp;的第&nbsp;<code>2</code>&nbsp;个数位为&nbsp;<code>min(0, 0, 0)</code>&nbsp;。</li>\n\t<li>数字答案 <code>key</code>&nbsp;的第 <code>3</code> 个数位为&nbsp;<code>min(0, 1, 0)</code>&nbsp;。</li>\n\t<li>数字答案 <code>key</code>&nbsp;的第 <code>4</code> 个数位为&nbsp;<code>min(1, 0, 0)</code>&nbsp;。</li>\n</ul>\n\n<p>所以数字答案为&nbsp;<code>\"0000\"</code>&nbsp;，也就是 0 。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">num1 = 987, num2 = 879, num3 = 798</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>777</span></p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>num1 = 1, num2 = 2, num3 = 3</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1, num2, num3 &lt;= 9999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3271.哈希分割字符串",
        "hardRate": "MEDIUM",
        "passRate": "84.70%",
        "problemsUrl": "https://leetcode.cn/problems/hash-divided-string/",
        "solutionsUrl": "https://leetcode.cn/problems/hash-divided-string/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的字符串 <code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，<code>n</code>&nbsp;是 <code>k</code>&nbsp;的 <strong>倍数</strong>&nbsp;。你的任务是将字符串 <code>s</code>&nbsp;哈希为一个长度为 <code>n / k</code>&nbsp;的新字符串&nbsp;<code>result</code>&nbsp;。</p>\n\n<p>首先，将&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>n / k</code>&nbsp;个&nbsp;<strong><span data-keyword=\"substring-nonempty\">子字符串</span></strong>&nbsp;，每个子字符串的长度都为&nbsp;<code>k</code>&nbsp;。然后，将&nbsp;<code>result</code>&nbsp;初始化为一个 <strong>空</strong>&nbsp;字符串。</p>\n\n<p>我们依次从前往后处理每一个 <strong>子字符串</strong>&nbsp;：</p>\n\n<ul>\n\t<li>一个字符的 <strong>哈希值</strong>&nbsp;是它在 <strong>字母表</strong>&nbsp;中的下标（也就是&nbsp;<code>'a' →<!-- notionvc: d3f8e4c2-23cd-41ad-a14b-101dfe4c5aba --> 0</code>&nbsp;，<code>'b' →<!-- notionvc: d3f8e4c2-23cd-41ad-a14b-101dfe4c5aba --> 1</code>&nbsp;，... ，<code>'z' →<!-- notionvc: d3f8e4c2-23cd-41ad-a14b-101dfe4c5aba --> 25</code>）。</li>\n\t<li>将子字符串中字母的 <strong>哈希值</strong>&nbsp;求和。</li>\n\t<li>将和对 26 取余，将结果记为&nbsp;<code>hashedChar</code>&nbsp;。</li>\n\t<li>找到小写字母表中 <code>hashedChar</code>&nbsp;对应的字符。</li>\n\t<li>将该字符添加到&nbsp;<code>result</code>&nbsp;的末尾。</li>\n</ul>\n\n<p>返回&nbsp;<code>result</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>s = \"abcd\", k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>\"bf\"</span></p>\n\n<p><b>解释：</b></p>\n\n<p>第一个字符串为&nbsp;<code>\"ab\"</code>&nbsp;，<code>0 + 1 = 1</code>&nbsp;，<code>1 % 26 = 1</code>&nbsp;，<code>result[0] = 'b'</code>&nbsp;。</p>\n\n<p>第二个字符串为： <code>\"cd\"</code>&nbsp;，<code>2 + 3 = 5</code>&nbsp;，<code>5 % 26 = 5</code>&nbsp;，<code>result[1] = 'f'</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>s = \"mxz\", k = 3</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>\"i\"</span></p>\n\n<p><b>解释：</b></p>\n\n<p>唯一的子字符串为&nbsp;<code>\"mxz\"</code>&nbsp;，<code>12 + 23 + 25 = 60</code>&nbsp;，<code>60 % 26 = 8</code>&nbsp;，<code>result[0] = 'i'</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>k &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s.length</code>&nbsp;能被 <code>k</code>&nbsp;整除。</li>\n\t<li><code>s</code> 只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3272.统计好整数的数目",
        "hardRate": "HARD",
        "passRate": "54.99%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-count-of-good-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-count-of-good-integers/solution",
        "problemsDesc": "<p>给你两个 <strong>正</strong>&nbsp;整数&nbsp;<code>n</code> 和&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果一个整数&nbsp;<code>x</code>&nbsp;满足以下条件，那么它被称为 <strong>k</strong><strong>&nbsp;回文</strong>&nbsp;整数&nbsp;。</p>\n\n<ul>\n\t<li><code>x</code>&nbsp;是一个&nbsp;<span data-keyword=\"palindrome-integer\">回文整数 。</span></li>\n\t<li><code>x</code>&nbsp;能被 <code>k</code>&nbsp;整除。</li>\n</ul>\n\n<p>如果一个整数的数位重新排列后能得到一个 <strong>k 回文整数</strong>&nbsp;，那么我们称这个整数为&nbsp;<strong>好 </strong>整数。比方说，<code>k = 2</code>&nbsp;，那么&nbsp;2020 可以重新排列得到 2002 ，2002 是一个 k 回文串，所以 2020 是一个好整数。而 1010 无法重新排列数位得到一个 k 回文整数。</p>\n\n<p>请你返回 <code>n</code>&nbsp;个数位的整数中，有多少个 <strong>好</strong>&nbsp;整数。</p>\n\n<p><b>注意</b>&nbsp;，任何整数在重新排列数位之前或者之后 <strong>都不能</strong> 有前导 0 。比方说 1010 不能重排列得到&nbsp;101 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>n = 3, k = 5</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>27</span></p>\n\n<p><b>解释：</b></p>\n\n<p>部分好整数如下：</p>\n\n<ul>\n\t<li>551 ，因为它可以重排列得到 515 。</li>\n\t<li>525 ，因为它已经是一个 k 回文整数。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>n = 1, k = 4</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>两个好整数分别是 4 和 8 。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>n = 5, k = 6</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>2468</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= k &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3273.对 Bob 造成的最少伤害",
        "hardRate": "HARD",
        "passRate": "47.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-damage-dealt-to-bob/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-damage-dealt-to-bob/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>power</code>&nbsp;和两个整数数组&nbsp;<code>damage</code> 和&nbsp;<code>health</code>&nbsp;，两个数组的长度都为&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>Bob 有&nbsp;<code>n</code>&nbsp;个敌人，如果第&nbsp;<code>i</code>&nbsp;个敌人还活着（也就是健康值&nbsp;<code>health[i] &gt; 0</code>&nbsp;的时候），每秒钟会对 Bob 造成&nbsp;<code>damage[i]</code>&nbsp;<strong>点</strong>&nbsp;伤害。</p>\n\n<p>每一秒中，在敌人对 Bob 造成伤害 <strong>之后</strong>&nbsp;，Bob 会选择 <strong>一个</strong>&nbsp;还活着的敌人进行攻击，该敌人的健康值减少 <code>power</code>&nbsp;。</p>\n\n<p>请你返回 Bob 将 <strong>所有</strong>&nbsp;<code>n</code>&nbsp;个敌人都消灭之前，<strong>最少</strong>&nbsp;会受到多少伤害。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>power = 4, damage = [1,2,3,4], health = [4,5,6,8]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>39</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>最开始 2 秒内都攻击敌人 3 ，然后敌人 3 会被消灭，这段时间内对 Bob 的总伤害是&nbsp;<code>10 + 10 = 20</code>&nbsp;点。</li>\n\t<li>接下来 2 秒内都攻击敌人 2 ，然后敌人 2 会被消灭，这段时间内对 Bob 的总伤害是&nbsp;<code>6 + 6 = 12</code>&nbsp;点。</li>\n\t<li>接下来 1 秒内都攻击敌人 0 ，然后敌人 0 会被消灭，这段时间内对 Bob 的总伤害是&nbsp;<code>3</code>&nbsp;点。</li>\n\t<li>接下来 2 秒内都攻击敌人 1 ，然后敌人 1 会被消灭，这段时间内对 Bob 的总伤害是&nbsp;<code>2 + 2 = 4</code>&nbsp;点。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>power = 1, damage = [1,1,1,1], health = [1,2,3,4]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>20</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>最开始 1 秒内都攻击敌人 0 ，然后敌人 0 会被消灭，这段时间对 Bob 的总伤害是&nbsp;<code>4</code>&nbsp;点。</li>\n\t<li>接下来 2 秒内都攻击敌人 1 ，然后敌人 1 会被消灭，这段时间对 Bob 的总伤害是&nbsp;<code>3 + 3 = 6</code>&nbsp;点。</li>\n\t<li>接下来 3 秒内都攻击敌人 2 ，然后敌人 2 会被消灭，这段时间对 Bob 的总伤害是&nbsp;<code>2 + 2 + 2 = 6</code>&nbsp;点。</li>\n\t<li>接下来 4 秒内都攻击敌人 3 ，然后敌人 3 会被消灭，这段时间对 Bob 的总伤害是&nbsp;<code>1 + 1 + 1 + 1 = 4</code>&nbsp;点。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>power = 8, damage = [40], health = [59]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>320</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= power &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= n == damage.length == health.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= damage[i], health[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3274.检查棋盘方格颜色是否相同",
        "hardRate": "EASY",
        "passRate": "79.33%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-chessboard-squares-have-the-same-color/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-chessboard-squares-have-the-same-color/solution",
        "problemsDesc": "<p>给你两个字符串 <code>coordinate1</code> 和 <code>coordinate2</code>，代表 <code>8 x 8</code> 国际象棋棋盘上的两个方格的坐标。</p>\n\n<p>以下是棋盘的参考图。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/07/17/screenshot-2021-02-20-at-22159-pm.png\" style=\"width: 400px; height: 396px;\" /></p>\n\n<p>如果这两个方格颜色相同，返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>坐标总是表示有效的棋盘方格。坐标的格式总是先字母（表示列），再数字（表示行）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">coordinate1 = \"a1\", coordinate2 = \"c3\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>两个方格均为黑色。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">coordinate1 = \"a1\", coordinate2 = \"h3\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">false</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>方格 <code>\"a1\"</code> 是黑色，而 <code>\"h3\"</code> 是白色。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>coordinate1.length == coordinate2.length == 2</code></li>\n\t<li><code>'a' &lt;= coordinate1[0], coordinate2[0] &lt;= 'h'</code></li>\n\t<li><code>'1' &lt;= coordinate1[1], coordinate2[1] &lt;= '8'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3275.第 K 近障碍物查询",
        "hardRate": "MEDIUM",
        "passRate": "39.39%",
        "problemsUrl": "https://leetcode.cn/problems/k-th-nearest-obstacle-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/k-th-nearest-obstacle-queries/solution",
        "problemsDesc": "<p>有一个无限大的二维平面。</p>\n\n<p>给你一个正整数&nbsp;<code>k</code>&nbsp;，同时给你一个二维数组&nbsp;<code>queries</code>&nbsp;，包含一系列查询：</p>\n\n<ul>\n\t<li><code>queries[i] = [x, y]</code>&nbsp;：在平面上坐标&nbsp;<code>(x, y)</code>&nbsp;处建一个障碍物，数据保证之前的查询 <strong>不会</strong> 在这个坐标处建立任何障碍物。</li>\n</ul>\n\n<p>每次查询后，你需要找到离原点第 <code>k</code>&nbsp;<strong>近</strong>&nbsp;障碍物到原点的 <strong>距离</strong>&nbsp;。</p>\n\n<p>请你返回一个整数数组&nbsp;<code>results</code>&nbsp;，其中&nbsp;<code>results[i]</code>&nbsp;表示建立第 <code>i</code>&nbsp;个障碍物以后，离原地第 <code>k</code>&nbsp;近障碍物距离原点的距离。如果少于 <code>k</code>&nbsp;个障碍物，<code>results[i] == -1</code>&nbsp;。</p>\n\n<p><strong>注意</strong>，一开始&nbsp;<strong>没有</strong>&nbsp;任何障碍物。</p>\n\n<p>坐标在&nbsp;<code>(x, y)</code>&nbsp;处的点距离原点的距离定义为&nbsp;<code>|x| + |y|</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[-1,7,5,3]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>最初，不存在障碍物。</p>\n\n<ul>\n\t<li><code>queries[0]</code>&nbsp;之后，少于 2 个障碍物。</li>\n\t<li><code>queries[1]</code>&nbsp;之后，&nbsp;两个障碍物距离原点的距离分别为 3 和 7 。</li>\n\t<li><code>queries[2]</code>&nbsp;之后，障碍物距离原点的距离分别为 3 ，5 和 7 。</li>\n\t<li><code>queries[3]</code>&nbsp;之后，障碍物距离原点的距离分别为 3，3，5 和 7 。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>queries = [[5,5],[4,4],[3,3]], k = 1</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[10,8,6]</span></p>\n\n<p><b>解释：</b></p>\n\n<ul>\n\t<li><code>queries[0]</code>&nbsp;之后，只有一个障碍物，距离原点距离为 10 。</li>\n\t<li><code>queries[1]</code>&nbsp;之后，障碍物距离原点距离分别为 8 和 10 。</li>\n\t<li><code>queries[2]</code>&nbsp;之后，障碍物距离原点的距离分别为 6， 8 和10 。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queries.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>所有&nbsp;<code>queries[i]</code>&nbsp;互不相同。</li>\n\t<li><code>-10<sup>9</sup> &lt;= queries[i][0], queries[i][1] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3276.选择矩阵中单元格的最大得分",
        "hardRate": "HARD",
        "passRate": "26.39%",
        "problemsUrl": "https://leetcode.cn/problems/select-cells-in-grid-with-maximum-score/",
        "solutionsUrl": "https://leetcode.cn/problems/select-cells-in-grid-with-maximum-score/solution",
        "problemsDesc": "<p>给你一个由正整数构成的二维矩阵 <code>grid</code>。</p>\n\n<p>你需要从矩阵中选择<strong> 一个或多个 </strong>单元格，选中的单元格应满足以下条件：</p>\n\n<ul>\n\t<li>所选单元格中的任意两个单元格都不会处于矩阵的 <strong>同一行</strong>。</li>\n\t<li>所选单元格的值 <strong>互不相同</strong>。</li>\n</ul>\n\n<p>你的得分为所选单元格值的<strong>总和</strong>。</p>\n\n<p>返回你能获得的<strong> 最大 </strong>得分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">grid = [[1,2,3],[4,3,2],[1,1,1]]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">8</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/07/29/grid1drawio.png\" /></p>\n\n<p>选择上图中用彩色标记的单元格，对应的值分别为 1、3 和 4 。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">grid = [[8,7,6],[8,3,2]]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">15</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/07/29/grid8_8drawio.png\" style=\"width: 170px; height: 114px;\" /></p>\n\n<p>选择上图中用彩色标记的单元格，对应的值分别为 7 和 8 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length, grid[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3277.查询子数组最大异或值",
        "hardRate": "HARD",
        "passRate": "47.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-score-subarray-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-score-subarray-queries/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，以及一个大小为 <code>q</code> 的二维整数数组 <code>queries</code>，其中 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code>。</p>\n\n<p>对于每一个查询，你需要找出 <code>nums[l<sub>i</sub>..r<sub>i</sub>]</code> 中任意 <span data-keyword=\"subarray\">子数组</span> 的 <strong>最大异或值</strong>。</p>\n\n<p><strong>数组的异或值 </strong>需要对数组 <code>a</code> 反复执行以下操作，直到只剩一个元素，剩下的那个元素就是 <strong>异或值</strong>：</p>\n\n<ul>\n\t<li><span class=\"text-only\" data-eleid=\"9\" style=\"white-space: pre;\">对于除最后一个下标以外的所有下标</span> <code>i</code>，同时将 <code>a[i]</code> 替换为 <code>a[i] XOR a[i + 1]</code> 。</li>\n\t<li>移除数组的最后一个元素。</li>\n</ul>\n\n<p>返回一个大小为 <code>q</code> 的数组 <code>answer</code>，其中 <code>answer[i]</code> 表示查询 <code>i</code> 的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">nums = [2,8,4,32,16,1], queries = [[0,2],[1,4],[0,5]]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">[12,60,60]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>在第一个查询中，<code>nums[0..2]</code> 的子数组分别是 <code>[2]</code>, <code>[8]</code>, <code>[4]</code>, <code>[2, 8]</code>, <code>[8, 4]</code>, 和 <code>[2, 8, 4]</code>，它们的异或值分别为 2, 8, 4, 10, 12, 和 6。查询的答案是 12，所有异或值中的最大值。</p>\n\n<p>在第二个查询中，<code>nums[1..4]</code> 的子数组中最大的异或值是子数组 <code>nums[1..4]</code> 的异或值，为 60。</p>\n\n<p>在第三个查询中，<code>nums[0..5]</code> 的子数组中最大的异或值是子数组 <code>nums[1..4]</code> 的异或值，为 60。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">nums = [0,7,3,2,8,5,1], queries = [[0,3],[1,5],[2,4],[2,6],[5,6]]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">[7,14,11,14,5]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<table height=\"70\" width=\"472\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th>下标</th>\n\t\t\t<th>nums[l<sub>i</sub>..r<sub>i</sub>]</th>\n\t\t\t<th>最大异或值子数组</th>\n\t\t\t<th>子数组最大异或值</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>0</td>\n\t\t\t<td>[0, 7, 3, 2]</td>\n\t\t\t<td>[7]</td>\n\t\t\t<td>7</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>1</td>\n\t\t\t<td>[7, 3, 2, 8, 5]</td>\n\t\t\t<td>[7, 3, 2, 8]</td>\n\t\t\t<td>14</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>2</td>\n\t\t\t<td>[3, 2, 8]</td>\n\t\t\t<td>[3, 2, 8]</td>\n\t\t\t<td>11</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>3</td>\n\t\t\t<td>[3, 2, 8, 5, 1]</td>\n\t\t\t<td>[2, 8, 5, 1]</td>\n\t\t\t<td>14</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>4</td>\n\t\t\t<td>[5, 1]</td>\n\t\t\t<td>[5]</td>\n\t\t\t<td>5</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= q == queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code></li>\n\t<li><code>0 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3278.寻找数据科学家职位的候选人 II",
        "hardRate": "MEDIUM",
        "passRate": "46.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-candidates-for-data-scientist-position-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-candidates-for-data-scientist-position-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3279.活塞占据的最大总区域",
        "hardRate": "HARD",
        "passRate": "61.90%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-total-area-occupied-by-pistons/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-total-area-occupied-by-pistons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3280.将日期转换为二进制表示",
        "hardRate": "EASY",
        "passRate": "91.77%",
        "problemsUrl": "https://leetcode.cn/problems/convert-date-to-binary/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-date-to-binary/solution",
        "problemsDesc": "<p>给你一个字符串 <code>date</code>，它的格式为 <code>yyyy-mm-dd</code>，表示一个公历日期。</p>\n\n<p><code>date</code> 可以重写为二进制表示，只需要将年、月、日分别转换为对应的二进制表示（不带前导零）并遵循 <code>year-month-day</code> 的格式。</p>\n\n<p>返回 <code>date</code> 的 <strong>二进制</strong> 表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">date = \"2080-02-29\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">\"100000100000-10-11101\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><span class=\"example-io\">100000100000, 10 和 11101 分别是 2080, 02 和 29 的二进制表示。</span></p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">date = \"1900-01-01\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">\"11101101100-1-1\"</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><span class=\"example-io\">11101101100, 1 和 1 分别是 1900, 1 和 1 的二进制表示。</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>date.length == 10</code></li>\n\t<li><code>date[4] == date[7] == '-'</code>，其余的 <code>date[i]</code> 都是数字。</li>\n\t<li>输入保证 <code>date</code> 代表一个有效的公历日期，日期范围从 1900 年 1 月 1 日到 2100 年 12 月 31 日（包括这两天）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3281.范围内整数的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "36.06%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-score-of-numbers-in-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-score-of-numbers-in-ranges/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>start</code> 和一个整数 <code>d</code>，代表 <code>n</code> 个区间 <code>[start[i], start[i] + d]</code>。</p>\n\n<p>你需要选择 <code>n</code> 个整数，其中第 <code>i</code> 个整数必须属于第 <code>i</code> 个区间。所选整数的 <strong>得分</strong> 定义为所选整数两两之间的 <strong>最小 </strong>绝对差。</p>\n\n<p>返回所选整数的 <strong>最大可能得分 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">start = [6,0,3], d = 2</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>可以选择整数 8, 0 和 4 获得最大可能得分，得分为 <code>min(|8 - 0|, |8 - 4|, |0 - 4|)</code>，等于 4。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">start = [2,6,13,13], d = 5</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">5</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>可以选择整数 2, 7, 13 和 18 获得最大可能得分，得分为 <code>min(|2 - 7|, |2 - 13|, |2 - 18|, |7 - 13|, |7 - 18|, |13 - 18|)</code>，等于 5。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= start.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= start[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= d &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3282.到达数组末尾的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "37.07%",
        "problemsUrl": "https://leetcode.cn/problems/reach-end-of-array-with-max-score/",
        "solutionsUrl": "https://leetcode.cn/problems/reach-end-of-array-with-max-score/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>你的目标是从下标 <code>0</code>&nbsp;出发，到达下标 <code>n - 1</code>&nbsp;处。每次你只能移动到&nbsp;<strong>更大</strong>&nbsp;的下标处。</p>\n\n<p>从下标 <code>i</code>&nbsp;跳到下标 <code>j</code>&nbsp;的得分为&nbsp;<code>(j - i) * nums[i]</code>&nbsp;。</p>\n\n<p>请你返回你到达最后一个下标处能得到的 <strong>最大总得分</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,3,1,5]</span></p>\n\n<p><b>输出：</b>7</p>\n\n<p><b>解释：</b></p>\n\n<p>一开始跳到下标 1 处，然后跳到最后一个下标处。总得分为&nbsp;<code>1 * 1 + 2 * 3 = 7</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [4,3,1,3,2]</span></p>\n\n<p><b>输出：</b>16</p>\n\n<p><strong>解释：</strong></p>\n\n<p>直接跳到最后一个下标处。总得分为&nbsp;<code>4 * 4 = 16</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3283.吃掉所有兵需要的最多移动次数",
        "hardRate": "HARD",
        "passRate": "53.92%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-to-kill-all-pawns/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-to-kill-all-pawns/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>50 x 50</code>&nbsp;的国际象棋棋盘，棋盘上有 <strong>一个</strong>&nbsp;马和一些兵。给你两个整数&nbsp;<code>kx</code> 和&nbsp;<code>ky</code>&nbsp;，其中&nbsp;<code>(kx, ky)</code>&nbsp;表示马所在的位置，同时还有一个二维数组&nbsp;<code>positions</code>&nbsp;，其中&nbsp;<code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示第 <code>i</code>&nbsp;个兵在棋盘上的位置。</p>\n\n<p>Alice 和 Bob 玩一个回合制游戏，Alice 先手。玩家的一次操作中，可以执行以下操作：</p>\n\n<ul>\n\t<li>玩家选择一个仍然在棋盘上的兵，然后移动马，通过 <strong>最少</strong>&nbsp;的 <strong>步数</strong> 吃掉这个兵。<strong>注意</strong>&nbsp;，玩家可以选择&nbsp;<strong>任意</strong>&nbsp;一个兵，<strong>不一定</strong>&nbsp;要选择从马的位置出发&nbsp;<strong>最少</strong>&nbsp;移动步数的兵。</li>\n\t<li><span>在马吃兵的过程中，马 <strong>可能</strong>&nbsp;会经过一些其他兵的位置，但这些兵 <strong>不会</strong>&nbsp;被吃掉。<strong>只有</strong>&nbsp;选中的兵在这个回合中被吃掉。</span></li>\n</ul>\n\n<p>Alice 的目标是 <strong>最大化</strong>&nbsp;两名玩家的 <strong>总</strong>&nbsp;移动次数，直到棋盘上不再存在兵，而 Bob 的目标是 <strong>最小化</strong>&nbsp;总移动次数。</p>\n\n<p>假设两名玩家都采用 <strong>最优</strong>&nbsp;策略，请你返回可以达到的 <strong>最大</strong>&nbsp;总移动次数。</p>\n\n<p>在一次&nbsp;<strong>移动</strong>&nbsp;中，如下图所示，马有 8 个可以移动到的位置，每个移动位置都是沿着坐标轴的一个方向前进 2 格，然后沿着垂直的方向前进 1 格。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2024/08/01/chess_knight.jpg\" style=\"width: 275px; height: 273px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>kx = 1, ky = 1, positions = [[0,0]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/16/gif3.gif\" style=\"width: 275px; height: 275px;\" /></p>\n\n<p>马需要移动 4 步吃掉&nbsp;<code>(0, 0)</code>&nbsp;处的兵。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>kx = 0, ky = 2, positions = [[1,1],[2,2],[3,3]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>8</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/16/gif4.gif\" style=\"width: 320px; height: 320px;\" /></strong></p>\n\n<ul>\n\t<li>Alice 选择&nbsp;<code>(2, 2)</code>&nbsp;处的兵，移动马吃掉它需要 2 步：<code>(0, 2) -&gt; (1, 4) -&gt; (2, 2)</code>&nbsp;。</li>\n\t<li>Bob 选择&nbsp;<code>(3, 3)</code>&nbsp;处的兵，移动马吃掉它需要 2 步：<code>(2, 2) -&gt; (4, 1) -&gt; (3, 3)</code>&nbsp;。</li>\n\t<li>Alice 选择&nbsp;<code>(1, 1)</code>&nbsp;处的兵，移动马吃掉它需要 4 步：<code>(3, 3) -&gt; (4, 1) -&gt; (2, 2) -&gt; (0, 3) -&gt; (1, 1)</code>&nbsp;。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>kx = 0, ky = 0, positions = [[1,2],[2,4]]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>Alice 选择&nbsp;<code>(2, 4)</code>&nbsp;处的兵，移动马吃掉它需要 2 步：<code>(0, 0) -&gt; (1, 2) -&gt; (2, 4)</code>&nbsp;。注意，<code>(1, 2)</code>&nbsp;处的兵不会被吃掉。</li>\n\t<li>Bob 选择&nbsp;<code>(1, 2)</code>&nbsp;处的兵，移动马吃掉它需要 1 步：<code>(2, 4) -&gt; (1, 2)</code>&nbsp;。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= kx, ky &lt;= 49</code></li>\n\t<li><code>1 &lt;= positions.length &lt;= 15</code></li>\n\t<li><code>positions[i].length == 2</code></li>\n\t<li><code>0 &lt;= positions[i][0], positions[i][1] &lt;= 49</code></li>\n\t<li><code>positions[i]</code>&nbsp;两两互不相同。</li>\n\t<li>输入保证对于所有&nbsp;<code>0 &lt;= i &lt; positions.length</code>&nbsp;，都有&nbsp;<code>positions[i] != [kx, ky]</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3284.连续子数组的和",
        "hardRate": "MEDIUM",
        "passRate": "59.60%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-consecutive-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-consecutive-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3285.找到稳定山的下标",
        "hardRate": "EASY",
        "passRate": "91.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-indices-of-stable-mountains/",
        "solutionsUrl": "https://leetcode.cn/problems/find-indices-of-stable-mountains/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;座山排成一列，每座山都有一个高度。给你一个整数数组&nbsp;<code>height</code>&nbsp;，其中&nbsp;<code>height[i]</code>&nbsp;表示第 <code>i</code>&nbsp;座山的高度，再给你一个整数&nbsp;<code>threshold</code>&nbsp;。</p>\n\n<p>对于下标不为 <code>0</code>&nbsp;的一座山，如果它左侧相邻的山的高度 <strong>严格</strong><strong>大于</strong>&nbsp;<code>threshold</code>&nbsp;，那么我们称它是 <strong>稳定</strong>&nbsp;的。我们定义下标为 <code>0</code>&nbsp;的山 <strong>不是</strong>&nbsp;稳定的。</p>\n\n<p>请你返回一个数组，包含所有 <strong>稳定</strong>&nbsp;山的下标，你可以以 <strong>任意</strong>&nbsp;顺序返回下标数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>height = [1,2,3,4,5], threshold = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[3,4]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>下标为 3 的山是稳定的，因为&nbsp;<code>height[2] == 3</code>&nbsp;大于&nbsp;<code>threshold == 2</code>&nbsp;。</li>\n\t<li>下标为 4 的山是稳定的，因为&nbsp;<code>height[3] == 4</code> 大于 <code>threshold == 2</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>height = [10,1,10,1,10], threshold = 3</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[1,3]</span></p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>height = [10,1,10,1,10], threshold = 10</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>[]</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == height.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= height[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= threshold &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3286.穿越网格图的安全路径",
        "hardRate": "MEDIUM",
        "passRate": "41.99%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-safe-walk-through-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-safe-walk-through-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩形&nbsp;<code>grid</code>&nbsp;和一个整数&nbsp;<code>health</code>&nbsp;表示你的健康值。</p>\n\n<p>你开始于矩形的左上角&nbsp;<code>(0, 0)</code>&nbsp;，你的目标是矩形的右下角&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</p>\n\n<p>你可以在矩形中往上下左右相邻格子移动，但前提是你的健康值始终是 <b>正数</b>&nbsp;。</p>\n\n<p>对于格子&nbsp;<code>(i, j)</code>&nbsp;，如果&nbsp;<code>grid[i][j] = 1</code>&nbsp;，那么这个格子视为 <strong>不安全</strong>&nbsp;的，会使你的健康值减少 1 。</p>\n\n<p>如果你可以到达最终的格子，请你返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p><b>注意</b>&nbsp;，当你在最终格子的时候，你的健康值也必须为<strong>&nbsp;正数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]], health = 1</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>true</span></p>\n\n<p><b>解释：</b></p>\n\n<p>沿着下图中灰色格子走，可以安全到达最终的格子。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/04/3868_examples_1drawio.png\" style=\"width: 301px; height: 121px;\" /></div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>grid = [[0,1,1,0,0,0],[1,0,1,0,0,0],[0,1,1,1,0,1],[0,0,1,0,1,0]], health = 3</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>false</span></p>\n\n<p><b>解释：</b></p>\n\n<p>健康值最少为 4 才能安全到达最后的格子。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/04/3868_examples_2drawio.png\" style=\"width: 361px; height: 161px;\" /></div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>grid = [[1,1,1],[1,0,1],[1,1,1]], health = 5</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>true</span></p>\n\n<p><b>解释：</b></p>\n\n<p>沿着下图中灰色格子走，可以安全到达最终的格子。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/04/3868_examples_3drawio.png\" style=\"width: 181px; height: 121px;\" /></p>\n\n<p>任何不经过格子&nbsp;<code>(1, 1)</code>&nbsp;的路径都是不安全的，因为你的健康值到达最终格子时，都会小于等于 0 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n<li><code>2 <= m * n</code></li>\n\t<li><code>1 &lt;= health &lt;= m + n</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是 0 ，要么是 1 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3287.求出数组中最大序列值",
        "hardRate": "HARD",
        "passRate": "69.20%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-sequence-value-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-sequence-value-of-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>定义长度为 <code>2 * x</code>&nbsp;的序列 <code>seq</code>&nbsp;的 <strong>值</strong>&nbsp;为：</p>\n\n<ul>\n\t<li><code>(seq[0] OR seq[1] OR ... OR seq[x - 1]) XOR (seq[x] OR seq[x + 1] OR ... OR seq[2 * x - 1])</code>.</li>\n</ul>\n\n<p>请你求出 <code>nums</code>&nbsp;中所有长度为 <code>2 * k</code>&nbsp;的 <span data-keyword=\"subsequence-array\">子序列</span> 的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2,6,7], k = 1</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>5</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>子序列&nbsp;<code>[2, 7]</code>&nbsp;的值最大，为&nbsp;<code>2 XOR 7 = 5</code>&nbsp;。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [4,2,5,6,7], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>子序列&nbsp;<code>[4, 5, 6, 7]</code>&nbsp;的值最大，为&nbsp;<code>(4 OR 5) XOR (6 OR 7) = 2</code>&nbsp;。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 400</code></li>\n\t<li><code>1 &lt;= nums[i] &lt; 2<sup>7</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3288.最长上升路径的长度",
        "hardRate": "HARD",
        "passRate": "23.03%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-the-longest-increasing-path/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-the-longest-increasing-path/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>coordinates</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，其中&nbsp;<code>0 &lt;= k &lt; n</code>&nbsp;。</p>\n\n<p><code>coordinates[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示二维平面里一个点&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;。</p>\n\n<p>如果一个点序列&nbsp;<code>(x<sub>1</sub>, y<sub>1</sub>)</code>, <code>(x<sub>2</sub>, y<sub>2</sub>)</code>, <code>(x<sub>3</sub>, y<sub>3</sub>)</code>, ..., <code>(x<sub>m</sub>, y<sub>m</sub>)</code>&nbsp;满足以下条件，那么我们称它是一个长度为 <code>m</code>&nbsp;的 <strong>上升序列</strong>&nbsp;：</p>\n\n<ul>\n\t<li>对于所有满足&nbsp;<code>1 &lt;= i &lt; m</code> 的&nbsp;<code>i</code>&nbsp;都有&nbsp;<code>x<sub>i</sub> &lt; x<sub>i + 1</sub></code>&nbsp;且&nbsp;<code>y<sub>i</sub> &lt; y<sub>i + 1</sub></code>&nbsp;。</li>\n\t<li>对于所有&nbsp;<code>1 &lt;= i &lt;= m</code>&nbsp;的&nbsp;<code>i</code>&nbsp;对应的点&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;都在给定的坐标数组里。</li>\n</ul>\n\n<p>请你返回包含坐标 <code>coordinates[k]</code>&nbsp;的 <strong>最长上升路径</strong>&nbsp;的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>coordinates = [[3,1],[2,2],[4,1],[0,0],[5,3]], k = 1</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>(0, 0)</code>&nbsp;，<code>(2, 2)</code>&nbsp;，<code>(5, 3)</code><!-- notionvc: 082cee9e-4ce5-4ede-a09d-57001a72141d -->&nbsp;是包含坐标 <code>(2, 2)</code>&nbsp;的最长上升路径。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>coordinates = [[2,1],[7,0],[5,6]], k = 2</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>2</span></p>\n\n<p><b>解释：</b></p>\n\n<p><code>(2, 1)</code>&nbsp;，<code>(5, 6)</code>&nbsp;是包含坐标 <code>(5, 6)</code>&nbsp;的最长上升路径。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == coordinates.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>coordinates[i].length == 2</code></li>\n\t<li><code>0 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>coordinates</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。<!-- notionvc: 6e412fc2-f9dd-4ba2-b796-5e802a2b305a --><!-- notionvc: c2cf5618-fe99-4909-9b4c-e6b068be22a6 --></li>\n\t<li><code>0 &lt;= k &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3289.数字小镇中的捣蛋鬼",
        "hardRate": "EASY",
        "passRate": "87.04%",
        "problemsUrl": "https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/",
        "solutionsUrl": "https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/solution",
        "problemsDesc": "<p>数字小镇 Digitville 中，存在一个数字列表 <code>nums</code>，其中包含从 <code>0</code> 到 <code>n - 1</code> 的整数。每个数字本应 <strong>只出现一次</strong>，然而，有 <strong>两个 </strong>顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。</p>\n\n<p>为了恢复 Digitville 的和平，作为小镇中的名侦探，请你找出这两个顽皮的数字。</p>\n\n<p>返回一个长度为 2 的数组，包含这两个数字（顺序任意）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">nums = [0,1,1,0]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">[0,1]</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>数字 0 和 1 分别在数组中出现了两次。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">nums = [0,3,2,1,3,2]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">[2,3]</span></p>\n\n<p><strong>解释: </strong></p>\n\n<p>数字 2 和 3 分别在数组中出现了两次。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">nums = [7,1,5,4,3,4,6,0,9,5,8,2]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">[4,5]</span></p>\n\n<p><strong>解释: </strong></p>\n\n<p>数字 4 和 5 分别在数组中出现了两次。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>nums.length == n + 2</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li>输入保证 <code>nums</code> 中<strong> 恰好 </strong>包含两个重复的元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3290.最高乘法得分",
        "hardRate": "MEDIUM",
        "passRate": "40.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-multiplication-score/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-multiplication-score/solution",
        "problemsDesc": "<p>给你一个大小为 4 的整数数组 <code>a</code> 和一个大小 <strong>至少</strong>为 4 的整数数组 <code>b</code>。</p>\n\n<p>你需要从数组 <code>b</code> 中选择四个下标 <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, 和 <code>i<sub>3</sub></code>，并满足 <code>i<sub>0</sub> &lt; i<sub>1</sub> &lt; i<sub>2</sub> &lt; i<sub>3</sub></code>。你的得分将是 <code>a[0] * b[i<sub>0</sub>] + a[1] * b[i<sub>1</sub>] + a[2] * b[i<sub>2</sub>] + a[3] * b[i<sub>3</sub>]</code> 的值。</p>\n\n<p>返回你能够获得的 <strong>最大 </strong>得分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">a = [3,2,5,6], b = [2,-6,4,-5,-3,2,-7]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">26</span></p>\n\n<p><strong>解释：</strong><br />\n选择下标 0, 1, 2 和 5。得分为 <code>3 * 2 + 2 * (-6) + 5 * 4 + 6 * 2 = 26</code>。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">a = [-1,4,5,-2], b = [-5,-1,-3,-2,-4]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">-1</span></p>\n\n<p><strong>解释：</strong><br />\n选择下标 0, 1, 3 和 4。得分为 <code>(-1) * (-5) + 4 * (-1) + 5 * (-2) + (-2) * (-4) = -1</code>。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>a.length == 4</code></li>\n\t<li><code>4 &lt;= b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= a[i], b[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3291.形成目标字符串需要的最少字符串数 I",
        "hardRate": "MEDIUM",
        "passRate": "39.86%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-i/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-i/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>target</code>。</p>\n\n<p>如果字符串 <code>x</code> 是 <code>words</code> 中<strong> 任意 </strong>字符串的 <span data-keyword=\"string-prefix\">前缀</span>，则认为 <code>x</code> 是一个 <strong>有效</strong> 字符串。</p>\n\n<p>现计划通过 <strong>连接 </strong>有效字符串形成 <code>target</code> ，请你计算并返回需要连接的 <strong>最少 </strong>字符串数量。如果无法通过这种方式形成 <code>target</code>，则返回 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">words = [\"abc\",\"aaaaa\",\"bcdef\"], target = \"aabcdabc\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>target 字符串可以通过连接以下有效字符串形成：</p>\n\n<ul>\n\t<li><code>words[1]</code> 的长度为 2 的前缀，即 <code>\"aa\"</code>。</li>\n\t<li><code>words[2]</code> 的长度为 3 的前缀，即 <code>\"bcd\"</code>。</li>\n\t<li><code>words[0]</code> 的长度为 3 的前缀，即 <code>\"abc\"</code>。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">words = [\"abababab\",\"ab\"], target = \"ababaababa\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>target 字符串可以通过连接以下有效字符串形成：</p>\n\n<ul>\n\t<li><code>words[0]</code> 的长度为 5 的前缀，即 <code>\"ababa\"</code>。</li>\n\t<li><code>words[0]</code> 的长度为 5 的前缀，即 <code>\"ababa\"</code>。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">words = [\"abcdef\"], target = \"xyz\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">-1</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>3</sup></code></li>\n\t<li>输入确保 <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>。</li>\n\t<li><code>words[i]</code> 只包含小写英文字母。</li>\n\t<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>3</sup></code></li>\n\t<li><code>target</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3292.形成目标字符串需要的最少字符串数 II",
        "hardRate": "HARD",
        "passRate": "58.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-ii/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>target</code>。</p>\n\n<p>如果字符串 <code>x</code> 是 <code>words</code> 中<strong> 任意 </strong>字符串的 <span data-keyword=\"string-prefix\">前缀</span>，则认为 <code>x</code> 是一个 <strong>有效</strong> 字符串。</p>\n\n<p>现计划通过 <strong>连接 </strong>有效字符串形成 <code>target</code> ，请你计算并返回需要连接的 <strong>最少 </strong>字符串数量。如果无法通过这种方式形成 <code>target</code>，则返回 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">words = [\"abc\",\"aaaaa\",\"bcdef\"], target = \"aabcdabc\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>target 字符串可以通过连接以下有效字符串形成：</p>\n\n<ul>\n\t<li><code>words[1]</code> 的长度为 2 的前缀，即 <code>\"aa\"</code>。</li>\n\t<li><code>words[2]</code> 的长度为 3 的前缀，即 <code>\"bcd\"</code>。</li>\n\t<li><code>words[0]</code> 的长度为 3 的前缀，即 <code>\"abc\"</code>。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">words = [\"abababab\",\"ab\"], target = \"ababaababa\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>target 字符串可以通过连接以下有效字符串形成：</p>\n\n<ul>\n\t<li><code>words[0]</code> 的长度为 5 的前缀，即 <code>\"ababa\"</code>。</li>\n\t<li><code>words[0]</code> 的长度为 5 的前缀，即 <code>\"ababa\"</code>。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">words = [\"abcdef\"], target = \"xyz\"</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">-1</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>输入确保 <code>sum(words[i].length) &lt;= 10<sup>5</sup></code>.</li>\n\t<li><code>words[i]</code> &nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= target.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>target</code> &nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3293.计算产品最终价格",
        "hardRate": "MEDIUM",
        "passRate": "79.89%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-product-final-price/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-product-final-price/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3294.将双链表转换为数组 II",
        "hardRate": "MEDIUM",
        "passRate": "89.59%",
        "problemsUrl": "https://leetcode.cn/problems/convert-doubly-linked-list-to-array-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-doubly-linked-list-to-array-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3295.举报垃圾信息",
        "hardRate": "MEDIUM",
        "passRate": "44.15%",
        "problemsUrl": "https://leetcode.cn/problems/report-spam-message/",
        "solutionsUrl": "https://leetcode.cn/problems/report-spam-message/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>message</code> 和一个字符串数组 <code>bannedWords</code>。</p>\n\n<p>如果数组中 <strong>至少</strong> 存在两个单词与 <code>bannedWords</code> 中的任一单词 <strong>完全相同</strong>，则该数组被视为 <strong>垃圾信息</strong>。</p>\n\n<p>如果数组 <code>message</code> 是垃圾信息，则返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">message = [\"hello\",\"world\",\"leetcode\"], bannedWords = [\"world\",\"hello\"]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>数组 <code>message</code> 中的 <code>\"hello\"</code> 和 <code>\"world\"</code> 都出现在数组 <code>bannedWords</code> 中。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">message = [\"hello\",\"programming\",\"fun\"], bannedWords = [\"world\",\"programming\",\"leetcode\"]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">false</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>数组 <code>message</code> 中只有一个单词（<code>\"programming\"</code>）出现在数组 <code>bannedWords</code> 中。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= message.length, bannedWords.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= message[i].length, bannedWords[i].length &lt;= 15</code></li>\n\t<li><code>message[i]</code> 和 <code>bannedWords[i]</code> 都只由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3296.移山所需的最少秒数",
        "hardRate": "MEDIUM",
        "passRate": "40.55%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/solution",
        "problemsDesc": "<p>给你一个整数 <code>mountainHeight</code> 表示山的高度。</p>\n\n<p>同时给你一个整数数组 <code>workerTimes</code>，表示工人们的工作时间（单位：<strong>秒</strong>）。</p>\n\n<p>工人们需要 <strong>同时 </strong>进行工作以 <strong>降低 </strong>山的高度。对于工人 <code>i</code> :</p>\n\n<ul>\n\t<li>山的高度降低 <code>x</code>，需要花费 <code>workerTimes[i] + workerTimes[i] * 2 + ... + workerTimes[i] * x</code> 秒。例如：\n\n\t<ul>\n\t\t<li>山的高度降低 1，需要 <code>workerTimes[i]</code> 秒。</li>\n\t\t<li>山的高度降低 2，需要 <code>workerTimes[i] + workerTimes[i] * 2</code> 秒，依此类推。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回一个整数，表示工人们使山的高度降低到 0 所需的 <strong>最少</strong> 秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">mountainHeight = 4, workerTimes = [2,1,1]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>将山的高度降低到 0 的一种方式是：</p>\n\n<ul>\n\t<li>工人 0 将高度降低 1，花费 <code>workerTimes[0] = 2</code> 秒。</li>\n\t<li>工人 1 将高度降低 2，花费 <code>workerTimes[1] + workerTimes[1] * 2 = 3</code> 秒。</li>\n\t<li>工人 2 将高度降低 1，花费 <code>workerTimes[2] = 1</code> 秒。</li>\n</ul>\n\n<p>因为工人同时工作，所需的最少时间为 <code>max(2, 3, 1) = 3</code> 秒。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">mountainHeight = 10, workerTimes = [3,2,2,4]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">12</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>工人 0 将高度降低 2，花费 <code>workerTimes[0] + workerTimes[0] * 2 = 9</code> 秒。</li>\n\t<li>工人 1 将高度降低 3，花费 <code>workerTimes[1] + workerTimes[1] * 2 + workerTimes[1] * 3 = 12</code> 秒。</li>\n\t<li>工人 2 将高度降低 3，花费 <code>workerTimes[2] + workerTimes[2] * 2 + workerTimes[2] * 3 = 12</code> 秒。</li>\n\t<li>工人 3 将高度降低 2，花费 <code>workerTimes[3] + workerTimes[3] * 2 = 12</code> 秒。</li>\n</ul>\n\n<p>所需的最少时间为 <code>max(9, 12, 12, 12) = 12</code> 秒。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong> <span class=\"example-io\">mountainHeight = 5, workerTimes = [1]</span></p>\n\n<p><strong>输出：</strong> <span class=\"example-io\">15</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>这个示例中只有一个工人，所以答案是 <code>workerTimes[0] + workerTimes[0] * 2 + workerTimes[0] * 3 + workerTimes[0] * 4 + workerTimes[0] * 5 = 15</code> 秒。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mountainHeight &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= workerTimes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= workerTimes[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3297.统计重新排列后包含另一个字符串的子字符串数目 I",
        "hardRate": "MEDIUM",
        "passRate": "56.34%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-i/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-i/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>&nbsp;。</p>\n\n<p>如果一个字符串 <code>x</code>&nbsp;重新排列后，<code>word2</code>&nbsp;是重排字符串的&nbsp;<span data-keyword=\"string-prefix\">前缀</span>&nbsp;，那么我们称字符串&nbsp;<code>x</code>&nbsp;是&nbsp;<strong>合法的</strong>&nbsp;。</p>\n\n<p>请你返回 <code>word1</code>&nbsp;中 <strong>合法</strong>&nbsp;<span data-keyword=\"substring-nonempty\">子字符串</span>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>word1 = \"bcca\", word2 = \"abc\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>唯一合法的子字符串是&nbsp;<code>\"bcca\"</code>&nbsp;，可以重新排列得到&nbsp;<code>\"abcc\"</code>&nbsp;，<code>\"abc\"</code>&nbsp;是它的前缀。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>word1 = \"abcabc\", word2 = \"abc\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>10</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>除了长度为 1 和 2 的所有子字符串都是合法的。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>word1 = \"abcabc\", word2 = \"aaabc\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>0</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= word2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>word1</code> 和&nbsp;<code>word2</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3298.统计重新排列后包含另一个字符串的子字符串数目 II",
        "hardRate": "HARD",
        "passRate": "69.23%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>&nbsp;。</p>\n\n<p>如果一个字符串 <code>x</code>&nbsp;重新排列后，<code>word2</code>&nbsp;是重排字符串的&nbsp;<span data-keyword=\"string-prefix\">前缀</span>&nbsp;，那么我们称字符串&nbsp;<code>x</code>&nbsp;是&nbsp;<strong>合法的</strong>&nbsp;。</p>\n\n<p>请你返回 <code>word1</code>&nbsp;中 <strong>合法</strong>&nbsp;<span data-keyword=\"substring-nonempty\">子字符串</span>&nbsp;的数目。</p>\n\n<p><strong>注意</strong>&nbsp;，这个问题中的内存限制比其他题目要&nbsp;<strong>小</strong>&nbsp;，所以你&nbsp;<strong>必须</strong>&nbsp;实现一个线性复杂度的解法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>word1 = \"bcca\", word2 = \"abc\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>唯一合法的子字符串是&nbsp;<code>\"bcca\"</code>&nbsp;，可以重新排列得到&nbsp;<code>\"abcc\"</code>&nbsp;，<code>\"abc\"</code>&nbsp;是它的前缀。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>word1 = \"abcabc\", word2 = \"abc\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>10</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>除了长度为 1 和 2 的所有子字符串都是合法的。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>word1 = \"abcabc\", word2 = \"aaabc\"</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>0</span></p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= word2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>word1</code> 和&nbsp;<code>word2</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3299.连续子序列的和",
        "hardRate": "HARD",
        "passRate": "62.60%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-consecutive-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-consecutive-subsequences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 3300.替换为数位和以后的最小元素",
        "hardRate": "EASY",
        "passRate": "85.32%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-element-after-replacement-with-digit-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-element-after-replacement-with-digit-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>请你将 <code>nums</code>&nbsp;中每一个元素都替换为它的各个数位之 <strong>和</strong>&nbsp;。</p>\n\n<p>请你返回替换所有元素以后 <code>nums</code>&nbsp;中的 <strong>最小</strong>&nbsp;元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [10,12,13,14]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>nums</code>&nbsp;替换后变为&nbsp;<code>[1, 3, 4, 5]</code>&nbsp;，最小元素为 1 。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [1,2,3,4]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>1</span></p>\n\n<p><b>解释：</b></p>\n\n<p><code>nums</code>&nbsp;替换后变为&nbsp;<code>[1, 2, 3, 4]</code>&nbsp;，最小元素为 1 。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [999,19,199]</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>10</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p><code>nums</code>&nbsp;替换后变为&nbsp;<code>[27, 10, 19]</code>&nbsp;，最小元素为 10 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    }
]