[
    {
        "problemsName": " 2901.最长相邻不相等子序列 II",
        "hardRate": "MEDIUM",
        "passRate": "41.13%",
        "problemsUrl": "https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个下标从&nbsp;<strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>words</code>&nbsp;，和一个下标从&nbsp;<strong>0</strong>&nbsp;开始的数组&nbsp;<code>groups</code>&nbsp;，两个数组长度都是&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>两个长度相等字符串的 <strong>汉明距离</strong>&nbsp;定义为对应位置字符&nbsp;<strong>不同</strong>&nbsp;的数目。</p>\n\n<p>你需要从下标&nbsp;<code>[0, 1, ..., n - 1]</code>&nbsp;中选出一个&nbsp;<strong>最长<span data-keyword=\"subsequence-array\">子序列</span></strong>&nbsp;，将这个子序列记作长度为 <code>k</code> 的&nbsp;<code>[i<sub>0</sub>, i<sub>1</sub>, ..., i<sub>k - 1</sub>]</code>&nbsp;，它需要满足以下条件：</p>\n\n<ul>\n\t<li><strong>相邻</strong> 下标对应的 <code>groups</code> 值 <strong>不同</strong>。即，对于所有满足&nbsp;<code>0 &lt; j + 1 &lt; k</code>&nbsp;的&nbsp;<code>j</code>&nbsp;都有&nbsp;<code>groups[i<sub>j</sub>] != groups[i<sub>j + 1</sub>]</code>&nbsp;。</li>\n\t<li>对于所有&nbsp;<code>0 &lt; j + 1 &lt; k</code>&nbsp;的下标&nbsp;<code>j</code>&nbsp;，都满足&nbsp;<code>words[i<sub>j</sub>]</code> 和&nbsp;<code>words[i<sub>j + 1</sub>]</code>&nbsp;的长度 <strong>相等</strong>&nbsp;，且两个字符串之间的 <strong>汉明距离</strong>&nbsp;为 <code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个字符串数组，它是下标子序列&nbsp;<strong>依次</strong>&nbsp;对应&nbsp;<code>words</code>&nbsp;数组中的字符串连接形成的字符串数组。如果有多个答案，返回任意一个。</p>\n\n<p><strong>子序列</strong>&nbsp;指的是从原数组中删掉一些（也可能一个也不删掉）元素，剩余元素不改变相对位置得到的新的数组。</p>\n\n<p><b>注意：</b><code>words</code>&nbsp;中的字符串长度可能&nbsp;<strong>不相等</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, words = [\"bab\",\"dab\",\"cab\"], groups = [1,2,2]\n<b>输出：</b>[\"bab\",\"cab\"]\n<b>解释：</b>一个可行的子序列是 [0,2] 。\n- groups[0] != groups[2]\n- words[0].length == words[2].length 且它们之间的汉明距离为 1 。\n所以一个可行的答案是 [words[0],words[2]] = [\"bab\",\"cab\"] 。\n另一个可行的子序列是 [0,1] 。\n- groups[0] != groups[1]\n- words[0].length = words[1].length 且它们之间的汉明距离为 1 。\n所以另一个可行的答案是 [words[0],words[1]] = [\"bab\",\"dab\"] 。\n符合题意的最长子序列的长度为 2 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, words = [\"a\",\"b\",\"c\",\"d\"], groups = [1,2,3,4]\n<b>输出：</b>[\"a\",\"b\",\"c\",\"d\"]\n<b>解释：</b>我们选择子序列 [0,1,2,3] 。\n它同时满足两个条件。\n所以答案为 [words[0],words[1],words[2],words[3]] = [\"a\",\"b\",\"c\",\"d\"] 。\n它是所有下标子序列里最长且满足所有条件的。\n所以它是唯一的答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= n == words.length == groups.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= groups[i] &lt;= n</code></li>\n\t<li><code>words</code>&nbsp;中的字符串&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>words[i]</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2902.和带限制的子多重集合的数目",
        "hardRate": "HARD",
        "passRate": "31.65%",
        "problemsUrl": "https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的非负整数数组&nbsp;<code>nums</code>&nbsp;和两个整数&nbsp;<code>l</code> 和&nbsp;<code>r</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;中子多重集合的和在闭区间&nbsp;<code>[l, r]</code>&nbsp;之间的 <strong>子多重集合的数目</strong> 。</p>\n\n<p>由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;取余后返回。</p>\n\n<p><strong>子多重集合</strong> 指的是从数组中选出一些元素构成的 <strong>无序</strong>&nbsp;集合，每个元素 <code>x</code>&nbsp;出现的次数可以是&nbsp;<code>0, 1, ..., occ[x]</code>&nbsp;次，其中&nbsp;<code>occ[x]</code>&nbsp;是元素&nbsp;<code>x</code>&nbsp;在数组中的出现次数。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>如果两个子多重集合中的元素排序后一模一样，那么它们两个是相同的&nbsp;<strong>子多重集合</strong>&nbsp;。</li>\n\t<li><strong>空</strong>&nbsp;集合的和是 <code>0</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,2,3], l = 6, r = 6\n<b>输出：</b>1\n<b>解释：</b>唯一和为 6 的子集合是 {1, 2, 3} 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,4,2,7], l = 1, r = 5\n<b>输出：</b>7\n<b>解释：</b>和在闭区间 [1, 5] 之间的子多重集合为 {1} ，{2} ，{4} ，{2, 2} ，{1, 2} ，{1, 4} 和 {1, 2, 2} 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1,3,5,2], l = 3, r = 5\n<b>输出：</b>9\n<b>解释：</b>和在闭区间 [3, 5] 之间的子多重集合为 {3} ，{5} ，{1, 2} ，{1, 3} ，{2, 2} ，{2, 3} ，{1, 1, 2} ，{1, 1, 3} 和 {1, 2, 2} 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 的和不超过&nbsp;<code>2 * 10<sup>4</sup></code> 。</li>\n\t<li><code>0 &lt;= l &lt;= r &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2903.找出满足差值条件的下标 I",
        "hardRate": "EASY",
        "passRate": "72.96%",
        "problemsUrl": "https://leetcode.cn/problems/find-indices-with-index-and-value-difference-i/",
        "solutionsUrl": "https://leetcode.cn/problems/find-indices-with-index-and-value-difference-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，以及整数 <code>indexDifference</code> 和整数 <code>valueDifference</code> 。</p>\n\n<p>你的任务是从范围 <code>[0, n - 1]</code> 内找出&nbsp; <strong>2</strong> 个满足下述所有条件的下标 <code>i</code> 和 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>abs(i - j) &gt;= indexDifference</code> 且</li>\n\t<li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li>\n</ul>\n\n<p>返回整数数组 <code>answer</code>。如果存在满足题目要求的两个下标，则 <code>answer = [i, j]</code> ；否则，<code>answer = [-1, -1]</code> 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p>\n\n<p><strong>注意：</strong><code>i</code> 和 <code>j</code> 可能 <strong>相等</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,4,1], indexDifference = 2, valueDifference = 4\n<strong>输出：</strong>[0,3]\n<strong>解释：</strong>在示例中，可以选择 i = 0 和 j = 3 。\nabs(0 - 3) &gt;= 2 且 abs(nums[0] - nums[3]) &gt;= 4 。\n因此，[0,3] 是一个符合题目要求的答案。\n[3,0] 也是符合题目要求的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1], indexDifference = 0, valueDifference = 0\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>\n在示例中，可以选择 i = 0 和 j = 0 。 \nabs(0 - 0) &gt;= 0 且 abs(nums[0] - nums[0]) &gt;= 0 。 \n因此，[0,0] 是一个符合题目要求的答案。 \n[0,1]、[1,0] 和 [1,1] 也是符合题目要求的答案。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], indexDifference = 2, valueDifference = 4\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>在示例中，可以证明无法找出 2 个满足所有条件的下标。\n因此，返回 [-1,-1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= indexDifference &lt;= 100</code></li>\n\t<li><code>0 &lt;= valueDifference &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2904.最短且字典序最小的美丽子字符串",
        "hardRate": "MEDIUM",
        "passRate": "44.02%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>如果 <code>s</code> 的某个子字符串中 <code>1</code> 的个数恰好等于 <code>k</code> ，则称这个子字符串是一个 <strong>美丽子字符串</strong> 。</p>\n\n<p>令 <code>len</code> 等于 <strong>最短</strong> 美丽子字符串的长度。</p>\n\n<p>返回长度等于 <code>len</code> 且字典序 <strong>最小</strong> 的美丽子字符串。如果 <code>s</code> 中不含美丽子字符串，则返回一个 <strong>空</strong> 字符串。</p>\n\n<p>对于相同长度的两个字符串 <code>a</code> 和 <code>b</code> ，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，<code>a</code> 中该位置上的字符严格大于 <code>b</code> 中的对应字符，则认为字符串 <code>a</code> 字典序 <strong>大于</strong> 字符串 <code>b</code> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abcd\"</code> 的字典序大于 <code>\"abcc\"</code> ，因为两个字符串出现不同的第一个位置对应第四个字符，而 <code>d</code> 大于 <code>c</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"100011001\", k = 3\n<strong>输出：</strong>\"11001\"\n<strong>解释：</strong>示例中共有 7 个美丽子字符串：\n1. 子字符串 \"<u>100011</u>001\" 。\n2. 子字符串 \"<u>1000110</u>01\" 。\n3. 子字符串 \"<u>10001100</u>1\" 。\n4. 子字符串 \"1<u>00011001</u>\" 。\n5. 子字符串 \"10<u>0011001</u>\" 。\n6. 子字符串 \"100<u>011001</u>\" 。\n7. 子字符串 \"1000<u>11001</u>\" 。\n最短美丽子字符串的长度是 5 。\n长度为 5 且字典序最小的美丽子字符串是子字符串 \"11001\" 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1011\", k = 2\n<strong>输出：</strong>\"11\"\n<strong>解释：</strong>示例中共有 3 个美丽子字符串：\n1. 子字符串 \"<u>101</u>1\" 。\n2. 子字符串 \"1<u>011</u>\" 。\n3. 子字符串 \"10<u>11</u>\" 。\n最短美丽子字符串的长度是 2 。\n长度为 2 且字典序最小的美丽子字符串是子字符串 \"11\" 。 \n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"000\", k = 1\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>示例中不存在美丽子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2905.找出满足差值条件的下标 II",
        "hardRate": "MEDIUM",
        "passRate": "41.31%",
        "problemsUrl": "https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，以及整数 <code>indexDifference</code> 和整数 <code>valueDifference</code> 。</p>\n\n<p>你的任务是从范围 <code>[0, n - 1]</code> 内找出&nbsp; <strong>2</strong> 个满足下述所有条件的下标 <code>i</code> 和 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>abs(i - j) &gt;= indexDifference</code> 且</li>\n\t<li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li>\n</ul>\n\n<p>返回整数数组 <code>answer</code>。如果存在满足题目要求的两个下标，则 <code>answer = [i, j]</code> ；否则，<code>answer = [-1, -1]</code> 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p>\n\n<p><strong>注意：</strong><code>i</code> 和 <code>j</code> 可能 <strong>相等</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,4,1], indexDifference = 2, valueDifference = 4\n<strong>输出：</strong>[0,3]\n<strong>解释：</strong>在示例中，可以选择 i = 0 和 j = 3 。\nabs(0 - 3) &gt;= 2 且 abs(nums[0] - nums[3]) &gt;= 4 。\n因此，[0,3] 是一个符合题目要求的答案。\n[3,0] 也是符合题目要求的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1], indexDifference = 0, valueDifference = 0\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>\n在示例中，可以选择 i = 0 和 j = 0 。 \nabs(0 - 0) &gt;= 0 且 abs(nums[0] - nums[0]) &gt;= 0 。 \n因此，[0,0] 是一个符合题目要求的答案。 \n[0,1]、[1,0] 和 [1,1] 也是符合题目要求的答案。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], indexDifference = 2, valueDifference = 4\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>在示例中，可以证明无法找出 2 个满足所有条件的下标。\n因此，返回 [-1,-1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= indexDifference &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= valueDifference &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2906.构造乘积矩阵",
        "hardRate": "MEDIUM",
        "passRate": "36.36%",
        "problemsUrl": "https://leetcode.cn/problems/construct-product-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-product-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n * m</code> 的二维整数矩阵 <code><font face=\"monospace\">grid</font></code><font face=\"monospace\"> ，定义一个下标从 <strong>0</strong> 开始、大小为 <code>n * m</code> 的的二维矩阵</font> <code>p</code>。如果满足以下条件，则称 <code>p</code> 为 <code>grid</code> 的 <strong>乘积矩阵</strong> ：</p>\n\n<ul>\n\t<li>对于每个元素 <code>p[i][j]</code> ，它的值等于除了 <code>grid[i][j]</code> 外所有元素的乘积。乘积对 <code>12345</code> 取余数。</li>\n</ul>\n\n<p>返回 <code>grid</code> 的乘积矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2],[3,4]]\n<strong>输出：</strong>[[24,12],[8,6]]\n<strong>解释：</strong>p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24\np[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12\np[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8\np[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6\n所以答案是 [[24,12],[8,6]] 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[12345],[2],[1]]\n<strong>输出：</strong>[[2],[0],[0]]\n<strong>解释：</strong>p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2\np[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0 ，所以 p[0][1] = 0\np[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0 ，所以 p[0][2] = 0\n所以答案是 [[2],[0],[0]] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == grid.length&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m == grid[i].length&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= n * m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2907.价格递增的最大利润三元组 I",
        "hardRate": "MEDIUM",
        "passRate": "61.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profitable-triplets-with-increasing-prices-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profitable-triplets-with-increasing-prices-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2908.元素和最小的山形三元组 I",
        "hardRate": "EASY",
        "passRate": "73.71%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>\n\n<p>如果下标三元组 <code>(i, j, k)</code> 满足下述全部条件，则认为它是一个 <strong>山形三元组</strong> ：</p>\n\n<ul>\n\t<li><code>i &lt; j &lt; k</code></li>\n\t<li><code>nums[i] &lt; nums[j]</code> 且 <code>nums[k] &lt; nums[j]</code></li>\n</ul>\n\n<p>请你找出 <code>nums</code> 中 <strong>元素和最小</strong> 的山形三元组，并返回其 <strong>元素和</strong> 。如果不存在满足条件的三元组，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [8,6,1,5,3]\n<strong>输出：</strong>9\n<strong>解释：</strong>三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为： \n- 2 &lt; 3 &lt; 4\n- nums[2] &lt; nums[3] 且 nums[4] &lt; nums[3]\n这个三元组的元素和等于 nums[2] + nums[3] + nums[4] = 9 。可以证明不存在元素和小于 9 的山形三元组。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,4,8,7,10,2]\n<strong>输出：</strong>13\n<strong>解释：</strong>三元组 (1, 3, 5) 是一个元素和等于 13 的山形三元组，因为： \n- 1 &lt; 3 &lt; 5 \n- nums[1] &lt; nums[3] 且 nums[5] &lt; nums[3]\n这个三元组的元素和等于 nums[1] + nums[3] + nums[5] = 13 。可以证明不存在元素和小于 13 的山形三元组。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,5,4,3,4,5]\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明 nums 中不存在山形三元组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2909.元素和最小的山形三元组 II",
        "hardRate": "MEDIUM",
        "passRate": "55.41%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>\n\n<p>如果下标三元组 <code>(i, j, k)</code> 满足下述全部条件，则认为它是一个 <strong>山形三元组</strong> ：</p>\n\n<ul>\n\t<li><code>i &lt; j &lt; k</code></li>\n\t<li><code>nums[i] &lt; nums[j]</code> 且 <code>nums[k] &lt; nums[j]</code></li>\n</ul>\n\n<p>请你找出 <code>nums</code> 中 <strong>元素和最小</strong> 的山形三元组，并返回其 <strong>元素和</strong> 。如果不存在满足条件的三元组，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [8,6,1,5,3]\n<strong>输出：</strong>9\n<strong>解释：</strong>三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为： \n- 2 &lt; 3 &lt; 4\n- nums[2] &lt; nums[3] 且 nums[4] &lt; nums[3]\n这个三元组的元素和等于 nums[2] + nums[3] + nums[4] = 9 。可以证明不存在元素和小于 9 的山形三元组。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,4,8,7,10,2]\n<strong>输出：</strong>13\n<strong>解释：</strong>三元组 (1, 3, 5) 是一个元素和等于 13 的山形三元组，因为： \n- 1 &lt; 3 &lt; 5 \n- nums[1] &lt; nums[3] 且 nums[5] &lt; nums[3]\n这个三元组的元素和等于 nums[1] + nums[3] + nums[5] = 13 。可以证明不存在元素和小于 13 的山形三元组。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,5,4,3,4,5]\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明 nums 中不存在山形三元组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2910.合法分组的最少组数",
        "hardRate": "MEDIUM",
        "passRate": "30.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/solution",
        "problemsDesc": "<p>给你一组带编号的&nbsp;<code>balls</code> 并要求将它们分类到盒子里，以便均衡地分配。你必须遵守两条规则：</p>\n\n<ul>\n\t<li>同一个盒子里的球必须具有相同的编号。但是，如果你有多个相同编号的球，你可以把它们放在不同的盒子里。</li>\n\t<li>最大的盒子只能比最小的盒子多一个球。</li>\n</ul>\n\n<p>返回遵循上述规则排列这些球所需要的盒子的最小数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>balls = [3,2,3,2,3]\n<b>输出：</b>2\n<b>解释：</b>一个得到 2 个分组的方案如下，中括号内的数字都是下标：\n我们可以如下排列 balls 到盒子里：\n- [3,3,3]\n- [2,2]\n两个盒子之间的大小差没有超过 1。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>balls = [10,10,10,3,1,1]\n<b>输出：</b>4\n<b>解释：</b>我们可以如下排列 balls 到盒子里：\n- [10]\n- [10,10]\n- [3]\n- [1,1]\n无法得到一个遵循上述规则且小于 4 盒的答案。例如，把所有三个编号为 10 的球都放在一个盒子里，就会打破盒子之间最大尺寸差异的规则。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= balls.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= balls[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2911.得到 K 个半回文串的最少修改次数",
        "hardRate": "HARD",
        "passRate": "47.85%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-k-semi-palindromes/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-k-semi-palindromes/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你将&nbsp;<code>s</code> 分成&nbsp;<code>k</code>&nbsp;个<strong>&nbsp;子字符串</strong>&nbsp;，使得每个 <strong>子字符串</strong>&nbsp;变成&nbsp;<strong>半回文串</strong>&nbsp;需要修改的字符数目最少。</p>\n\n<p>请你返回一个整数，表示需要修改的 <strong>最少</strong>&nbsp;字符数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果一个字符串从左往右和从右往左读是一样的，那么它是一个 <strong>回文串</strong>&nbsp;。</li>\n\t<li>如果长度为 <code>len</code>&nbsp;的字符串存在一个满足&nbsp;<code>1 &lt;= d &lt; len</code>&nbsp;的正整数&nbsp;<code>d</code>&nbsp;，<code>len % d == 0</code>&nbsp;成立且所有对 <code>d</code>&nbsp;做除法余数相同的下标对应的字符连起来得到的字符串都是 <strong>回文串</strong>&nbsp;，那么我们说这个字符串是 <strong>半回文串</strong>&nbsp;。比方说&nbsp;<code>\"aa\"</code>&nbsp;，<code>\"aba\"</code> ，<code>\"adbgad\"</code>&nbsp;和&nbsp;<code>\"abab\"</code>&nbsp;都是 <strong>半回文串</strong>&nbsp;，而&nbsp;<code>\"a\"</code>&nbsp;，<code>\"ab\"</code>&nbsp;和&nbsp;<code>\"abca\"</code>&nbsp;不是。</li>\n\t<li><strong>子字符串</strong>&nbsp;指的是一个字符串中一段连续的字符序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcac\", k = 2\n<b>输出：</b>1\n<b>解释：</b>我们可以将 s 分成子字符串 \"ab\" 和 \"cac\" 。子字符串 \"cac\" 已经是半回文串。如果我们将 \"ab\" 变成 \"aa\" ，它也会变成一个 d = 1 的半回文串。\n该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 1 。</pre>\n\n<p><strong class=\"example\">示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcdef\", k = 2\n<b>输出：</b>2\n<b>解释：</b>我们可以将 s 分成子字符串 \"abc\" 和 \"def\" 。子字符串 \"abc\" 和 \"def\" 都需要修改一个字符得到半回文串，所以我们总共需要 2 次字符修改使所有子字符串变成半回文串。\n该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 2 。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabbaa\", k = 3\n<b>输出：</b>0\n<b>解释：</b>我们可以将 s 分成子字符串 \"aa\" ，\"bb\" 和 \"aa\" 。\n字符串 \"aa\" 和 \"bb\" 都已经是半回文串了。所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= k &lt;= s.length / 2</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2912.在网格上移动到目的地的方法数",
        "hardRate": "HARD",
        "passRate": "63.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-destination-in-the-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-destination-in-the-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2913.子数组不同元素数目的平方和 I",
        "hardRate": "EASY",
        "passRate": "80.48%",
        "problemsUrl": "https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-i/",
        "solutionsUrl": "https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>定义 <code>nums</code>&nbsp;一个子数组的 <strong>不同计数</strong>&nbsp;值如下：</p>\n\n<ul>\n\t<li>令&nbsp;<code>nums[i..j]</code>&nbsp;表示 <code>nums</code> 中所有下标在 <code>i</code> 到 <code>j</code> 范围内的元素构成的子数组（满足 <code>0 &lt;= i &lt;= j &lt; nums.length</code> ），那么我们称子数组&nbsp;<code>nums[i..j]</code>&nbsp;中不同值的数目为&nbsp;<code>nums[i..j]</code>&nbsp;的不同计数。</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中所有子数组的 <strong>不同计数</strong>&nbsp;的 <strong>平方</strong>&nbsp;和。</p>\n\n<p>由于答案可能会很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>子数组指的是一个数组里面一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1]\n<b>输出：</b>15\n<b>解释：</b>六个子数组分别为：\n[1]: 1 个互不相同的元素。\n[2]: 1 个互不相同的元素。\n[1]: 1 个互不相同的元素。\n[1,2]: 2 个互不相同的元素。\n[2,1]: 2 个互不相同的元素。\n[1,2,1]: 2 个互不相同的元素。\n所有不同计数的平方和为 1<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> + 2<sup>2</sup> + 2<sup>2</sup> + 2<sup>2</sup> = 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2]\n<b>输出：3</b>\n<strong>解释：</strong>三个子数组分别为：\n[2]: 1 个互不相同的元素。\n[2]: 1 个互不相同的元素。\n[2,2]: 1 个互不相同的元素。\n所有不同计数的平方和为 1<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2914.使二进制字符串变美丽的最少修改次数",
        "hardRate": "MEDIUM",
        "passRate": "76.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-changes-to-make-binary-string-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-changes-to-make-binary-string-beautiful/solution",
        "problemsDesc": "<p>给你一个长度为偶数下标从 <strong>0</strong>&nbsp;开始的二进制字符串&nbsp;<code>s</code>&nbsp;。</p>\n\n<p>如果可以将一个字符串分割成一个或者更多满足以下条件的子字符串，那么我们称这个字符串是 <strong>美丽的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>每个子字符串的长度都是 <strong>偶数</strong>&nbsp;。</li>\n\t<li>每个子字符串都 <strong>只</strong>&nbsp;包含 <code>1</code>&nbsp;或 <strong>只</strong>&nbsp;包含 <code>0</code>&nbsp;。</li>\n</ul>\n\n<p>你可以将 <code>s</code>&nbsp;中任一字符改成&nbsp;<code>0</code>&nbsp;或者&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>请你返回让字符串 <code>s</code>&nbsp;美丽的<strong>&nbsp;最少</strong>&nbsp;字符修改次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"1001\"\n<b>输出：</b>2\n<b>解释：</b>我们将 s[1] 改为 1 ，且将 s[3] 改为 0 ，得到字符串 \"1100\" 。\n字符串 \"1100\" 是美丽的，因为我们可以将它分割成 \"11|00\" 。\n将字符串变美丽最少需要 2 次修改。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"10\"\n<b>输出：</b>1\n<b>解释：</b>我们将 s[1] 改为 1 ，得到字符串 \"11\" 。\n字符串 \"11\" 是美丽的，因为它已经是美丽的。\n将字符串变美丽最少需要 1 次修改。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0000\"\n<b>输出：</b>0\n<b>解释：</b>不需要进行任何修改，字符串 \"0000\" 已经是美丽字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;的长度为偶数。</li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2915.和为目标值的最长子序列的长度",
        "hardRate": "MEDIUM",
        "passRate": "51.48%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>返回和为 <code>target</code>&nbsp;的 <code>nums</code>&nbsp;子序列中，子序列&nbsp;<strong>长度的最大值&nbsp;</strong>。如果不存在和为 <code>target</code>&nbsp;的子序列，返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子序列</strong> 指的是从原数组中删除一些或者不删除任何元素后，剩余元素保持原来的顺序构成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5], target = 9\n<b>输出：</b>3\n<b>解释：</b>总共有 3 个子序列的和为 9 ：[4,5] ，[1,3,5] 和 [2,3,4] 。最长的子序列是 [1,3,5] 和 [2,3,4] 。所以答案为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,1,3,2,1,5], target = 7\n<b>输出：</b>4\n<strong>解释：</strong>总共有 5 个子序列的和为 7 ：[4,3] ，[4,1,2] ，[4,2,1] ，[1,1,5] 和 [1,3,2,1] 。最长子序列为 [1,3,2,1] 。所以答案为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,5,4,5], target = 3\n<b>输出：</b>-1\n<b>解释：</b>无法得到和为 3 的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2916.子数组不同元素数目的平方和 II",
        "hardRate": "HARD",
        "passRate": "38.97%",
        "problemsUrl": "https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>定义 <code>nums</code>&nbsp;一个子数组的 <strong>不同计数</strong>&nbsp;值如下：</p>\n\n<ul>\n\t<li>令&nbsp;<code>nums[i..j]</code>&nbsp;表示 <code>nums</code> 中所有下标在 <code>i</code> 到 <code>j</code> 范围内的元素构成的子数组（满足 <code>0 &lt;= i &lt;= j &lt; nums.length</code> ），那么我们称子数组&nbsp;<code>nums[i..j]</code>&nbsp;中不同值的数目为&nbsp;<code>nums[i..j]</code>&nbsp;的不同计数。</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中所有子数组的 <strong>不同计数</strong>&nbsp;的 <strong>平方</strong>&nbsp;和。</p>\n\n<p>由于答案可能会很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>子数组指的是一个数组里面一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1]\n<b>输出：</b>15\n<b>解释：</b>六个子数组分别为：\n[1]: 1 个互不相同的元素。\n[2]: 1 个互不相同的元素。\n[1]: 1 个互不相同的元素。\n[1,2]: 2 个互不相同的元素。\n[2,1]: 2 个互不相同的元素。\n[1,2,1]: 2 个互不相同的元素。\n所有不同计数的平方和为 1<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> + 2<sup>2</sup> + 2<sup>2</sup> + 2<sup>2</sup> = 15 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2]\n<b>输出：3</b>\n<strong>解释：</strong>三个子数组分别为：\n[2]: 1 个互不相同的元素。\n[2]: 1 个互不相同的元素。\n[2,2]: 1 个互不相同的元素。\n所有不同计数的平方和为 1<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2917.找出数组中的 K-or 值",
        "hardRate": "EASY",
        "passRate": "80.23%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-or-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-or-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。让我们通过扩展标准的按位或来介绍 <strong>K-or</strong> 操作。在 K-or 操作中，如果在 <code>nums</code> 中，至少存在 <code>k</code> 个元素的第 <code>i</code> 位值为 1 ，那么 K-or 中的第 <code>i</code> 位的值是 1 。</p>\n\n<p>返回 <code>nums</code> 的 <strong>K-or</strong> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,12,9,8,9,15], k = 4\n<strong>输出：</strong>9\n<strong>解释：</strong>\n用二进制表示 numbers：\n</pre>\n\n<table style=\"text-indent:10px; margin-bottom=20px;\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th><b>Number</b></th>\n\t\t\t<th>Bit 3</th>\n\t\t\t<th>Bit 2</th>\n\t\t\t<th>Bit 1</th>\n\t\t\t<th>Bit 0</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><b>7</b></td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><b>12</b></td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>0</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><b>9</b></td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><b>8</b></td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>0</td>\n\t\t\t<td>0</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><b>9</b></td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><b>15</b></td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td><b>Result = 9</b></td>\n\t\t\t<td>1</td>\n\t\t\t<td>0</td>\n\t\t\t<td>0</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<pre>\n位 0 在 7, 9, 9, 15 中为 1。位 3 在 12, 9, 8, 9, 15 中为 1。 只有位 0 和 3 满足。结果是 (1001)<sub>2</sub> = 9。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,12,1,11,4,5], k = 6\n<strong>输出：</strong>0\n<strong>解释：</strong>没有位在所有 6 个数字中都为 1，如 k = 6 所需要的。所以，答案为 0。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,8,5,9,11,6,8], k = 1\n<strong>输出：</strong>15\n<strong>解释：</strong>因为 k == 1 ，数组的 1-or 等于其中所有元素按位或运算的结果。因此，答案为 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>31</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2918.数组的最小相等和",
        "hardRate": "MEDIUM",
        "passRate": "37.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/solution",
        "problemsDesc": "<p>给你两个由正整数和 <code>0</code> 组成的数组 <code>nums1</code> 和 <code>nums2</code> 。</p>\n\n<p>你必须将两个数组中的<strong> 所有</strong> <code>0</code> 替换为 <strong>严格</strong> 正整数，并且满足两个数组中所有元素的和 <strong>相等</strong> 。</p>\n\n<p>返回 <strong>最小</strong> 相等和 ，如果无法使两数组相等，则返回 <code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,2,0,1,0], nums2 = [6,5,0]\n<strong>输出：</strong>12\n<strong>解释：</strong>可以按下述方式替换数组中的 0 ：\n- 用 2 和 4 替换 nums1 中的两个 0 。得到 nums1 = [3,2,2,1,4] 。\n- 用 1 替换 nums2 中的一个 0 。得到 nums2 = [6,5,1] 。\n两个数组的元素和相等，都等于 12 。可以证明这是可以获得的最小相等和。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,0,2,0], nums2 = [1,4]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法使两个数组的和相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2919.使数组变美的最小增量运算数",
        "hardRate": "MEDIUM",
        "passRate": "42.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和一个整数 <code>k</code> 。</p>\n\n<p>你可以执行下述 <strong>递增</strong> 运算 <strong>任意</strong> 次（可以是 <strong>0</strong> 次）：</p>\n\n<ul>\n\t<li>从范围&nbsp;<code>[0, n - 1]</code> 中选择一个下标 <code>i</code> ，并将 <code>nums[i]</code> 的值加 <code>1</code> 。</li>\n</ul>\n\n<p>如果数组中任何长度 <strong>大于或等于 3</strong> 的子数组，其 <strong>最大</strong> 元素都大于或等于 <code>k</code> ，则认为数组是一个 <strong>美丽数组</strong> 。</p>\n\n<p>以整数形式返回使数组变为 <strong>美丽数组</strong> 需要执行的 <strong>最小</strong> 递增运算数。</p>\n\n<p>子数组是数组中的一个连续 <strong>非空</strong> 元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,0,0,2], k = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>可以执行下述递增运算，使 nums 变为美丽数组：\n选择下标 i = 1 ，并且将 nums[1] 的值加 1 -&gt; [2,4,0,0,2] 。\n选择下标 i = 4 ，并且将 nums[4] 的值加 1 -&gt; [2,4,0,0,3] 。\n选择下标 i = 4 ，并且将 nums[4] 的值加 1 -&gt; [2,4,0,0,4] 。\n长度大于或等于 3 的子数组为 [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4] 。\n在所有子数组中，最大元素都等于 k = 4 ，所以 nums 现在是美丽数组。\n可以证明无法用少于 3 次递增运算使 nums 变为美丽数组。\n因此，答案为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,3,3], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>可以执行下述递增运算，使 nums 变为美丽数组：\n选择下标 i = 2 ，并且将 nums[2] 的值加 1 -&gt; [0,1,4,3] 。\n选择下标 i = 2 ，并且将 nums[2] 的值加 1 -&gt; [0,1,5,3] 。\n长度大于或等于 3 的子数组为 [0,1,5]、[1,5,3]、[0,1,5,3] 。\n在所有子数组中，最大元素都等于 k = 5 ，所以 nums 现在是美丽数组。\n可以证明无法用少于 2 次递增运算使 nums 变为美丽数组。 \n因此，答案为 2 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>在这个示例中，只有一个长度大于或等于 3 的子数组 [1,1,2] 。\n其最大元素 2 已经大于 k = 1 ，所以无需执行任何增量运算。\n因此，答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2920.收集所有金币可获得的最大积分",
        "hardRate": "HARD",
        "passRate": "54.02%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes/solution",
        "problemsDesc": "<p>有一棵由 <code>n</code> 个节点组成的无向树，以&nbsp;<code>0</code>&nbsp; 为根节点，节点编号从 <code>0</code> 到 <code>n - 1</code> 。给你一个长度为 <code>n - 1</code> 的二维 <strong>整数</strong> 数组 <code>edges</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示在树上的节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>coins</code> 和一个整数 <code>k</code> ，其中 <code>coins[i]</code> 表示节点 <code>i</code> 处的金币数量。</p>\n\n<p>从根节点开始，你必须收集所有金币。要想收集节点上的金币，必须先收集该节点的祖先节点上的金币。</p>\n\n<p>节点 <code>i</code> 上的金币可以用下述方法之一进行收集：</p>\n\n<ul>\n\t<li>收集所有金币，得到共计 <code>coins[i] - k</code> 点积分。如果 <code>coins[i] - k</code> 是负数，你将会失去 <code>abs(coins[i] - k)</code> 点积分。</li>\n\t<li>收集所有金币，得到共计 <code>floor(coins[i] / 2)</code> 点积分。如果采用这种方法，节点 <code>i</code> 子树中所有节点 <code>j</code> 的金币数 <code>coins[j]</code> 将会减少至 <code>floor(coins[j] / 2)</code> 。</li>\n</ul>\n\n<p>返回收集 <strong>所有</strong> 树节点的金币之后可以获得的最大积分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/09/18/ex1-copy.png\" style=\"width: 60px; height: 316px; padding: 10px; background: rgb(255, 255, 255); border-radius: 0.5rem;\" />\n<pre>\n<strong>输入：</strong>edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5\n<strong>输出：</strong>11                        \n<strong>解释：</strong>\n使用第一种方法收集节点 0 上的所有金币。总积分 = 10 - 5 = 5 。\n使用第一种方法收集节点 1 上的所有金币。总积分 = 5 + (10 - 5) = 10 。\n使用第二种方法收集节点 2 上的所有金币。所以节点 3 上的金币将会变为 floor(3 / 2) = 1 ，总积分 = 10 + floor(3 / 2) = 11 。\n使用第二种方法收集节点 3 上的所有金币。总积分 =  11 + floor(1 / 2) = 11.\n可以证明收集所有节点上的金币能获得的最大积分是 11 。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<strong class=\"example\"> <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/09/18/ex2.png\" style=\"width: 140px; height: 147px; padding: 10px; background: #fff; border-radius: .5rem;\" /></strong>\n\n<pre>\n<strong>输入：</strong>edges = [[0,1],[0,2]], coins = [8,4,4], k = 0\n<strong>输出：</strong>16\n<strong>解释：</strong>\n使用第一种方法收集所有节点上的金币，因此，总积分 = (8 - 0) + (4 - 0) + (4 - 0) = 16 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == coins.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= coins[i] &lt;= 10<sup>4</sup></font></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= edges[i][0], edges[i][1] &lt; n</font></code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= k &lt;= 10<sup>4</sup></font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2921.价格递增的最大利润三元组 II",
        "hardRate": "HARD",
        "passRate": "44.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profitable-triplets-with-increasing-prices-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profitable-triplets-with-increasing-prices-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2922.市场分析 III",
        "hardRate": "MEDIUM",
        "passRate": "34.67%",
        "problemsUrl": "https://leetcode.cn/problems/market-analysis-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/market-analysis-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2923.找到冠军 I",
        "hardRate": "EASY",
        "passRate": "83.01%",
        "problemsUrl": "https://leetcode.cn/problems/find-champion-i/",
        "solutionsUrl": "https://leetcode.cn/problems/find-champion-i/solution",
        "problemsDesc": "<p>一场比赛中共有 <code>n</code> 支队伍，按从 <code>0</code> 到&nbsp; <code>n - 1</code> 编号。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n * n</code> 的二维布尔矩阵 <code>grid</code> 。对于满足&nbsp;<code>0 &lt;= i, j &lt;= n - 1</code> 且 <code>i != j</code> 的所有 <code>i, j</code> ：如果 <code>grid[i][j] == 1</code>，那么 <code>i</code> 队比 <code>j</code> 队 <strong>强</strong> ；否则，<code>j</code> 队比 <code>i</code> 队 <strong>强</strong> 。</p>\n\n<p>在这场比赛中，如果不存在某支强于 <code>a</code> 队的队伍，则认为 <code>a</code> 队将会是 <strong>冠军</strong> 。</p>\n\n<p>返回这场比赛中将会成为冠军的队伍。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1],[0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>比赛中有两支队伍。\ngrid[0][1] == 1 表示 0 队比 1 队强。所以 0 队是冠军。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,1],[1,0,1],[0,0,0]]\n<strong>输出：</strong>1\n<strong>解释：</strong>比赛中有三支队伍。\ngrid[1][0] == 1 表示 1 队比 0 队强。\ngrid[1][2] == 1 表示 1 队比 2 队强。\n所以 1 队是冠军。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> 的值为 <code>0</code> 或 <code>1</code><meta charset=\"UTF-8\" /></li>\n\t<li>对于所有&nbsp;<code>i</code>，<code> grid[i][i]</code>&nbsp;等于&nbsp;<code>0.</code></li>\n\t<li>对于满足&nbsp;<code>i != j</code> 的所有 <code>i, j</code> ，<code>grid[i][j] != grid[j][i]</code> 均成立</li>\n\t<li>生成的输入满足：如果 <code>a</code> 队比 <code>b</code> 队强，<code>b</code> 队比 <code>c</code> 队强，那么 <code>a</code> 队比 <code>c</code> 队强</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2924.找到冠军 II",
        "hardRate": "MEDIUM",
        "passRate": "67.66%",
        "problemsUrl": "https://leetcode.cn/problems/find-champion-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-champion-ii/solution",
        "problemsDesc": "<p>一场比赛中共有 <code>n</code> 支队伍，按从 <code>0</code> 到&nbsp; <code>n - 1</code> 编号。每支队伍也是 <strong>有向无环图（DAG）</strong> 上的一个节点。</p>\n\n<p>给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始、长度为 <code>m</code> 的二维整数数组 <code>edges</code> 表示这个有向无环图，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示图中存在一条从 <code>u<sub>i</sub></code> 队到 <code>v<sub>i</sub></code> 队的有向边。</p>\n\n<p>从 <code>a</code> 队到 <code>b</code> 队的有向边意味着 <code>a</code> 队比 <code>b</code> 队 <strong>强</strong> ，也就是 <code>b</code> 队比 <code>a</code> 队 <strong>弱</strong> 。</p>\n\n<p>在这场比赛中，如果不存在某支强于 <code>a</code> 队的队伍，则认为 <code>a</code> 队将会是 <strong>冠军</strong> 。</p>\n\n<p>如果这场比赛存在 <strong>唯一</strong> 一个冠军，则返回将会成为冠军的队伍。否则，返回<em> </em><code>-1</code><em> 。</em></p>\n\n<p><strong>注意</strong></p>\n\n<ul>\n\t<li><strong>环</strong> 是形如 <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, a<sub>n+1</sub></code> 的一个序列，且满足：节点 <code>a<sub>1</sub></code> 与节点 <code>a<sub>n+1</sub></code> 是同一个节点；节点 <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code> 互不相同；对于范围&nbsp;<code>[1, n]</code> 中的每个 <code>i</code> ，均存在一条从节点 <code>a<sub>i</sub></code> 到节点 <code>a<sub>i+1</sub></code> 的有向边。</li>\n\t<li><strong>有向无环图</strong> 是不存在任何环的有向图。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img height=\"300\" src=\"https://assets.leetcode.com/uploads/2023/10/19/graph-3.png\" width=\"300\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, edges = [[0,1],[1,2]]\n<strong>输出：</strong>0\n<strong>解释：</strong>1 队比 0 队弱。2 队比 1 队弱。所以冠军是 0 队。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><img height=\"300\" src=\"https://assets.leetcode.com/uploads/2023/10/19/graph-4.png\" width=\"300\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, edges = [[0,2],[1,3],[1,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>2 队比 0 队和 1 队弱。3 队比 1 队弱。但是 1 队和 0 队之间不存在强弱对比。所以答案是 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>m == edges.length</code></li>\n\t<li><code>0 &lt;= m &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= edge[i][j] &lt;= n - 1</code></li>\n\t<li><code>edges[i][0] != edges[i][1]</code></li>\n\t<li>生成的输入满足：如果 <code>a</code> 队比 <code>b</code> 队强，就不存在 <code>b</code> 队比 <code>a</code> 队强</li>\n\t<li>生成的输入满足：如果 <code>a</code> 队比 <code>b</code> 队强，<code>b</code> 队比 <code>c</code> 队强，那么 <code>a</code> 队比 <code>c</code> 队强</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2925.在树上执行操作以后得到的最大分数",
        "hardRate": "MEDIUM",
        "passRate": "48.31%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/solution",
        "problemsDesc": "<p>有一棵 <code>n</code>&nbsp;个节点的无向树，节点编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;，根节点编号为 <code>0</code>&nbsp;。给你一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;表示这棵树，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code>&nbsp;和&nbsp;<code>b<sub>i</sub></code>&nbsp;有一条边。</p>\n\n<p>同时给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>values</code>&nbsp;，其中&nbsp;<code>values[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个节点的值。</p>\n\n<p>一开始你的分数为 <code>0</code>&nbsp;，每次操作中，你将执行：</p>\n\n<ul>\n\t<li>选择节点&nbsp;<code>i</code>&nbsp;。</li>\n\t<li>将&nbsp;<code>values[i]</code>&nbsp;加入你的分数。</li>\n\t<li>将&nbsp;<code>values[i]</code>&nbsp;变为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>如果从根节点出发，到任意叶子节点经过的路径上的节点值之和都不等于 0 ，那么我们称这棵树是 <strong>健康的</strong>&nbsp;。</p>\n\n<p>你可以对这棵树执行任意次操作，但要求执行完所有操作以后树是&nbsp;<strong>健康的</strong>&nbsp;，请你返回你可以获得的 <strong>最大分数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/10/11/graph-13-1.png\" style=\"width: 515px; height: 443px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[0,2],[0,3],[2,4],[4,5]], values = [5,2,5,2,1,1]\n<b>输出：</b>11\n<b>解释：</b>我们可以选择节点 1 ，2 ，3 ，4 和 5 。根节点的值是非 0 的。所以从根出发到任意叶子节点路径上节点值之和都不为 0 。所以树是健康的。你的得分之和为 values[1] + values[2] + values[3] + values[4] + values[5] = 11 。\n11 是你对树执行任意次操作以后可以获得的最大得分之和。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/10/11/graph-14-2.png\" style=\"width: 522px; height: 245px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]], values = [20,10,9,7,4,3,5]\n<b>输出：</b>40\n<b>解释：</b>我们选择节点 0 ，2 ，3 和 4 。\n- 从 0 到 4 的节点值之和为 10 。\n- 从 0 到 3 的节点值之和为 10 。\n- 从 0 到 5 的节点值之和为 3 。\n- 从 0 到 6 的节点值之和为 5 。\n所以树是健康的。你的得分之和为 values[0] + values[2] + values[3] + values[4] = 40 。\n40 是你对树执行任意次操作以后可以获得的最大得分之和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>values.length == n</code></li>\n\t<li><code>1 &lt;= values[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>输入保证&nbsp;<code>edges</code>&nbsp;构成一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2926.平衡子序列的最大和",
        "hardRate": "HARD",
        "passRate": "39.72%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-balanced-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-balanced-subsequence-sum/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p><code>nums</code>&nbsp;一个长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;指的是选出 <code>k</code>&nbsp;个 <strong>下标</strong>&nbsp;<code>i<sub>0</sub>&nbsp;&lt;&nbsp;i<sub>1</sub> &lt;&nbsp;... &lt; i<sub>k-1</sub></code>&nbsp;，如果这个子序列满足以下条件，我们说它是 <strong>平衡的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>对于范围&nbsp;<code>[1, k - 1]</code>&nbsp;内的所有&nbsp;<code>j</code>&nbsp;，<code>nums[i<sub>j</sub>] - nums[i<sub>j-1</sub>] &gt;= i<sub>j</sub> - i<sub>j-1</sub></code>&nbsp;都成立。</li>\n</ul>\n\n<p><code>nums</code>&nbsp;长度为 <code>1</code>&nbsp;的 <strong>子序列</strong>&nbsp;是平衡的。</p>\n\n<p>请你返回一个整数，表示 <code>nums</code>&nbsp;<strong>平衡</strong>&nbsp;子序列里面的 <strong>最大元素和</strong>&nbsp;。</p>\n\n<p>一个数组的 <strong>子序列</strong>&nbsp;指的是从原数组中删除一些元素（<strong>也可能一个元素也不删除</strong>）后，剩余元素保持相对顺序得到的 <strong>非空</strong>&nbsp;新数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,3,5,6]\n<b>输出：</b>14\n<b>解释：</b>这个例子中，选择子序列 [3,5,6] ，下标为 0 ，2 和 3 的元素被选中。\nnums[2] - nums[0] &gt;= 2 - 0 。\nnums[3] - nums[2] &gt;= 3 - 2 。\n所以，这是一个平衡子序列，且它的和是所有平衡子序列里最大的。\n包含下标 1 ，2 和 3 的子序列也是一个平衡的子序列。\n最大平衡子序列和为 14 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,-1,-3,8]\n<b>输出：</b>13\n<b>解释：</b>这个例子中，选择子序列 [5,8] ，下标为 0 和 3 的元素被选中。\nnums[3] - nums[0] &gt;= 3 - 0 。\n所以，这是一个平衡子序列，且它的和是所有平衡子序列里最大的。\n最大平衡子序列和为 13 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-2,-1]\n<b>输出：</b>-1\n<b>解释：</b>这个例子中，选择子序列 [-1] 。\n这是一个平衡子序列，而且它的和是 nums 所有平衡子序列里最大的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2927.给小朋友们分糖果 III",
        "hardRate": "HARD",
        "passRate": "55.82%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-candies-among-children-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-candies-among-children-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2928.给小朋友们分糖果 I",
        "hardRate": "EASY",
        "passRate": "82.33%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-candies-among-children-i/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-candies-among-children-i/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>n</code> 和&nbsp;<code>limit</code>&nbsp;。</p>\n\n<p>请你将 <code>n</code>&nbsp;颗糖果分给 <code>3</code>&nbsp;位小朋友，确保没有任何小朋友得到超过 <code>limit</code>&nbsp;颗糖果，请你返回满足此条件下的&nbsp;<strong>总方案数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, limit = 2\n<b>输出：</b>3\n<b>解释：</b>总共有 3 种方法分配 5 颗糖果，且每位小朋友的糖果数不超过 2 ：(1, 2, 2) ，(2, 1, 2) 和 (2, 2, 1) 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, limit = 3\n<b>输出：</b>10\n<b>解释：</b>总共有 10 种方法分配 3 颗糖果，且每位小朋友的糖果数不超过 3 ：(0, 0, 3) ，(0, 1, 2) ，(0, 2, 1) ，(0, 3, 0) ，(1, 0, 2) ，(1, 1, 1) ，(1, 2, 0) ，(2, 0, 1) ，(2, 1, 0) 和 (3, 0, 0) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= limit &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2929.给小朋友们分糖果 II",
        "hardRate": "MEDIUM",
        "passRate": "41.80%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-candies-among-children-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-candies-among-children-ii/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>n</code> 和&nbsp;<code>limit</code>&nbsp;。</p>\n\n<p>请你将 <code>n</code>&nbsp;颗糖果分给 <code>3</code>&nbsp;位小朋友，确保没有任何小朋友得到超过 <code>limit</code>&nbsp;颗糖果，请你返回满足此条件下的&nbsp;<strong>总方案数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, limit = 2\n<b>输出：</b>3\n<b>解释：</b>总共有 3 种方法分配 5 颗糖果，且每位小朋友的糖果数不超过 2 ：(1, 2, 2) ，(2, 1, 2) 和 (2, 2, 1) 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, limit = 3\n<b>输出：</b>10\n<b>解释：</b>总共有 10 种方法分配 3 颗糖果，且每位小朋友的糖果数不超过 3 ：(0, 0, 3) ，(0, 1, 2) ，(0, 2, 1) ，(0, 3, 0) ，(1, 0, 2) ，(1, 1, 1) ，(1, 2, 0) ，(2, 0, 1) ，(2, 1, 0) 和 (3, 0, 0) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= limit &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2930.重新排列后包含指定子字符串的字符串数目",
        "hardRate": "MEDIUM",
        "passRate": "62.99%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>如果一个字符串&nbsp;<code>s</code>&nbsp;只包含小写英文字母，<strong>且</strong>&nbsp;将 <code>s</code>&nbsp;的字符重新排列后，新字符串包含&nbsp;<strong>子字符串</strong>&nbsp;<code>\"leet\"</code> ，那么我们称字符串 <code>s</code>&nbsp;是一个 <strong>好</strong>&nbsp;字符串。</p>\n\n<p>比方说：</p>\n\n<ul>\n\t<li>字符串&nbsp;<code>\"lteer\"</code>&nbsp;是好字符串，因为重新排列后可以得到&nbsp;<code>\"leetr\"</code>&nbsp;。</li>\n\t<li><code>\"letl\"</code>&nbsp;不是好字符串，因为无法重新排列并得到子字符串&nbsp;<code>\"leet\"</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回长度为 <code>n</code>&nbsp;的好字符串 <strong>总</strong>&nbsp;数目。</p>\n\n<p>由于答案可能很大，将答案对<strong>&nbsp;</strong><code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p><strong>子字符串</strong>&nbsp;是一个字符串中一段连续的字符序列。</p>\n\n<div class=\"notranslate\" style=\"all: initial;\">&nbsp;</div>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>12\n<b>解释：</b>总共有 12 个字符串重新排列后包含子字符串 \"leet\" ：\"eelt\" ，\"eetl\" ，\"elet\" ，\"elte\" ，\"etel\" ，\"etle\" ，\"leet\" ，\"lete\" ，\"ltee\" ，\"teel\" ，\"tele\" 和 \"tlee\" 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 10\n<b>输出：</b>83943898\n<b>解释：</b>长度为 10 的字符串重新排列后包含子字符串 \"leet\" 的方案数为 526083947580 。所以答案为 526083947580 % (10<sup>9</sup> + 7) = 83943898 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2931.购买物品的最大开销",
        "hardRate": "HARD",
        "passRate": "71.83%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-spending-after-buying-items/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-spending-after-buying-items/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为&nbsp;<code>m * n</code>&nbsp;的整数矩阵&nbsp;<code>values</code>&nbsp;，表示&nbsp;<code>m</code>&nbsp;个不同商店里&nbsp;<code>m * n</code>&nbsp;件不同的物品。每个商店有 <code>n</code>&nbsp;件物品，第&nbsp;<code>i</code>&nbsp;个商店的第 <code>j</code>&nbsp;件物品的价值为&nbsp;<code>values[i][j]</code>&nbsp;。除此以外，第&nbsp;<code>i</code>&nbsp;个商店的物品已经按照价值非递增排好序了，也就是说对于所有&nbsp;<code>0 &lt;= j &lt; n - 1</code>&nbsp;都有&nbsp;<code>values[i][j] &gt;= values[i][j + 1]</code>&nbsp;。</p>\n\n<p>每一天，你可以在一个商店里购买一件物品。具体来说，在第&nbsp;<code>d</code>&nbsp;天，你可以：</p>\n\n<ul>\n\t<li>选择商店&nbsp;<code>i</code>&nbsp;。</li>\n\t<li>购买数组中最右边的物品&nbsp;<code>j</code>&nbsp;，开销为&nbsp;<code>values[i][j] * d</code>&nbsp;。换句话说，选择该商店中还没购买过的物品中最大的下标&nbsp;<code>j</code>&nbsp;，并且花费&nbsp;<code>values[i][j] * d</code>&nbsp;去购买。</li>\n</ul>\n\n<p><strong>注意</strong>，所有物品都视为不同的物品。比方说如果你已经从商店 <code>1</code>&nbsp;购买了物品&nbsp;<code>0</code>&nbsp;，你还可以在别的商店里购买其他商店的物品&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回购买所有 <code>m * n</code>&nbsp;件物品需要的 <strong>最大开销</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>values = [[8,5,2],[6,4,1],[9,7,3]]\n<b>输出：</b>285\n<b>解释：</b>第一天，从商店 1 购买物品 2 ，开销为 values[1][2] * 1 = 1 。\n第二天，从商店 0 购买物品 2 ，开销为 values[0][2] * 2 = 4 。\n第三天，从商店 2 购买物品 2 ，开销为 values[2][2] * 3 = 9 。\n第四天，从商店 1 购买物品 1 ，开销为 values[1][1] * 4 = 16 。\n第五天，从商店 0 购买物品 1 ，开销为 values[0][1] * 5 = 25 。\n第六天，从商店 1 购买物品 0 ，开销为 values[1][0] * 6 = 36 。\n第七天，从商店 2 购买物品 1 ，开销为 values[2][1] * 7 = 49 。\n第八天，从商店 0 购买物品 0 ，开销为 values[0][0] * 8 = 64 。\n第九天，从商店 2 购买物品 0 ，开销为 values[2][0] * 9 = 81 。\n所以总开销为 285 。\n285 是购买所有 m * n 件物品的最大总开销。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>values = [[10,8,6,4,2],[9,7,5,3,2]]\n<b>输出：</b>386\n<b>解释：</b>第一天，从商店 0 购买物品 4 ，开销为 values[0][4] * 1 = 2 。\n第二天，从商店 1 购买物品 4 ，开销为 values[1][4] * 2 = 4 。\n第三天，从商店 1 购买物品 3 ，开销为 values[1][3] * 3 = 9 。\n第四天，从商店 0 购买物品 3 ，开销为 values[0][3] * 4 = 16 。\n第五天，从商店 1 购买物品 2 ，开销为 values[1][2] * 5 = 25 。\n第六天，从商店 0 购买物品 2 ，开销为 values[0][2] * 6 = 36 。\n第七天，从商店 1 购买物品 1 ，开销为 values[1][1] * 7 = 49 。\n第八天，从商店 0 购买物品 1 ，开销为 values[0][1] * 8 = 64 。\n第九天，从商店 1 购买物品 0 ，开销为 values[1][0] * 9 = 81 。\n第十天，从商店 0 购买物品 0 ，开销为 values[0][0] * 10 = 100 。\n所以总开销为 386 。\n386 是购买所有 m * n 件物品的最大总开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m == values.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= n == values[i].length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= values[i][j] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>values[i]</code>&nbsp;按照非递增顺序排序。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2932.找出强数对的最大异或值 I",
        "hardRate": "EASY",
        "passRate": "75.75%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-strong-pair-xor-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-strong-pair-xor-i/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果一对整数 <code>x</code> 和 <code>y</code> 满足以下条件，则称其为 <strong>强数对</strong> ：</p>\n\n<ul>\n\t<li><code>|x - y| &lt;= min(x, y)</code></li>\n</ul>\n\n<p>你需要从 <code>nums</code> 中选出两个整数，且满足：这两个整数可以形成一个强数对，并且它们的按位异或（<code>XOR</code>）值是在该数组所有强数对中的<strong> 最大值 </strong>。</p>\n\n<p>返回数组 <code>nums</code> 所有可能的强数对中的<strong> 最大 </strong>异或值。</p>\n\n<p><strong>注意</strong>，你可以选择同一个整数两次来形成一个强数对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>数组<code> nums </code>中有 11 个强数对：(1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) 和 (5, 5) 。\n这些强数对中的最大异或值是 3 XOR 4 = 7 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,100]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组<code> nums </code>中有 2 个强数对：(10, 10) 和 (100, 100) 。\n这些强数对中的最大异或值是 10 XOR 10 = 0 ，数对 (100, 100) 的异或值也是 100 XOR 100 = 0 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,6,25,30]\n<strong>输出：</strong>7\n<strong>解释：</strong>数组<code> nums </code>中有 6 个强数对：(5, 5), (5, 6), (6, 6), (25, 25), (25, 30) 和 (30, 30) 。\n这些强数对中的最大异或值是 25 XOR 30 = 7 ；另一个异或值非零的数对是 (5, 6) ，其异或值是 5 XOR 6 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2933.高访问员工",
        "hardRate": "MEDIUM",
        "passRate": "51.30%",
        "problemsUrl": "https://leetcode.cn/problems/high-access-employees/",
        "solutionsUrl": "https://leetcode.cn/problems/high-access-employees/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的二维字符串数组 <code>access_times</code> 。对于每个 <code>i</code>（<code>0 &lt;= i &lt;= n - 1</code> ），<code>access_times[i][0]</code> 表示某位员工的姓名，<code>access_times[i][1]</code> 表示该员工的访问时间。<code>access_times</code> 中的所有条目都发生在同一天内。</p>\n\n<p>访问时间用 <strong>四位</strong> 数字表示， 符合 <strong>24 小时制</strong> ，例如 <code>\"0800\"</code> 或 <code>\"2250\"</code> 。</p>\n\n<p>如果员工在 <strong>同一小时内</strong> 访问系统 <strong>三次或更多</strong> ，则称其为 <strong>高访问</strong> 员工。</p>\n\n<p>时间间隔正好相差一小时的时间 <strong>不</strong> 被视为同一小时内。例如，<code>\"0815\"</code> 和 <code>\"0915\"</code> 不属于同一小时内。</p>\n\n<p>一天开始和结束时的访问时间不被计算为同一小时内。例如，<code>\"0005\"</code> 和 <code>\"2350\"</code> 不属于同一小时内。</p>\n\n<p>以列表形式，按任意顺序，返回所有 <strong>高访问</strong> 员工的姓名。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>access_times = [[\"a\",\"0549\"],[\"b\",\"0457\"],[\"a\",\"0532\"],[\"a\",\"0621\"],[\"b\",\"0540\"]]\n<strong>输出：</strong>[\"a\"]\n<strong>解释：</strong>\"a\" 在时间段 [05:32, 06:31] 内有三条访问记录，时间分别为 05:32 、05:49 和 06:21 。\n但是 \"b\" 的访问记录只有两条。\n因此，答案是 [\"a\"] 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>access_times = [[\"d\",\"0002\"],[\"c\",\"0808\"],[\"c\",\"0829\"],[\"e\",\"0215\"],[\"d\",\"1508\"],[\"d\",\"1444\"],[\"d\",\"1410\"],[\"c\",\"0809\"]]\n<strong>输出：</strong>[\"c\",\"d\"]\n<strong>解释：</strong>\"c\" 在时间段 [08:08, 09:07] 内有三条访问记录，时间分别为 08:08 、08:09 和 08:29 。\n\"d\" 在时间段 [14:10, 15:09] 内有三条访问记录，时间分别为 14:10 、14:44 和 15:08 。\n然而，\"e\" 只有一条访问记录，因此不能包含在答案中，最终答案是 [\"c\",\"d\"] 。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>access_times = [[\"cd\",\"1025\"],[\"ab\",\"1025\"],[\"cd\",\"1046\"],[\"cd\",\"1055\"],[\"ab\",\"1124\"],[\"ab\",\"1120\"]]\n<strong>输出：</strong>[\"ab\",\"cd\"]\n<strong>解释：</strong>\"ab\"在时间段 [10:25, 11:24] 内有三条访问记录，时间分别为 10:25 、11:20 和 11:24 。\n\"cd\" 在时间段 [10:25, 11:24] 内有三条访问记录，时间分别为 10:25 、10:46 和 10:55 。\n因此，答案是 [\"ab\",\"cd\"] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= access_times.length &lt;= 100</code></li>\n\t<li><code>access_times[i].length == 2</code></li>\n\t<li><code>1 &lt;= access_times[i][0].length &lt;= 10</code></li>\n\t<li><code>access_times[i][0]</code> 仅由小写英文字母组成。</li>\n\t<li><code>access_times[i][1].length == 4</code></li>\n\t<li><code>access_times[i][1]</code> 采用24小时制表示时间。</li>\n\t<li><code>access_times[i][1]</code> 仅由数字 <code>'0'</code> 到 <code>'9'</code> 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2934.最大化数组末位元素的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "47.90%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-maximize-last-elements-in-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-maximize-last-elements-in-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，这两个数组的长度都是 <code>n</code> 。</p>\n\n<p>你可以执行一系列<strong> 操作（可能不执行）</strong>。</p>\n\n<p>在每次操作中，你可以选择一个在范围 <code>[0, n - 1]</code> 内的下标 <code>i</code> ，并交换 <code>nums1[i]</code> 和 <code>nums2[i]</code> 的值。</p>\n\n<p>你的任务是找到满足以下条件所需的 <strong>最小</strong> 操作次数：</p>\n\n<ul>\n\t<li><code>nums1[n - 1]</code> 等于 <code>nums1</code> 中所有元素的 <strong>最大值</strong> ，即 <code>nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1])</code> 。</li>\n\t<li><code>nums2[n - 1]</code> 等于 <code>nums2</code> 中所有元素的 <strong>最大值</strong> ，即 <code>nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1])</code> 。</li>\n</ul>\n\n<p>以整数形式，表示并返回满足上述 <strong>全部</strong> 条件所需的 <strong>最小</strong> 操作次数，如果无法同时满足两个条件，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,7]，nums2 = [4,5,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>在这个示例中，可以选择下标 i = 2 执行一次操作。\n交换 nums1[2] 和 nums2[2] 的值，nums1 变为 [1,2,3] ，nums2 变为 [4,5,7] 。\n同时满足两个条件。\n可以证明，需要执行的最小操作次数为 1 。\n因此，答案是 1 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,3,4,5,9]，nums2 = [8,8,4,4,4]\n<strong>输出：</strong>2\n<strong>解释：</strong>在这个示例中，可以执行以下操作：\n首先，选择下标 i = 4 执行操作。\n交换 nums1[4] 和 nums2[4] 的值，nums1 变为 [2,3,4,5,4] ，nums2 变为 [8,8,4,4,9] 。\n然后，选择下标 i = 3 执行操作。\n交换 nums1[3] 和 nums2[3] 的值，nums1 变为 [2,3,4,4,4] ，nums2 变为 [8,8,4,5,9] 。\n同时满足两个条件。 \n可以证明，需要执行的最小操作次数为 2 。 \n因此，答案是 2 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,5,4]，nums2 = [2,5,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>在这个示例中，无法同时满足两个条件。\n因此，答案是 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums1.length == nums2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums1[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2935.找出强数对的最大异或值 II",
        "hardRate": "HARD",
        "passRate": "40.57%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-strong-pair-xor-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-strong-pair-xor-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果一对整数 <code>x</code> 和 <code>y</code> 满足以下条件，则称其为 <strong>强数对</strong> ：</p>\n\n<ul>\n\t<li><code>|x - y| &lt;= min(x, y)</code></li>\n</ul>\n\n<p>你需要从 <code>nums</code> 中选出两个整数，且满足：这两个整数可以形成一个强数对，并且它们的按位异或（<code>XOR</code>）值是在该数组所有强数对中的<strong> 最大值 </strong>。</p>\n\n<p>返回数组 <code>nums</code> 所有可能的强数对中的<strong> 最大 </strong>异或值。</p>\n\n<p><strong>注意</strong>，你可以选择同一个整数两次来形成一个强数对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>数组<code> nums </code>中有 11 个强数对：(1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) 和 (5, 5) 。\n这些强数对中的最大异或值是 3 XOR 4 = 7 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,100]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组<code> nums </code>中有 2 个强数对：(10, 10) 和 (100, 100) 。\n这些强数对中的最大异或值是 10 XOR 10 = 0 ，数对 (100, 100) 的异或值也是 100 XOR 100 = 0 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [500,520,2500,3000]\n<strong>输出：</strong>1020\n<strong>解释：</strong>数组<code> nums </code>中有 6 个强数对：(500, 500), (500, 520), (520, 520), (2500, 2500), (2500, 3000) 和 (3000, 3000) 。\n这些强数对中的最大异或值是 500 XOR 520 = 1020 ；另一个异或值非零的数对是 (5, 6) ，其异或值是 2500 XOR 3000 = 636 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2<sup>20</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2936.包含相等值数字块的数量",
        "hardRate": "MEDIUM",
        "passRate": "59.00%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-equal-numbers-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-equal-numbers-blocks/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2937.使三个字符串相等",
        "hardRate": "EASY",
        "passRate": "47.86%",
        "problemsUrl": "https://leetcode.cn/problems/make-three-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-three-strings-equal/solution",
        "problemsDesc": "<p>给你三个字符串 <code>s1</code>、<code>s2</code> 和 <code>s3</code>。 你可以根据需要对这三个字符串执行以下操作 <strong>任意次数</strong> <!-- notionvc: b5178de7-3318-4129-b7d9-726b47e90621 -->。</p>\n\n<p>在每次操作中，你可以选择其中一个长度至少为 <code>2</code> 的字符串 <!-- notionvc: 3342ac46-33c8-4010-aacd-e58678ce31ef --> 并删除其 <strong>最右位置上</strong> 的字符。</p>\n\n<p>如果存在某种方法能够使这三个字符串相等，请返回使它们相等所需的 <strong>最小</strong> 操作次数；否则，返回 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"abc\"，s2 = \"abb\"，s3 = \"ab\"\n<strong>输出：</strong>2\n<strong>解释：</strong>对 s1 和 s2 进行一次操作后，可以得到三个相等的字符串。\n可以证明，不可能用少于两次操作使它们相等。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"dac\"，s2 = \"bac\"，s3 = \"cac\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>因为 s1 和 s2 的最左位置上的字母<!-- notionvc: 47239f7c-eec1-49f8-af79-c206ec88cb07 -->不相等，所以无论进行多少次操作，它们都不可能相等。因此答案是 -1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length, s3.length &lt;= 100</code></li>\n\t<li><code>s1</code>、<code>s2</code> 和 <code>s3</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2938.区分黑球与白球",
        "hardRate": "MEDIUM",
        "passRate": "65.13%",
        "problemsUrl": "https://leetcode.cn/problems/separate-black-and-white-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/separate-black-and-white-balls/solution",
        "problemsDesc": "<p>桌子上有 <code>n</code> 个球，每个球的颜色不是黑色，就是白色。</p>\n\n<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code>，其中 <code>1</code> 和 <code>0</code> 分别代表黑色和白色的球。</p>\n\n<p>在每一步中，你可以选择两个相邻的球并交换它们。</p>\n\n<p>返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 <strong>最小步数</strong>」。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"101\"\n<strong>输出：</strong>1\n<strong>解释：</strong>我们可以按以下方式将所有黑色球移到右侧：\n- 交换 s[0] 和 s[1]，s = \"011\"。\n最开始，1 没有都在右侧，需要至少 1 步将其移到右侧。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"100\"\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以按以下方式将所有黑色球移到右侧：\n- 交换 s[0] 和 s[1]，s = \"010\"。\n- 交换 s[1] 和 s[2]，s = \"001\"。\n可以证明所需的最小步数为 2 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0111\"\n<strong>输出：</strong>0\n<strong>解释：</strong>所有黑色球都已经在右侧。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 不是 <code>'0'</code>，就是 <code>'1'</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2939.最大异或乘积",
        "hardRate": "MEDIUM",
        "passRate": "32.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-product/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-product/solution",
        "problemsDesc": "<p>给你三个整数&nbsp;<code>a</code>&nbsp;，<code>b</code>&nbsp;和&nbsp;<code>n</code>&nbsp;，请你返回&nbsp;<code>(a XOR x) * (b XOR x)</code>&nbsp;的&nbsp;<strong>最大值</strong>&nbsp;且 <code>x</code>&nbsp;需要满足 <code>0 &lt;= x &lt; 2<sup>n</sup></code>。</p>\n\n<p>由于答案可能会很大，返回它对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;<strong>取余</strong>&nbsp;后的结果。</p>\n\n<p><strong>注意</strong>，<code>XOR</code>&nbsp;是按位异或操作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>a = 12, b = 5, n = 4\n<b>输出：</b>98\n<b>解释：</b>当 x = 2 时，(a XOR x) = 14 且 (b XOR x) = 7 。所以，(a XOR x) * (b XOR x) = 98 。\n98 是所有满足 0 &lt;= x &lt; 2<sup>n </sup>中 (a XOR x) * (b XOR x) 的最大值。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>a = 6, b = 7 , n = 5\n<b>输出：</b>930\n<b>解释：</b>当 x = 25 时，(a XOR x) = 31 且 (b XOR x) = 30 。所以，(a XOR x) * (b XOR x) = 930 。\n930 是所有满足 0 &lt;= x &lt; 2<sup>n </sup>中 (a XOR x) * (b XOR x) 的最大值。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>a = 1, b = 6, n = 3\n<b>输出：</b>12\n<b>解释： </b>当 x = 5 时，(a XOR x) = 4 且 (b XOR x) = 3 。所以，(a XOR x) * (b XOR x) = 12 。\n12 是所有满足 0 &lt;= x &lt; 2<sup>n </sup>中 (a XOR x) * (b XOR x) 的最大值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b &lt; 2<sup>50</sup></code></li>\n\t<li><code>0 &lt;= n &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2940.找到 Alice 和 Bob 可以相遇的建筑",
        "hardRate": "HARD",
        "passRate": "52.61%",
        "problemsUrl": "https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/",
        "solutionsUrl": "https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的正整数数组&nbsp;<code>heights</code>&nbsp;，其中&nbsp;<code>heights[i]</code>&nbsp;表示第 <code>i</code>&nbsp;栋建筑的高度。</p>\n\n<p>如果一个人在建筑&nbsp;<code>i</code>&nbsp;，且存在&nbsp;<code>i &lt; j</code>&nbsp;的建筑&nbsp;<code>j</code>&nbsp;满足&nbsp;<code>heights[i] &lt; heights[j]</code>&nbsp;，那么这个人可以移动到建筑&nbsp;<code>j</code>&nbsp;。</p>\n\n<p>给你另外一个数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个查询中，Alice 在建筑&nbsp;<code>a<sub>i</sub></code> ，Bob 在建筑&nbsp;<code>b<sub>i</sub></code><sub>&nbsp;</sub>。</p>\n\n<p>请你能返回一个数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询中，Alice 和 Bob 可以相遇的&nbsp;<strong>最左边的建筑</strong>&nbsp;。如果对于查询&nbsp;<code>i</code>&nbsp;，Alice<em> </em>和<em> </em>Bob 不能相遇，令&nbsp;<code>ans[i]</code> 为&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]\n<b>输出：</b>[2,5,-1,5,2]\n<b>解释：</b>第一个查询中，Alice 和 Bob 可以移动到建筑 2 ，因为 heights[0] &lt; heights[2] 且 heights[1] &lt; heights[2] 。\n第二个查询中，Alice 和 Bob 可以移动到建筑 5 ，因为 heights[0] &lt; heights[5] 且 heights[3] &lt; heights[5] 。\n第三个查询中，Alice 无法与 Bob 相遇，因为 Alice 不能移动到任何其他建筑。\n第四个查询中，Alice 和 Bob 可以移动到建筑 5 ，因为 heights[3] &lt; heights[5] 且 heights[4] &lt; heights[5] 。\n第五个查询中，Alice 和 Bob 已经在同一栋建筑中。\n对于 ans[i] != -1 ，ans[i] 是 Alice 和 Bob 可以相遇的建筑中最左边建筑的下标。\n对于 ans[i] == -1 ，不存在 Alice 和 Bob 可以相遇的建筑。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]\n<b>输出：</b>[7,6,-1,4,6]\n<strong>解释：</strong>第一个查询中，Alice 可以直接移动到 Bob 的建筑，因为 heights[0] &lt; heights[7] 。\n第二个查询中，Alice 和 Bob 可以移动到建筑 6 ，因为 heights[3] &lt; heights[6] 且 heights[5] &lt; heights[6] 。\n第三个查询中，Alice 无法与 Bob 相遇，因为 Bob 不能移动到任何其他建筑。\n第四个查询中，Alice 和 Bob 可以移动到建筑 4 ，因为 heights[3] &lt; heights[4] 且 heights[0] &lt; heights[4] 。\n第五个查询中，Alice 可以直接移动到 Bob 的建筑，因为 heights[1] &lt; heights[6] 。\n对于 ans[i] != -1 ，ans[i] 是 Alice 和 Bob 可以相遇的建筑中最左边建筑的下标。\n对于 ans[i] == -1 ，不存在 Alice 和 Bob 可以相遇的建筑。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= heights.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2941.子数组的最大 GCD-Sum",
        "hardRate": "HARD",
        "passRate": "54.47%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-gcd-sum-of-a-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-gcd-sum-of-a-subarray/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2942.查找包含给定字符的单词",
        "hardRate": "EASY",
        "passRate": "87.56%",
        "problemsUrl": "https://leetcode.cn/problems/find-words-containing-character/",
        "solutionsUrl": "https://leetcode.cn/problems/find-words-containing-character/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>words</code>&nbsp;和一个字符&nbsp;<code>x</code>&nbsp;。</p>\n\n<p>请你返回一个 <strong>下标数组</strong>&nbsp;，表示下标在数组中对应的单词包含字符 <code>x</code>&nbsp;。</p>\n\n<p><b>注意</b>&nbsp;，返回的数组可以是&nbsp;<strong>任意</strong>&nbsp;顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"leet\",\"code\"], x = \"e\"\n<b>输出：</b>[0,1]\n<b>解释：</b>\"e\" 在两个单词中都出现了：\"l<em><strong>ee</strong></em>t\" 和 \"cod<em><strong>e</strong></em>\" 。所以我们返回下标 0 和 1 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"a\"\n<b>输出：</b>[0,2]\n<b>解释：</b>\"a\" 在 \"<em><strong>a</strong></em>bc\" 和 \"<em><strong>aaaa</strong></em>\" 中出现了，所以我们返回下标 0 和 2 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abc\",\"bcd\",\"aaaa\",\"cbc\"], x = \"z\"\n<b>输出：</b>[]\n<b>解释：</b>\"z\" 没有在任何单词中出现。所以我们返回空数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 50</code></li>\n\t<li><code>x</code>&nbsp;是一个小写英文字母。</li>\n\t<li><code>words[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2943.最大化网格图中正方形空洞的面积",
        "hardRate": "MEDIUM",
        "passRate": "39.80%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/solution",
        "problemsDesc": "<p>给你一个网格图，由&nbsp;<code>n + 2</code>&nbsp;条 <strong>横线段</strong>&nbsp;和&nbsp;<code>m + 2</code>&nbsp;条&nbsp;<strong>竖线段</strong>&nbsp;组成，一开始所有区域均为&nbsp;<code>1 x 1</code>&nbsp;的单元格。</p>\n\n<p>所有线段的编号从 <strong>1</strong>&nbsp;开始。</p>\n\n<p>给你两个整数&nbsp;<code>n</code> 和&nbsp;<code>m</code>&nbsp;。</p>\n\n<p>同时给你两个整数数组&nbsp;<code>hBars</code> 和&nbsp;<code>vBars</code>&nbsp;。</p>\n\n<ul>\n\t<li><code>hBars</code> 包含区间&nbsp;<code>[2, n + 1]</code>&nbsp;内&nbsp;<strong>互不相同</strong>&nbsp;的横线段编号。</li>\n\t<li><code>vBars</code>&nbsp;包含&nbsp;<code>[2, m + 1]</code>&nbsp;内&nbsp;<strong>互不相同的</strong>&nbsp;竖线段编号。</li>\n</ul>\n\n<p>如果满足以下条件之一，你可以 <strong>移除</strong>&nbsp;两个数组中的部分线段：</p>\n\n<ul>\n\t<li>如果移除的是横线段，它必须是&nbsp;<code>hBars</code>&nbsp;中的值。</li>\n\t<li>如果移除的是竖线段，它必须是&nbsp;<code>vBars</code>&nbsp;中的值。</li>\n</ul>\n\n<p>请你返回移除一些线段后（<strong>可能不移除任何线段）</strong>，剩余网格图中 <strong>最大正方形</strong>&nbsp;空洞的面积，正方形空洞的意思是正方形 <strong>内部</strong> 不含有任何线段。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/05/screenshot-from-2023-11-05-22-40-25.png\" style=\"width: 411px; height: 220px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 2, m = 1, hBars = [2,3], vBars = [2]\n<b>输出：</b>4\n<b>解释：</b>左边的图是一开始的网格图。\n横线编号的范围是区间 [1,4] ，竖线编号的范围是区间 [1,3] 。\n可以移除的横线段为 [2,3] ，竖线段为 [2] 。\n一种得到最大正方形面积的方法是移除横线段 2 和竖线段 2 。\n操作后得到的网格图如右图所示。\n正方形空洞面积为 4。\n无法得到面积大于 4 的正方形空洞。\n所以答案为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/04/screenshot-from-2023-11-04-17-01-02.png\" style=\"width: 368px; height: 145px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 1, m = 1, hBars = [2], vBars = [2]\n<b>输出：</b>4\n<b>解释：</b>左边的图是一开始的网格图。\n横线编号的范围是区间 [1,3] ，竖线编号的范围是区间 [1,3] 。\n可以移除的横线段为 [2] ，竖线段为 [2] 。\n一种得到最大正方形面积的方法是移除横线段 2 和竖线段 2 。\n操作后得到的网格图如右图所示。\n正方形空洞面积为 4。\n无法得到面积大于 4 的正方形空洞。\n所以答案为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/05/screenshot-from-2023-11-05-22-33-35.png\" style=\"width: 648px; height: 218px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 2, m = 3, hBars = [2,3], vBars = [2,3,4]\n<b>输出：</b>9\n<b>解释：</b>左边的图是一开始的网格图。\n横线编号的范围是区间 [1,4] ，竖线编号的范围是区间 [1,5] 。\n可以移除的横线段为 [2,3] ，竖线段为 [2,3,4] 。\n一种得到最大正方形面积的方法是移除横线段 2、3 和竖线段 3、4 。\n操作后得到的网格图如右图所示。\n正方形空洞面积为 9。\n无法得到面积大于 9 的正方形空洞。\n所以答案为 9 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= hBars.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= hBars[i] &lt;= n + 1</code></li>\n\t<li><code>1 &lt;= vBars.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= vBars[i] &lt;= m + 1</code></li>\n\t<li><code>hBars</code>&nbsp;中的值互不相同。</li>\n\t<li><code>vBars</code> 中的值互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2944.购买水果需要的最少金币数",
        "hardRate": "MEDIUM",
        "passRate": "71.32%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0&nbsp;开始的</strong> 整数数组&nbsp;<code>prices</code>&nbsp;，其中&nbsp;<code>prices[i]</code>&nbsp;表示你购买第 <code>i + 1</code>&nbsp;个水果需要花费的金币数目。</p>\n\n<p>水果超市有如下促销活动：</p>\n\n<ul>\n\t<li>如果你花费 <code>prices[i]</code>&nbsp;购买了下标为&nbsp;<code>i + 1</code>&nbsp;的水果，那么你可以免费获得下标范围在&nbsp;<code>[i + 1, i + i]</code>&nbsp;的水果。</li>\n</ul>\n\n<p><strong>注意</strong>&nbsp;，即使你&nbsp;<strong>可以</strong>&nbsp;免费获得水果&nbsp;<code>j</code>&nbsp;，你仍然可以花费&nbsp;<code>prices[j - 1]</code>&nbsp;个金币去购买它以获得它的奖励。</p>\n\n<p>请你返回获得所有水果所需要的 <strong>最少</strong>&nbsp;金币数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">prices = [3,1,2]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">4</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>用&nbsp;<code>prices[0] = 3</code>&nbsp;个金币购买第 1 个水果，你可以免费获得第 2 个水果。</li>\n\t<li>用&nbsp;<code>prices[1] = 1</code>&nbsp;个金币购买第 2 个水果，你可以免费获得第 3 个水果。</li>\n\t<li>免费获得第 3 个水果。</li>\n</ul>\n\n<p>请注意，即使您可以免费获得第 2 个水果作为购买第 1 个水果的奖励，但您购买它是为了获得其奖励，这是更优化的。</p>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">prices = [1,10,1,1]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">2</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>用&nbsp;<code>prices[0] = 1</code> 个金币购买第 1 个水果，你可以免费获得第 2 个水果。</li>\n\t<li>免费获得第 2 个水果。</li>\n\t<li>用&nbsp;<code>prices[2] = 1</code> 个金币购买第 3 个水果，你可以免费获得第 4 个水果。</li>\n\t<li>免费获得第 4 个水果。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><strong>输入：</strong><span class=\"example-io\">prices = [26,18,6,12,49,7,45,45]</span></p>\n\n<p><strong>输出：</strong><span class=\"example-io\">39</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>用&nbsp;<code>prices[0] = 26</code> 个金币购买第 1 个水果，你可以免费获得第 2 个水果。</li>\n\t<li>免费获得第 2 个水果。</li>\n\t<li>用&nbsp;<code>prices[2] = 6</code> 个金币购买第 3 个水果，你可以免费获得第 4，5，6（接下来的三个）水果。</li>\n\t<li>免费获得第 4 个水果。</li>\n\t<li>免费获得第 5&nbsp;个水果。</li>\n\t<li>用&nbsp;<code>prices[5] = 7</code>&nbsp;个金币购买第 6 个水果，你可以免费获得第 7 和 第 8 个水果。</li>\n\t<li>免费获得第 7&nbsp;个水果。</li>\n\t<li>免费获得第 8&nbsp;个水果。</li>\n</ul>\n\n<p>请注意，即使您可以免费获得第 6 个水果作为购买第 3 个水果的奖励，但您购买它是为了获得其奖励，这是更优化的。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2945.找到最大非递减数组的长度",
        "hardRate": "HARD",
        "passRate": "26.16%",
        "problemsUrl": "https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/",
        "solutionsUrl": "https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>你可以执行任意次操作。每次操作中，你需要选择一个 <strong>子数组</strong>&nbsp;，并将这个子数组用它所包含元素的 <strong>和</strong>&nbsp;替换。比方说，给定数组是&nbsp;<code>[1,3,5,6]</code>&nbsp;，你可以选择子数组&nbsp;<code>[3,5]</code>&nbsp;，用子数组的和 <code>8</code>&nbsp;替换掉子数组，然后数组会变为&nbsp;<code>[1,8,6]</code>&nbsp;。</p>\n\n<p>请你返回执行任意次操作以后，可以得到的 <strong>最长非递减</strong>&nbsp;数组的长度。</p>\n\n<p><strong>子数组</strong>&nbsp;指的是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,2,2]\n<b>输出：</b>1\n<strong>解释：</strong>这个长度为 3 的数组不是非递减的。\n我们有 2 种方案使数组长度为 2 。\n第一种，选择子数组 [2,2] ，对数组执行操作后得到 [5,4] 。\n第二种，选择子数组 [5,2] ，对数组执行操作后得到 [7,2] 。\n这两种方案中，数组最后都不是 <strong>非递减</strong>&nbsp;的，所以不是可行的答案。\n如果我们选择子数组 [5,2,2] ，并将它替换为 [9] ，数组变成非递减的。\n所以答案为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>4\n<b>解释：</b>数组已经是非递减的。所以答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,3,2,6]\n<b>输出：</b>3\n<b>解释：</b>将 [3,2] 替换为 [5] ，得到数组 [4,5,6] ，它是非递减的。\n最大可能的答案为 3 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2946.循环移位后的矩阵相似检查",
        "hardRate": "EASY",
        "passRate": "63.28%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-similarity-after-cyclic-shifts/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-similarity-after-cyclic-shifts/solution",
        "problemsDesc": "<p>给你一个<strong>下标从 0 开始</strong>且大小为 <code>m x n</code> 的整数矩阵 <code>mat</code> 和一个整数 <code>k</code> 。请你将矩阵中的<strong> 奇数</strong> 行循环 <strong>右</strong> 移 <code>k</code> 次，<strong>偶数</strong> 行循环 <strong>左</strong> 移 <code>k</code> 次。</p>\n\n<p>如果初始矩阵和最终矩阵完全相同，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/10/29/similarmatrix.png\" style=\"width: 500px; height: 117px;\" />\n\n初始矩阵如图一所示。\n图二表示对奇数行右移一次且对偶数行左移一次后的矩阵状态。\n图三是经过两次循环移位后的最终矩阵状态，与初始矩阵相同。\n因此，返回 true 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[2,2],[2,2]], k = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>由于矩阵中的所有值都相等，即使进行循环移位，矩阵仍然保持不变。因此，返回 true 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2]], k = 1\n<strong>输出：</strong>false\n<strong>解释：</strong>循环移位一次后，mat = [[2,1]]，与初始矩阵不相等。因此，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mat.length &lt;= 25</code></li>\n\t<li><code>1 &lt;= mat[i].length &lt;= 25</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 25</code></li>\n\t<li><code>1 &lt;= k &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2947.统计美丽子字符串 I",
        "hardRate": "MEDIUM",
        "passRate": "59.80%",
        "problemsUrl": "https://leetcode.cn/problems/count-beautiful-substrings-i/",
        "solutionsUrl": "https://leetcode.cn/problems/count-beautiful-substrings-i/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>用 <code>vowels</code> 和 <code>consonants</code> 分别表示字符串中元音字母和辅音字母的数量。</p>\n\n<p>如果某个字符串满足以下条件，则称其为 <strong>美丽字符串</strong> ：</p>\n\n<ul>\n\t<li><code>vowels == consonants</code>，即元音字母和辅音字母的数量相等。</li>\n\t<li><code>(vowels * consonants) % k == 0</code>，即元音字母和辅音字母的数量的乘积能被 <code>k</code> 整除。</li>\n</ul>\n\n<p>返回字符串 <code>s</code> 中 <strong>非空美丽子字符串</strong> 的数量。</p>\n\n<p>子字符串是字符串中的一个连续字符序列。</p>\n\n<p>英语中的<strong> 元音字母 </strong>为 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code> 。</p>\n\n<p>英语中的<strong> 辅音字母 </strong>为除了元音字母之外的所有字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baeyh\", k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>字符串 s 中有 2 个美丽子字符串。\n- 子字符串 \"b<em><strong>aeyh</strong></em>\"，vowels = 2（[\"a\",\"e\"]），consonants = 2（[\"y\",\"h\"]）。\n可以看出字符串 \"aeyh\" 是美丽字符串，因为 vowels == consonants 且 vowels * consonants % k == 0 。\n- 子字符串 \"<em><strong>baey</strong></em>h\"，vowels = 2（[\"a\",\"e\"]），consonants = 2（[\"b\",\"y\"]）。\n可以看出字符串 \"baey\" 是美丽字符串，因为 vowels == consonants 且 vowels * consonants % k == 0 。\n可以证明字符串 s 中只有 2 个美丽子字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abba\", k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>字符串 s 中有 3 个美丽子字符串。\n- 子字符串 \"<strong><em>ab</em></strong>ba\"，vowels = 1（[\"a\"]），consonants = 1（[\"b\"]）。\n- 子字符串 \"ab<strong><em>ba</em></strong>\"，vowels = 1（[\"a\"]），consonants = 1（[\"b\"]）。\n- 子字符串 \"<em><strong>abba</strong></em>\"，vowels = 2（[\"a\",\"a\"]），consonants = 2（[\"b\",\"b\"]）。\n可以证明字符串 s 中只有 3 个美丽子字符串。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bcdf\", k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 s 中没有美丽子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2948.交换得到字典序最小的数组",
        "hardRate": "MEDIUM",
        "passRate": "46.21%",
        "problemsUrl": "https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0 </strong>开始的 <strong>正整数</strong> 数组 <code>nums</code> 和一个 <strong>正整数</strong> <code>limit</code> 。</p>\n\n<p>在一次操作中，你可以选择任意两个下标 <code>i</code> 和 <code>j</code>，<strong>如果</strong> 满足 <code>|nums[i] - nums[j]| &lt;= limit</code> ，则交换 <code>nums[i]</code> 和 <code>nums[j]</code> 。</p>\n\n<p>返回执行任意次操作后能得到的 <strong>字典序最小的数组</strong><em> </em>。</p>\n\n<p>如果在数组 <code>a</code> 和数组 <code>b</code> 第一个不同的位置上，数组 <code>a</code> 中的对应元素比数组 <code>b</code> 中的对应元素的字典序更小，则认为数组 <code>a</code> 就比数组 <code>b</code> 字典序更小。例如，数组 <code>[2,10,3]</code> 比数组 <code>[10,2,3]</code> 字典序更小，下标 <code>0</code> 处是两个数组第一个不同的位置，且 <code>2 &lt; 10</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,3,9,8], limit = 2\n<strong>输出：</strong>[1,3,5,8,9]\n<strong>解释：</strong>执行 2 次操作：\n- 交换 nums[1] 和 nums[2] 。数组变为 [1,3,5,9,8] 。\n- 交换 nums[3] 和 nums[4] 。数组变为 [1,3,5,8,9] 。\n即便执行更多次操作，也无法得到字典序更小的数组。\n注意，执行不同的操作也可能会得到相同的结果。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,7,6,18,2,1], limit = 3\n<strong>输出：</strong>[1,6,7,18,1,2]\n<strong>解释：</strong>执行 3 次操作：\n- 交换 nums[1] 和 nums[2] 。数组变为 [1,6,7,18,2,1] 。\n- 交换 nums[0] 和 nums[4] 。数组变为 [2,6,7,18,1,1] 。\n- 交换 nums[0] 和 nums[5] 。数组变为 [1,6,7,18,1,2] 。\n即便执行更多次操作，也无法得到字典序更小的数组。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,7,28,19,10], limit = 3\n<strong>输出：</strong>[1,7,28,19,10]\n<strong>解释：</strong>[1,7,28,19,10] 是字典序最小的数组，因为不管怎么选择下标都无法执行操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= limit &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2949.统计美丽子字符串 II",
        "hardRate": "HARD",
        "passRate": "34.40%",
        "problemsUrl": "https://leetcode.cn/problems/count-beautiful-substrings-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-beautiful-substrings-ii/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>用 <code>vowels</code> 和 <code>consonants</code> 分别表示字符串中元音字母和辅音字母的数量。</p>\n\n<p>如果某个字符串满足以下条件，则称其为 <strong>美丽字符串</strong> ：</p>\n\n<ul>\n\t<li><code>vowels == consonants</code>，即元音字母和辅音字母的数量相等。</li>\n\t<li><code>(vowels * consonants) % k == 0</code>，即元音字母和辅音字母的数量的乘积能被 <code>k</code> 整除。</li>\n</ul>\n\n<p>返回字符串 <code>s</code> 中 <strong>非空美丽子字符串</strong> 的数量。</p>\n\n<p>子字符串是字符串中的一个连续字符序列。</p>\n\n<p>英语中的<strong> 元音字母 </strong>为 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code> 。</p>\n\n<p>英语中的<strong> 辅音字母 </strong>为除了元音字母之外的所有字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baeyh\", k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>字符串 s 中有 2 个美丽子字符串。\n- 子字符串 \"b<em><strong>aeyh</strong></em>\"，vowels = 2（[\"a\",\"e\"]），consonants = 2（[\"y\",\"h\"]）。\n可以看出字符串 \"aeyh\" 是美丽字符串，因为 vowels == consonants 且 vowels * consonants % k == 0 。\n- 子字符串 \"<em><strong>baey</strong></em>h\"，vowels = 2（[\"a\",\"e\"]），consonants = 2（[\"b\",\"y\"]）。\n可以看出字符串 \"baey\" 是美丽字符串，因为 vowels == consonants 且 vowels * consonants % k == 0 。\n可以证明字符串 s 中只有 2 个美丽子字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abba\", k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>字符串 s 中有 3 个美丽子字符串。\n- 子字符串 \"<strong><em>ab</em></strong>ba\"，vowels = 1（[\"a\"]），consonants = 1（[\"b\"]）。\n- 子字符串 \"ab<strong><em>ba</em></strong>\"，vowels = 1（[\"a\"]），consonants = 1（[\"b\"]）。\n- 子字符串 \"<em><strong>abba</strong></em>\"，vowels = 2（[\"a\",\"a\"]），consonants = 2（[\"b\",\"b\"]）。\n可以证明字符串 s 中只有 3 个美丽子字符串。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bcdf\", k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 s 中没有美丽子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2950.可整除子串的数量",
        "hardRate": "MEDIUM",
        "passRate": "77.17%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-divisible-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-divisible-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]