[
    {
        "problemsName": " 3551.集水器",
        "hardRate": "HARD",
        "passRate": "57.33%",
        "problemsUrl": "https://leetcode.cn/problems/kskhHQ/",
        "solutionsUrl": "https://leetcode.cn/problems/kskhHQ/solution",
        "problemsDesc": "字符串数组 `shape` 描述了一个二维平面中的矩阵形式的集水器，`shape[i][j]` 表示集水器的第 `i` 行 `j` 列为：\n- `'l'`表示向左倾斜的隔板（即从左上到右下）；\n- `'r'`表示向右倾斜的隔板（即从左下到右上）；\n- `'.'` 表示此位置没有隔板\n![image.png](https://pic.leetcode-cn.com/1664424667-wMnPja-image.png){:width=200px}\n\n已知当隔板构成存储容器可以存水，每个方格代表的蓄水量为 `2`。集水器初始浸泡在水中，除内部密闭空间外，所有位置均被水填满。\n现将其从水中竖直向上取出，请返回集水器最终的蓄水量。\n\n**注意：**\n- 隔板具有良好的透气性，因此空气可以穿过隔板，但水无法穿过\n\n**示例 1：**\n> 输入：\n> `shape = [\"....rl\",\"l.lr.r\",\".l..r.\",\"..lr..\"]`\n>\n> 输出：`18`\n>\n> 解释：如下图所示，由于空气会穿过隔板，因此红框区域没有水\n![image.png](https://pic.leetcode-cn.com/1664436239-eyYxeP-image.png){:width=\"280px\"}\n\n\n**示例 2：**\n> 输入：\n> `shape = [\".rlrlrlrl\",\"ll..rl..r\",\".llrrllrr\",\"..lr..lr.\"]`\n> 输出：`18`\n>\n> 解释：如图所示。由于红框右侧未闭合，因此多余的水会从该处流走。\n![image.png](https://pic.leetcode-cn.com/1664436082-SibVMv-image.png){:width=\"400px\"}\n\n\n**示例 3：**\n> 输入：\n> `shape = [\"rlrr\",\"llrl\",\"llr.\"]`\n> 输出：`6`\n>\n> 解释：如图所示。\n![image.png](https://pic.leetcode-cn.com/1664424855-dwpUHO-image.png){:width=\"230px\"}\n\n\n\n\n**示例 4：**\n> 输入：\n> `shape = [\"...rl...\",\"..r..l..\",\".r.rl.l.\",\"r.r..l.l\",\"l.l..rl.\",\".l.lr.r.\",\"..l..r..\",\"...lr...\"]`\n>\n> 输出：`30`\n>\n> 解释：如下图所示。由于中间为内部密闭空间，无法蓄水。\n![image.png](https://pic.leetcode-cn.com/1664424894-mClEXh-image.png){:width=\"350px\"}\n\n\n**提示**：\n- `1 <= shape.length <= 50`\n- `1 <= shape[i].length <= 50`\n- `shape[i][j]` 仅为 `'l'`、`'r'` 或 `'.'`\n",
        "isPlus": false
    },
    {
        "problemsName": " 3552.补给马车",
        "hardRate": "EASY",
        "passRate": "67.83%",
        "problemsUrl": "https://leetcode.cn/problems/hqCnmP/",
        "solutionsUrl": "https://leetcode.cn/problems/hqCnmP/solution",
        "problemsDesc": "远征队即将开启未知的冒险之旅，不过在此之前，将对补给车队进行最后的检查。`supplies[i]` 表示编号为 `i` 的补给马车装载的物资数量。\n考虑到车队过长容易被野兽偷袭，他们决定将车队的长度变为原来的一半（向下取整），计划为：\n- 找出车队中 **物资之和最小** 两辆 **相邻** 马车，将它们车辆的物资整合为一辆。若存在多组物资之和相同的马车，则取编号最小的两辆马车进行整合；\n- 重复上述操作直到车队长度符合要求。\n\n请返回车队长度符合要求后，物资的分布情况。\n\n**示例 1：**\n>输入：`supplies = [7,3,6,1,8]`\n>\n>输出：`[10,15]`\n>\n>解释：\n> 第 1 次合并，符合条件的两辆马车为 6,1，合并后的车队为 [7,3,7,8]；\n> 第 2 次合并，符合条件的两辆马车为 (7,3) 和 (3,7)，取编号最小的 (7,3)，合并后的车队为 [10,7,8]；\n> 第 3 次合并，符合条件的两辆马车为 7,8，合并后的车队为 [10,15]；\n>返回 `[10,15]`\n\n**示例 2：**\n>输入：`supplies = [1,3,1,5]`\n>\n>输出：`[5,5]`\n\n**解释：**\n- `2 <= supplies.length <= 1000`\n- `1 <= supplies[i] <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 3553.探险营地",
        "hardRate": "MEDIUM",
        "passRate": "46.29%",
        "problemsUrl": "https://leetcode.cn/problems/0Zeoeg/",
        "solutionsUrl": "https://leetcode.cn/problems/0Zeoeg/solution",
        "problemsDesc": "探险家小扣的行动轨迹，都将保存在记录仪中。`expeditions[i]` 表示小扣第 `i` 次探险记录，用一个字符串数组表示。其中的每个「营地」由大小写字母组成，通过子串 `->` 连接。\n> 例：\"Leet->code->Campsite\"，表示到访了 \"Leet\"、\"code\"、\"Campsite\" 三个营地。\n\n`expeditions[0]` 包含了初始小扣已知的所有营地；对于之后的第 `i` 次探险(即 `expeditions[i]` 且 i > 0)，如果记录中包含了之前均没出现的营地，则表示小扣 **新发现** 的营地。\n\n请你找出小扣发现新营地最多且索引最小的那次探险，并返回对应的记录索引。如果所有探险记录都没有发现新的营地，返回 `-1`\n\n**注意：**\n- 大小写不同的营地视为不同的营地；\n- 营地的名称长度均大于 `0`。\n\n**示例 1：**\n>输入：`expeditions = [\"leet->code\",\"leet->code->Campsite->Leet\",\"leet->code->leet->courier\"]`\n>\n>输出：`1`\n>\n>解释：\n>初始已知的所有营地为 \"leet\" 和 \"code\"\n>第 1 次，到访了 \"leet\"、\"code\"、\"Campsite\"、\"Leet\"，新发现营地 2 处：\"Campsite\"、\"Leet\"\n>第 2 次，到访了 \"leet\"、\"code\"、\"courier\"，新发现营地 1 处：\"courier\"\n>第 1 次探险发现的新营地数量最多，因此返回 `1`\n\n**示例 2：**\n>输入：`expeditions = [\"Alice->Dex\",\"\",\"Dex\"]`\n>\n>输出：`-1`\n>\n>解释：\n>初始已知的所有营地为 \"Alice\" 和 \"Dex\"\n>第 1 次，未到访任何营地；\n>第 2 次，到访了 \"Dex\"，未新发现营地；\n>因为两次探险均未发现新的营地，返回 `-1`\n\n**示例 3：**\n>输入：`expeditions = [\"\",\"Gryffindor->Slytherin->Gryffindor\",\"Hogwarts->Hufflepuff->Ravenclaw\"]`\n>\n>输出：`2`\n>\n>解释：\n>初始未发现任何营地；\n>第 1 次，到访 \"Gryffindor\"、\"Slytherin\" 营地，其中重复到访 \"Gryffindor\" 两次，\n>因此新发现营地为 2 处：\"Gryffindor\"、\"Slytherin\"\n>第 2 次，到访 \"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\" 营地；\n>新发现营地 3 处：\"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\"；\n>第 2 次探险发现的新营地数量最多，因此返回 `2`\n\n**提示：**\n- `1 <= expeditions.length <= 1000`\n- `0 <= expeditions[i].length <= 1000`\n- 探险记录中只包含大小写字母和子串\"->\"",
        "isPlus": false
    },
    {
        "problemsName": " 3554.最强祝福力场",
        "hardRate": "MEDIUM",
        "passRate": "34.83%",
        "problemsUrl": "https://leetcode.cn/problems/xepqZ5/",
        "solutionsUrl": "https://leetcode.cn/problems/xepqZ5/solution",
        "problemsDesc": "小扣在探索丛林的过程中，无意间发现了传说中“落寞的黄金之都”。而在这片建筑废墟的地带中，小扣使用探测仪监测到了存在某种带有「祝福」效果的力场。\n经过不断的勘测记录，小扣将所有力场的分布都记录了下来。`forceField[i] = [x,y,side]` 表示第 `i` 片力场将覆盖以坐标 `(x,y)` 为中心，边长为 `side` 的正方形区域。\n\n若任意一点的 **力场强度** 等于覆盖该点的力场数量，请求出在这片地带中 **力场强度** 最强处的 **力场强度**。\n\n**注意：** \n- 力场范围的边缘同样被力场覆盖。\n\n**示例 1：**\n>输入：\n>`forceField = [[0,0,1],[1,0,1]]`\n>\n>输出：`2`\n>\n>解释：如图所示，（0.5, 0) 处力场强度最强为 2， （0.5，-0.5）处力场强度同样是 2。\n![image.png](https://pic.leetcode.cn/1681805536-zGfghe-image.png){:width=400px}\n\n\n**示例 2：**\n>输入：\n>`forceField = [[4,4,6],[7,5,3],[1,6,2],[5,6,3]]`\n>\n>输出：`3`\n>\n>解释：如下图所示，\n>`forceField[0]、forceField[1]、forceField[3]` 重叠的区域力场强度最大，返回 `3`\n![image.png](https://pic.leetcode.cn/1681805437-HQkyZS-image.png){:width=500px}\n\n\n\n**提示：**\n- `1 <= forceField.length <= 100`\n- `forceField[i].length == 3`\n- `0 <= forceField[i][0], forceField[i][1] <= 10^9`\n- `1 <= forceField[i][2] <= 10^9`",
        "isPlus": false
    },
    {
        "problemsName": " 3555.传送卷轴",
        "hardRate": "HARD",
        "passRate": "40.80%",
        "problemsUrl": "https://leetcode.cn/problems/rdmXM7/",
        "solutionsUrl": "https://leetcode.cn/problems/rdmXM7/solution",
        "problemsDesc": "随着不断的深入，小扣来到了守护者之森寻找的魔法水晶。首先，他必须先通过守护者的考验。\n\n考验的区域是一个正方形的迷宫，`maze[i][j]` 表示在迷宫 `i` 行 `j` 列的地形：\n- 若为 `.` ，表示可以到达的空地；\n- 若为 `#` ，表示不可到达的墙壁；\n- 若为 `S` ，表示小扣的初始位置；\n- 若为 `T` ，表示魔法水晶的位置。\n\n小扣每次可以向 上、下、左、右 相邻的位置移动一格。而守护者拥有一份「传送魔法卷轴」，使用规则如下：\n- 魔法需要在小扣位于 **空地** 时才能释放，发动后卷轴消失；；\n- 发动后，小扣会被传送到水平或者竖直的镜像位置，且目标位置不得为墙壁(如下图所示)；\n![image.png](https://pic.leetcode.cn/1681789509-wTekFu-image.png){:width=400px}\n\n在使用卷轴后，小扣将被「附加负面效果」，因此小扣需要尽可能缩短传送后到达魔法水晶的距离。而守护者的目标是阻止小扣到达魔法水晶的位置；如果无法阻止，则尽可能 **增加** 小扣传送后到达魔法水晶的距离。\n假设小扣和守护者都按最优策略行事，返回小扣需要在 「附加负面效果」的情况下 **最少** 移动多少次才能到达魔法水晶。如果无法到达，返回 `-1`。\n\n**注意：**\n- 守护者可以不使用卷轴；\n- 传送后的镜像位置可能与原位置相同。\n\n**示例 1：**\n>输入：`maze = [\".....\",\"##S..\",\"...#.\",\"T.#..\",\"###..\"]`\n>\n>输出：`7`\n>\n>解释：如下图所示：\n>守护者释放魔法的两个最佳的位置为 [2,0] 或 [3,1]：\n>若小扣经过 [2,0]，守护者在该位置释放魔法，\n>小扣被传送至 [2,4] 处且加上负面效果，此时小扣还需要移动 7 次才能到达魔法水晶；\n>若小扣经过 [3,1]，守护者在该位置释放魔法，\n>小扣被传送至 [3,3] 处且加上负面效果，此时小扣还需要移动 9 次才能到达魔法水晶；\n>因此小扣负面效果下最少需要移动 7 次才能到达魔法水晶。\n![image.png](https://pic.leetcode.cn/1681714676-gksEMT-image.png){:width=300px}\n\n\n**示例 2：**\n>输入：`maze = [\".#..\",\"..##\",\".#S.\",\".#.T\"]`\n>\n>输出：`-1`\n>\n>解释：如下图所示。\n>若小扣向下移动至 [3,2]，守护者使其传送至 [0,2]，小扣将无法到达魔法水晶；\n>若小扣向右移动至 [2,3]，守护者使其传送至 [2,0]，小扣将无法到达魔法水晶；\n![image.png](https://pic.leetcode.cn/1681714693-LsxKAh-image.png){:width=300px}\n\n\n**示例 3：**\n>输入：`maze = [\"S###.\",\"..###\",\"#..##\",\"##..#\",\"###.T\"]`\n>\n>输出：`5`\n>\n>解释：如下图所示：\n>守护者需要小扣在空地才能释放，因此初始无法将其从 [0,0] 传送至 [0,4];\n>当小扣移动至 [2,1] 时，释放卷轴将其传送至水平方向的镜像位置 [2,1]（为原位置）\n>而后小扣需要移动 5 次到达魔法水晶\n![image.png](https://pic.leetcode.cn/1681800985-KrSdru-image.png){:width=300px}\n\n**提示：**\n- `4 <= maze.length == maze[i].length <= 200`\n- `maze[i][j]` 仅包含 `\".\"`、`\"#\"`、`\"S\"`、`\"T\"`",
        "isPlus": false
    },
    {
        "problemsName": " 3556.魔法棋盘",
        "hardRate": "HARD",
        "passRate": "38.69%",
        "problemsUrl": "https://leetcode.cn/problems/1ybDKD/",
        "solutionsUrl": "https://leetcode.cn/problems/1ybDKD/solution",
        "problemsDesc": "在大小为 `n * m` 的棋盘中，有两种不同的棋子：黑色，红色。当两颗颜色不同的棋子同时满足以下两种情况时，将会产生魔法共鸣：\n- 两颗异色棋子在同一行或者同一列\n- 两颗异色棋子之间恰好只有一颗棋子\n    > 注：异色棋子之间可以有空位\n\n由于棋盘上被施加了魔法禁制，棋盘上的部分格子变成问号。`chessboard[i][j]` 表示棋盘第 `i` 行 `j` 列的状态：\n- 若为 `.` ，表示当前格子确定为空\n- 若为 `B` ，表示当前格子确定为 黑棋\n- 若为 `R` ，表示当前格子确定为 红棋\n- 若为 `?` ，表示当前格子待定\n\n现在，探险家小扣的任务是确定所有问号位置的状态（留空/放黑棋/放红棋），使最终的棋盘上，任意两颗棋子间都 **无法** 产生共鸣。请返回可以满足上述条件的放置方案数量。\n\n**示例1：**\n> 输入：`n = 3, m = 3, chessboard = [\"..R\",\"..B\",\"?R?\"]`\n>\n> 输出：`5`\n>\n> 解释：给定的棋盘如图：\n>![image.png](https://pic.leetcode.cn/1681714583-unbRox-image.png){:height=150px}\n> 所有符合题意的最终局面如图：\n>![image.png](https://pic.leetcode.cn/1681714596-beaOHK-image.png){:height=150px}\n\n**示例2：**\n> 输入：`n = 3, m = 3, chessboard = [\"?R?\",\"B?B\",\"?R?\"]`\n>\n> 输出：`105`\n\n**提示：**\n- `n == chessboard.length`\n- `m == chessboard[i].length`\n- `1 <= n*m <= 30`\n- `chessboard` 中仅包含 `\".\"、\"B\"、\"R\"、\"?\"`",
        "isPlus": false
    },
    {
        "problemsName": " 3557.符文储备",
        "hardRate": "EASY",
        "passRate": "68.58%",
        "problemsUrl": "https://leetcode.cn/problems/W2ZX4X/",
        "solutionsUrl": "https://leetcode.cn/problems/W2ZX4X/solution",
        "problemsDesc": "远征队在出发前需要携带一些「符文」，作为后续的冒险储备。`runes[i]` 表示第 `i` 枚符文的魔力值。\n\n他们将从中选取若干符文进行携带，并对这些符文进行重新排列，以确保任意相邻的两块符文之间的魔力值相差不超过 `1`。\n\n请返回他们能够携带的符文 **最大数量**。\n\n**示例 1：**\n>输入：`runes = [1,3,5,4,1,7]`\n>\n>输出：`3`\n>\n>解释：最佳的选择方案为[3,5,4]\n>将其排列为 [3,4,5] 后，任意相邻的两块符文魔力值均不超过 `1`，携带数量为 `3`\n>其他满足条件的方案为 [1,1] 和 [7]，数量均小于 3。\n>因此返回可携带的最大数量 `3`。\n\n**示例 2：**\n>输入：`runes = [1,1,3,3,2,4]`\n>\n>输出：`6`\n>\n>解释：排列为 [1,1,2,3,3,4]，可携带所有的符文\n\n**提示：**\n- `1 <= runes.length <= 10^4`\n- `0 <= runes[i] <= 10^4`\n",
        "isPlus": false
    },
    {
        "problemsName": " 3558.城墙防线",
        "hardRate": "MEDIUM",
        "passRate": "45.97%",
        "problemsUrl": "https://leetcode.cn/problems/Nsibyl/",
        "solutionsUrl": "https://leetcode.cn/problems/Nsibyl/solution",
        "problemsDesc": "在探险营地间，小扣意外发现了一片城墙遗迹，在探索期间，却不巧遇到迁徙中的兽群向他迎面冲来。情急之下小扣吹响了他的苍蓝笛，随着笛声响起，遗迹中的城墙逐渐发生了横向膨胀。\n已知 `rampart[i] = [x,y]` 表示第 `i` 段城墙的初始所在区间。当城墙发生膨胀时，将遵循以下规则：\n- 所有的城墙会同时膨胀相等的长度；\n- 每个城墙可以向左、向右或向两个方向膨胀。\n\n小扣为了确保自身的安全，需要在所有城墙均无重叠的情况下，让城墙尽可能的膨胀。请返回城墙可以膨胀的 **最大值** 。\n\n**注意：**\n- 初始情况下，所有城墙均不重叠，且 `rampart` 中的元素升序排列；\n- 两侧的城墙可以向外无限膨胀。\n\n**示例 1：**\n>输入：`rampart = [[0,3],[4,5],[7,9]]`\n>\n>输出：`3`\n>\n>解释：如下图所示：\n>`rampart[0]` 向左侧膨胀 3 个单位；\n>`rampart[2]` 向右侧膨胀 3 个单位；\n>`rampart[1]` 向左侧膨胀 1 个单位，向右膨胀 2 个单位。\n>不存在膨胀更多的方案，返回 3。\n![image.png](https://pic.leetcode.cn/1681717918-tWywrp-image.png){:width=750px}\n\n**示例 2：**\n>输入：`rampart = [[1,2],[5,8],[11,15],[18,25]]`\n>\n>输出：`4`\n\n**提示：**\n- `3 <= rampart.length <= 10^4`\n- `rampart[i].length == 2`\n- `0 <= rampart[i][0] < rampart[i][1] <= rampart[i+1][0] <= 10^8`",
        "isPlus": false
    },
    {
        "problemsName": " 3559.提取咒文",
        "hardRate": "MEDIUM",
        "passRate": "30.55%",
        "problemsUrl": "https://leetcode.cn/problems/kjpLFZ/",
        "solutionsUrl": "https://leetcode.cn/problems/kjpLFZ/solution",
        "problemsDesc": "随着兽群逐渐远去，一座大升降机缓缓的从地下升到了远征队面前。借由这台升降机，他们将能够到达地底的永恒至森。\n在升降机的操作台上，是一个由魔法符号组成的矩阵，为了便于辨识，我们用小写字母来表示。 `matrix[i][j]` 表示矩阵第 `i` 行 `j` 列的字母。该矩阵上有一个提取装置，可以对所在位置的字母提取。\n提取装置初始位于矩阵的左上角 `[0,0]`，可以通过每次操作移动到上、下、左、右相邻的 1 格位置中。提取装置每次移动或每次提取均记为一次操作。\n\n远征队需要按照顺序，从矩阵中逐一取出字母以组成 `mantra`，才能够成功的启动升降机。请返回他们 **最少** 需要消耗的操作次数。如果无法完成提取，返回 `-1`。\n\n**注意：**\n- 提取装置可对同一位置的字母重复提取，每次提取一个\n- 提取字母时，需按词语顺序依次提取\n\n**示例 1：**\n>输入：`matrix = [\"sd\",\"ep\"], mantra = \"speed\"`\n>\n>输出：`10`\n>\n>解释：如下图所示\n![矩阵 (2).gif](https://pic.leetcode-cn.com/1646288670-OTlvAl-%E7%9F%A9%E9%98%B5%20\\(2\\).gif)\n\n**示例 2：**\n>输入：`matrix = [\"abc\",\"daf\",\"geg\"]， mantra = \"sad\"`\n>\n>输出：`-1`\n>\n>解释：矩阵中不存在 `s` ，无法提取词语\n\n**提示：**\n- `0 < matrix.length, matrix[i].length <= 100`\n- `0 < mantra.length <= 100`\n- `matrix 和 mantra` 仅由小写字母组成",
        "isPlus": false
    },
    {
        "problemsName": " 3560.生物进化录",
        "hardRate": "HARD",
        "passRate": "52.58%",
        "problemsUrl": "https://leetcode.cn/problems/qoQAMX/",
        "solutionsUrl": "https://leetcode.cn/problems/qoQAMX/solution",
        "problemsDesc": "在永恒之森中，存在着一本生物进化录，以 **一个树形结构** 记载了所有生物的演化过程。经过观察并整理了各节点间的关系，`parents[i]` 表示编号 `i` 节点的父节点编号(根节点的父节点为 `-1`)。\n\n为了探索和记录其中的演化规律，队伍中的炼金术师提出了一种方法，可以以字符串的形式将其复刻下来，规则如下：\n- 初始只有一个根节点，表示演化的起点，依次记录 `01` 字符串中的字符，\n- 如果记录 `0`，则在当前节点下添加一个子节点，并将指针指向新添加的子节点；\n- 如果记录 `1`，则将指针回退到当前节点的父节点处。\n\n现在需要应用上述的记录方法，复刻下它的演化过程。请返回能够复刻演化过程的字符串中， **字典序最小** 的 `01` 字符串。\n\n**注意：**\n- 节点指针最终可以停在任何节点上，不一定要回到根节点。\n\n**示例 1：**\n> 输入：`parents = [-1,0,0,2]`\n>\n> 输出：`\"00110\"`\n>\n>解释：树结构如下图所示，共存在 2 种记录方案：\n>第 1 种方案为：0(记录编号 1 的节点) -> 1(回退至节点 0) -> 0(记录编号 2 的节点) -> 0((记录编号 3 的节点))\n>第 2 种方案为：0(记录编号 2 的节点) -> 0(记录编号 3 的节点) -> 1(回退至节点 2) -> 1(回退至节点 0) -> 0(记录编号 1 的节点)\n>返回字典序更小的 `\"00110\"`\n![image.png](https://pic.leetcode.cn/1682319485-cRVudI-image.png){:width=120px}![进化 (3).gif](https://pic.leetcode.cn/1682412701-waHdnm-%E8%BF%9B%E5%8C%96%20\\(3\\).gif){:width=320px}\n\n\n\n**示例 2：**\n> 输入：`parents = [-1,0,0,1,2,2]`\n>\n> 输出：`\"00101100\"`\n\n**提示：**\n\n- `1 <= parents.length <= 10^4`\n- `-1 <= parents[i] < i` (即父节点编号小于子节点)",
        "isPlus": false
    },
    {
        "problemsName": " 3561.与非的谜题",
        "hardRate": "HARD",
        "passRate": "47.55%",
        "problemsUrl": "https://leetcode.cn/problems/ryfUiz/",
        "solutionsUrl": "https://leetcode.cn/problems/ryfUiz/solution",
        "problemsDesc": "在永恒之森中，封存着有关万灵之树线索的卷轴，只要探险队通过最后的考验，便可以获取前往万灵之树的线索。\n\n探险队需要从一段不断变化的谜题数组中找到最终的密码，初始的谜题为长度为 `n` 的数组 `arr`（下标从 0 开始），数组中的数字代表了 `k` 位二进制数。\n破解谜题的过程中，需要使用 `与非（NAND）` 运算方式，`operations[i] = [type,x,y]` 表示第 `i` 次进行的谜题操作信息：\n- 若 `type = 0`，表示修改操作，将谜题数组中下标 `x` 的数字变化为 `y`；\n- 若 `type = 1`，表示运算操作，将数字 `y` 进行 `x*n` 次「与非」操作，第 `i` 次与非操作为 `y = y NAND arr[i%n]`；\n    > 运算操作结果即：`y NAND arr[0%n] NAND arr[1%n] NAND arr[2%n] ... NAND arr[(x*n-1)%n]`\n\n最后，将所有运算操作的结果按顺序逐一进行 `异或（XOR）`运算，从而得到最终解开封印的密码。请返回最终解开封印的密码。\n\n**注意:**\n- 「与非」（NAND）的操作为：先进行 `与` 操作，后进行 `非` 操作。\n    > 例如：两个三位二进制数`2`和`3`，其与非结果为 `NOT ((010) AND (011)) = (101) = 5`\n\n**示例 1：**\n> 输入: \n> `k = 3`\n> `arr = [1,2]`\n> `operations = [[1,2,3],[0,0,3],[1,2,2]]`\n>\n> 输出: `2`\n>\n> 解释：\n> 初始的谜题数组为 [1,2]，二进制位数为 3，\n> 第 0 次进行运算操作，将数字 3(011) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `3 NAND 1 NAND 2 NAND 1 NAND 2 = 5`\n> 第 1 次进行修改操作，谜题数组的第 `0` 个数字变化为 `3`，谜题变成 `[3,2]`\n> 第 2 次进行运算操作，将数字 2(010) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `2 NAND 3 NAND 2 NAND 3 NAND 2 = 7`\n> 所有运算操作结果进行「异或」运算为 `5 XOR 7 = 2`\n> 因此得到的最终密码为 `2`。\n\n**示例 2：**\n> 输入:\n> `k = 4`\n> `arr = [4,6,4,7,10,9,11]`\n> `operations = [[1,5,7],[1,7,14],[0,6,7],[1,6,5]]`\n> 输出: `9`\n> 解释: \n> 初始的谜题数组为 [4,6,4,7,10,9,11],\n> 第 0 次进行运算操作，运算操作结果为 5；\n> 第 1 次进行运算操作，运算操作结果为 5；\n> 第 2 次进行修改操作，修改后谜题数组为 [4, 6, 4, 7, 10, 9, 7]；\n> 第 3 次进行运算操作，运算操作结果为 9；\n> 所有运算操作结果进行「异或」运算为 `5 XOR 5 XOR 9 = 9`；\n> 因此得到的最终密码为 `9`。\n\n**提示:**\n- `1 <= arr.length, operations.length <= 10^4`\n- `1 <= k <= 30`\n- `0 <= arr[i] < 2^k`\n- 若 `type = 0`，`0 <= x < arr.length` 且 `0 <= y < 2^k`\n- 若 `type = 1`，`1 <= x < 10^9` 且 `0 <= y < 2^k`\n- 保证存在 `type = 1` 的操作\n",
        "isPlus": false
    },
    {
        "problemsName": " 3562.万灵之树",
        "hardRate": "HARD",
        "passRate": "18.46%",
        "problemsUrl": "https://leetcode.cn/problems/cnHoX6/",
        "solutionsUrl": "https://leetcode.cn/problems/cnHoX6/solution",
        "problemsDesc": "探险家小扣终于来到了万灵之树前，挑战最后的谜题。\n已知小扣拥有足够数量的链接节点和 `n` 颗幻境宝石，`gem[i]` 表示第 `i` 颗宝石的数值。现在小扣需要使用这些链接节点和宝石组合成一颗二叉树，其组装规则为：\n- 链接节点将作为二叉树中的非叶子节点，且每个链接节点必须拥有 `2` 个子节点；\n- 幻境宝石将作为二叉树中的叶子节点，所有的幻境宝石都必须被使用。\n\n能量首先进入根节点，而后将按如下规则进行移动和记录：\n- 若能量首次到达该节点时：\n    - 记录数字 `1`；\n    - 若该节点为叶节点，将额外记录该叶节点的数值；\n- 若存在未到达的子节点，则选取未到达的一个子节点（优先选取左子节点）进入；\n- 若无子节点或所有子节点均到达过，此时记录 `9`，并回到当前节点的父节点（若存在）。\n\n如果最终记下的数依序连接成一个整数 `num`，满足 $num \\mod~p=target$，则视为解开谜题。\n请问有多少种二叉树的组装方案，可以使得最终记录下的数字可以解开谜题\n\n**注意：**\n- 两棵结构不同的二叉树，作为不同的组装方案\n- 两棵结构相同的二叉树且存在某个相同位置处的宝石编号不同，也作为不同的组装方案\n- 可能存在数值相同的两颗宝石\n\n**示例 1：**\n> 输入：`gem = [2,3]`\n> `p = 100000007`\n> `target = 11391299`\n>\n> 输出：`1`\n>\n> 解释：\n> 包含 `2` 个叶节点的结构只有一种。\n> 假设 B、C 节点的值分别为 3、2，对应 target 为 11391299，如下图所示。\n> 11391299 % 100000007 = 11391299，满足条件;\n> 假设 B、C 节点的值分别为 2、3，对应 target 为 11291399;\n> 11291399 % 100000007 = 11291399，不满足条件；\n> 因此只存在 1 种方案，返回 1\n![万灵 (1).gif](https://pic.leetcode.cn/1682397079-evMssw-%E4%B8%87%E7%81%B5%20\\(1\\).gif){:height=300px}\n\n\n**示例 2：**\n> 输入：`gem = [3,21,3]`\n> `p = 7`\n> `target = 5`\n>\n> 输出：`4`\n>\n> 解释：\n包含 `3` 个叶节点树结构有两种，列举如下：\n满足条件的组合有四种情况：\n> 当结构为下图（1）时：叶子节点的值为 [3,3,21] 或 [3,3,21]，得到的整数为 `11139139912199`。\n> 当结构为下图（2）时：叶子节点的值为 [21,3,3] 或 [21,3,3]，得到的整数为 `11219113913999`。\n![image.png](https://pic.leetcode.cn/1682322894-vfqJIV-image.png){:width=500px}\n\n\n**提示：**\n- `1 <= gem.length <= 9`\n- `0 <= gem[i] <= 10^9`\n- `1 <= p <= 10^9`，保证 $p$ 为素数。\n- `0 <= target < p`\n- 存在 2 组 `gem.length == 9` 的用例",
        "isPlus": false
    },
    {
        "problemsName": " 3563.两数相除",
        "hardRate": "EASY",
        "passRate": "21.23%",
        "problemsUrl": "https://leetcode.cn/problems/xoh6Oh/",
        "solutionsUrl": "https://leetcode.cn/problems/xoh6Oh/solution",
        "problemsDesc": "<p>给定两个整数 <code>a</code> 和 <code>b</code> ，求它们的除法的商 <code>a/b</code> ，要求不得使用乘号 <code>&#39;*&#39;</code>、除号 <code>&#39;/&#39;</code> 以及求余符号 <code>&#39;%&#39;</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code>&nbsp;以及&nbsp;<code>truncate(-2.7335) = -2</code></li>\n\t<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 <code>[&minus;2<sup>31</sup>,&nbsp;2<sup>31</sup>&minus;1]</code>。本题中，如果除法结果溢出，则返回 <code>2<sup>31&nbsp;</sup>&minus; 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 15, b = 2\n<strong>输出：</strong>7\n<strong><span style=\"white-space: pre-wrap;\">解释：</span></strong>15/2 = truncate(7.5) = 7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 7, b = -3\n<strong>输出：</strong><span style=\"white-space: pre-wrap;\">-2</span>\n<strong><span style=\"white-space: pre-wrap;\">解释：</span></strong>7/-3 = truncate(-2.33333..) = -2</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 0, b = 1\n<strong>输出：</strong><span style=\"white-space: pre-wrap;\">0</span></pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 1\n<strong>输出：</strong><span style=\"white-space: pre-wrap;\">1</span></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= a, b &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n\t<li><code>b != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 29&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/divide-two-integers/\">https://leetcode-cn.com/problems/divide-two-integers/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3564.二进制求和",
        "hardRate": "EASY",
        "passRate": "53.81%",
        "problemsUrl": "https://leetcode.cn/problems/JFETK5/",
        "solutionsUrl": "https://leetcode.cn/problems/JFETK5/solution",
        "problemsDesc": "<p>给定两个 01 字符串&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;，请计算它们的和，并以二进制字符串的形式输出。</p>\n\n<p>输入为 <strong>非空 </strong>字符串且只包含数字&nbsp;<code>1</code>&nbsp;和&nbsp;<code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> a = &quot;11&quot;, b = &quot;10&quot;\n<strong>输出:</strong> &quot;101&quot;</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> a = &quot;1010&quot;, b = &quot;1011&quot;\n<strong>输出:</strong> &quot;10101&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>\n\t<li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 67&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/add-binary/\">https://leetcode-cn.com/problems/add-binary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3565.比特位计数",
        "hardRate": "EASY",
        "passRate": "78.14%",
        "problemsUrl": "https://leetcode.cn/problems/w3tCBm/",
        "solutionsUrl": "https://leetcode.cn/problems/w3tCBm/solution",
        "problemsDesc": "<p>给定一个非负整数 <code>n</code><b>&nbsp;</b>，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>n =<strong> </strong>2\n<strong>输出: </strong>[0,1,1]\n<strong>解释: \n</strong>0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入: </strong>n =<strong> </strong>5\n<strong>输出: </strong><code>[0,1,1,2,1,2]\n</code><span style=\"white-space: pre-wrap;\"><strong>解释:</strong>\n</span>0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n3 --&gt; 11\n4 --&gt; 100\n5 --&gt; 101\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明 :</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong></p>\n\n<ul>\n\t<li>给出时间复杂度为&nbsp;<code>O(n*sizeof(integer))</code><strong>&nbsp;</strong>的解答非常容易。但你可以在线性时间&nbsp;<code>O(n)</code><strong>&nbsp;</strong>内用一趟扫描做到吗？</li>\n\t<li>要求算法的空间复杂度为&nbsp;<code>O(n)</code>&nbsp;。</li>\n\t<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的&nbsp;<code>__builtin_popcount</code><strong>&nbsp;</strong>）来执行此操作。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 338&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/counting-bits/\">https://leetcode-cn.com/problems/counting-bits/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3566.只出现一次的数字 II",
        "hardRate": "MEDIUM",
        "passRate": "70.87%",
        "problemsUrl": "https://leetcode.cn/problems/WGki4K/",
        "solutionsUrl": "https://leetcode.cn/problems/WGki4K/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,3,2]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,1,0,1,100]\n<strong>输出：</strong>100\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 137&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/single-number-ii/\">https://leetcode-cn.com/problems/single-number-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3567.最大单词长度乘积",
        "hardRate": "MEDIUM",
        "passRate": "71.29%",
        "problemsUrl": "https://leetcode.cn/problems/aseY1I/",
        "solutionsUrl": "https://leetcode.cn/problems/aseY1I/solution",
        "problemsDesc": "<p>给定一个字符串数组&nbsp;<code>words</code>，请计算当两个字符串 <code>words[i]</code> 和 <code>words[j]</code> 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]\n<strong>输出：</strong>16 \n<strong>解释：</strong>这两个单词为<strong> </strong>&quot;abcw&quot;, &quot;fxyz&quot;。它们不包含相同字符，且长度的乘积最大。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]\n<strong>输出：</strong>4 \n<strong>解释：</strong>这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]\n<strong>输出：</strong>0 \n<strong>解释：</strong>不存在这样的两个单词。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 318&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\">https://leetcode-cn.com/problems/maximum-product-of-word-lengths/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3568.两数之和 II - 输入有序数组",
        "hardRate": "EASY",
        "passRate": "67.37%",
        "problemsUrl": "https://leetcode.cn/problems/kLl5u1/",
        "solutionsUrl": "https://leetcode.cn/problems/kLl5u1/solution",
        "problemsDesc": "<p>给定一个已按照<strong><em> </em>升序排列&nbsp; </strong>的整数数组&nbsp;<code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数&nbsp;<code>target</code> 。</p>\n\n<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 0&nbsp;开始计数</strong> ，所以答案数组应当满足 <code>0&nbsp;&lt;= answer[0] &lt; answer[1] &lt;&nbsp;numbers.length</code>&nbsp;。</p>\n\n<p>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [1,2,4,6,10], target = 8\n<strong>输出：</strong>[1,3]\n<strong>解释：</strong>2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [2,3,4], target = 6\n<strong>输出：</strong>[0,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [-1,0], target = -1\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>仅存在一个有效答案</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 167 题相似（下标起点不同）：<a href=\"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/\">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3569.三数之和",
        "hardRate": "MEDIUM",
        "passRate": "43.37%",
        "problemsUrl": "https://leetcode.cn/problems/1fGaJU/",
        "solutionsUrl": "https://leetcode.cn/problems/1fGaJU/solution",
        "problemsDesc": "<p>给定一个包含 <code>n</code> 个整数的数组&nbsp;<code>nums</code>，判断&nbsp;<code>nums</code>&nbsp;中是否存在三个元素&nbsp;<code>a</code> ，<code>b</code> ，<code>c</code> <em>，</em>使得&nbsp;<code>a + b + c = 0</code> ？请找出所有和为 <code>0</code> 且&nbsp;<strong>不重复&nbsp;</strong>的三元组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 15&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/3sum/\">https://leetcode-cn.com/problems/3sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3570.长度最小的子数组",
        "hardRate": "MEDIUM",
        "passRate": "50.96%",
        "problemsUrl": "https://leetcode.cn/problems/2VG8Kg/",
        "solutionsUrl": "https://leetcode.cn/problems/2VG8Kg/solution",
        "problemsDesc": "<p>给定一个含有&nbsp;<code>n</code><strong>&nbsp;</strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p>\n\n<p>找出该数组中满足其和<strong> </strong><code>&ge; target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong>&nbsp;<code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>子数组&nbsp;<code>[4,3]</code>&nbsp;是该条件下的长度最小的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 4, nums = [1,4,4]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>进阶：</p>\n\n<ul>\n\t<li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 209&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/\">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3571.乘积小于 K 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "53.13%",
        "problemsUrl": "https://leetcode.cn/problems/ZVAVXX/",
        "solutionsUrl": "https://leetcode.cn/problems/ZVAVXX/solution",
        "problemsDesc": "<p>给定一个正整数数组&nbsp;<code>nums</code>和整数 <code>k</code>&nbsp;，请找出该数组内乘积小于&nbsp;<code>k</code>&nbsp;的连续的子数组的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [10,5,2,6], k = 100\n<strong>输出:</strong> 8\n<strong>解释:</strong> 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于100的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3], k = 0\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 713&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/subarray-product-less-than-k/\">https://leetcode-cn.com/problems/subarray-product-less-than-k/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3572.和为 K 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "43.71%",
        "problemsUrl": "https://leetcode.cn/problems/QTMn0o/",
        "solutionsUrl": "https://leetcode.cn/problems/QTMn0o/solution",
        "problemsDesc": "<p>给定一个整数数组和一个整数&nbsp;<code>k</code><strong> ，</strong>请找到该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>nums = [1,1,1], k = 2\n<strong>输出:</strong> 2\n<strong>解释:</strong> 此题 [1,1] 与 [1,1] 为两种不同的情况\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong>nums = [1,2,3], k = 3\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>\n\t<p><code>-10<sup>7</sup>&nbsp;&lt;= k &lt;= 10<sup>7</sup></code></p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 560&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/subarray-sum-equals-k/\">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3573.连续数组",
        "hardRate": "MEDIUM",
        "passRate": "54.56%",
        "problemsUrl": "https://leetcode.cn/problems/A1NYOS/",
        "solutionsUrl": "https://leetcode.cn/problems/A1NYOS/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> 2\n<strong>解释:</strong> [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1,0]\n<strong>输出:</strong> 2\n<strong>解释:</strong> [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 525&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/contiguous-array/\">https://leetcode-cn.com/problems/contiguous-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3574.寻找数组的中心下标",
        "hardRate": "EASY",
        "passRate": "67.97%",
        "problemsUrl": "https://leetcode.cn/problems/tvdfij/",
        "solutionsUrl": "https://leetcode.cn/problems/tvdfij/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> ，请计算数组的 <strong>中心下标 </strong>。</p>\n\n<p>数组<strong> 中心下标</strong><strong> </strong>是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,7,3,6,5,6]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n中心下标是 3 。\n左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n数组中不存在满足此条件的中心下标。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2, 1, -1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n中心下标是 0 。\n左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 724&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-pivot-index/\">https://leetcode-cn.com/problems/find-pivot-index/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3575.二维区域和检索 - 矩阵不可变",
        "hardRate": "MEDIUM",
        "passRate": "69.06%",
        "problemsUrl": "https://leetcode.cn/problems/O4NDxx/",
        "solutionsUrl": "https://leetcode.cn/problems/O4NDxx/solution",
        "problemsDesc": "<p><big><small>给定一个二维矩阵 <code>matrix</code>，</small></big>以下类型的多个请求：</p>\n\n<ul>\n\t<li><big><small>计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1,&nbsp;col1)</code> ，右下角为 <code>(row2,&nbsp;col2)</code> 。</small></big></li>\n</ul>\n\n<p>实现 <code>NumMatrix</code> 类：</p>\n\n<ul>\n\t<li><code>NumMatrix(int[][] matrix)</code>&nbsp;给定整数矩阵 <code>matrix</code> 进行初始化</li>\n\t<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code>&nbsp;返回<big><small>左上角</small></big><big><small> <code>(row1,&nbsp;col1)</code>&nbsp;、右下角&nbsp;<code>(row2,&nbsp;col2)</code></small></big>&nbsp;的子矩阵的元素总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png\" style=\"width: 200px;\" /></p>\n\n<pre>\n<strong>输入:</strong> \n[&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n<strong>输出:</strong> \n[null, 8, 11, 12]\n\n<strong>解释:</strong>\nNumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m,&nbsp;n &lt;=&nbsp;200</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>\n\t<li><meta charset=\"UTF-8\" />最多调用 <code>10<sup>4</sup></code> 次&nbsp;<code>sumRegion</code> 方法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 304&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">https://leetcode-cn.com/problems/range-sum-query-2d-immutable/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3576.字符串的排列",
        "hardRate": "MEDIUM",
        "passRate": "51.48%",
        "problemsUrl": "https://leetcode.cn/problems/MPnaiL/",
        "solutionsUrl": "https://leetcode.cn/problems/MPnaiL/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的某个变位词。</p>\n\n<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;\n<strong>输出: </strong>True\n<strong>解释:</strong> s2 包含 s1 的排列之一 (&quot;ba&quot;).\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;\n<strong>输出:</strong> False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 567&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/permutation-in-string/\">https://leetcode-cn.com/problems/permutation-in-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3577.找到字符串中所有字母异位词",
        "hardRate": "MEDIUM",
        "passRate": "60.80%",
        "problemsUrl": "https://leetcode.cn/problems/VabMRr/",
        "solutionsUrl": "https://leetcode.cn/problems/VabMRr/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和<b>&nbsp;</b><code>p</code>，找到&nbsp;<code>s</code><strong>&nbsp;</strong>中所有 <code>p</code> 的&nbsp;<strong>变位词&nbsp;</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n\n<p><strong>变位词 </strong>指字母相同，但排列不同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;\n<strong>输出: </strong>[0,6]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的变位词。\n起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的变位词。\n</pre>\n\n<p><strong>&nbsp;示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;abab&quot;, p = &quot;ab&quot;\n<strong>输出: </strong>[0,1,2]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;和 <code>p</code> 仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 438&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\" style=\"background-color: rgb(255, 255, 255);\">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3578.无重复字符的最长子串",
        "hardRate": "MEDIUM",
        "passRate": "47.40%",
        "problemsUrl": "https://leetcode.cn/problems/wtcaE1/",
        "solutionsUrl": "https://leetcode.cn/problems/wtcaE1/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的&nbsp;<strong>最长连续子字符串&nbsp;</strong>的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;abcabcbb&quot;\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子字符串是 <code>&quot;abc&quot;，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;bbbbb&quot;\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子字符串是 <code>&quot;b&quot;</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;pwwkew&quot;\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>&quot;wke&quot;</code>，所以其长度为 3。\n&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>&quot;pwke&quot;</code>&nbsp;是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;&quot;\n<strong>输出: </strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;由英文字母、数字、符号和空格组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 3&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3579.最小覆盖子串",
        "hardRate": "HARD",
        "passRate": "51.03%",
        "problemsUrl": "https://leetcode.cn/problems/M1oyTv/",
        "solutionsUrl": "https://leetcode.cn/problems/M1oyTv/solution",
        "problemsDesc": "<p>给定两个字符串 <code>s</code> 和&nbsp;<code>t</code> 。返回 <code>s</code> 中包含&nbsp;<code>t</code>&nbsp;的所有字符的最短子字符串。如果 <code>s</code> 中不存在符合条件的子字符串，则返回空字符串 <code>&quot;&quot;</code> 。</p>\n\n<p>如果 <code>s</code> 中存在多个符合条件的子字符串，返回任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意： </strong>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>输出：</strong>&quot;BANC&quot; \n<strong>解释：</strong>最短子字符串 &quot;BANC&quot; 包含了字符串 t 的所有字符 &#39;A&#39;、&#39;B&#39;、&#39;C&#39;</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;, t = &quot;a&quot;\n<strong>输出：</strong>&quot;a&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 76&nbsp;题相似（本题答案不唯一）：<a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\">https://leetcode-cn.com/problems/minimum-window-substring/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3580.验证回文串",
        "hardRate": "EASY",
        "passRate": "51.24%",
        "problemsUrl": "https://leetcode.cn/problems/XltzEq/",
        "solutionsUrl": "https://leetcode.cn/problems/XltzEq/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，验证 <code>s</code>&nbsp;是否是&nbsp;<strong>回文串&nbsp;</strong>，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n\n<p>本题中，将空字符串定义为有效的&nbsp;<strong>回文串&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s =<strong> </strong>&quot;A man, a plan, a canal: Panama&quot;\n<strong>输出:</strong> true\n<strong>解释：</strong>&quot;amanaplanacanalpanama&quot; 是回文串</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;race a car&quot;\n<strong>输出:</strong> false\n<strong>解释：</strong>&quot;raceacar&quot; 不是回文串</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>字符串 <code>s</code> 由 ASCII 字符组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 125&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/valid-palindrome/\">https://leetcode-cn.com/problems/valid-palindrome/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3581.验证回文串 II",
        "hardRate": "EASY",
        "passRate": "45.21%",
        "problemsUrl": "https://leetcode.cn/problems/RQku0D/",
        "solutionsUrl": "https://leetcode.cn/problems/RQku0D/solution",
        "problemsDesc": "<p>给定一个非空字符串&nbsp;<code>s</code>，请判断如果&nbsp;<strong>最多 </strong>从字符串中删除一个字符能否得到一个回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;aba&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;abca&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong> 可以删除 &quot;c&quot; 字符 或者 &quot;b&quot; 字符\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;abc&quot;\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 680&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/\">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3582.回文子串",
        "hardRate": "MEDIUM",
        "passRate": "70.82%",
        "problemsUrl": "https://leetcode.cn/problems/a7VOhD/",
        "solutionsUrl": "https://leetcode.cn/problems/a7VOhD/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p>\n\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;abc&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;aaa&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 70 题相同：<a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">https://leetcode-cn.com/problems/palindromic-substrings/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3583.删除链表的倒数第 N 个结点",
        "hardRate": "MEDIUM",
        "passRate": "56.31%",
        "problemsUrl": "https://leetcode.cn/problems/SLwz0R/",
        "solutionsUrl": "https://leetcode.cn/problems/SLwz0R/solution",
        "problemsDesc": "<p>给定一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], n = 2\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], n = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中结点的数目为 <code>sz</code></li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能尝试使用一趟扫描实现吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 19&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3584.环形链表 II",
        "hardRate": "MEDIUM",
        "passRate": "55.74%",
        "problemsUrl": "https://leetcode.cn/problems/c32eOV/",
        "solutionsUrl": "https://leetcode.cn/problems/c32eOV/solution",
        "problemsDesc": "<p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回&nbsp;<code>null</code>。</p>\n\n<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>\n\n<p><strong>说明：</strong>不允许修改给定的链表。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>返回索引为 1 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>返回索引为 0 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>返回 null\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>是否可以使用 <code>O(1)</code> 空间解决此题？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 142&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3585.相交链表",
        "hardRate": "EASY",
        "passRate": "67.68%",
        "problemsUrl": "https://leetcode.cn/problems/3u1WK4/",
        "solutionsUrl": "https://leetcode.cn/problems/3u1WK4/solution",
        "problemsDesc": "<p>给定两个单链表的头节点&nbsp;<code>headA</code> 和 <code>headB</code> ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at &#39;8&#39;\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at &#39;2&#39;\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;= m</code></li>\n\t<li><code>0 &lt;= skipB &lt;= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 160&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3586.反转链表",
        "hardRate": "EASY",
        "passRate": "75.70%",
        "problemsUrl": "https://leetcode.cn/problems/UHnkqh/",
        "solutionsUrl": "https://leetcode.cn/problems/UHnkqh/solution",
        "problemsDesc": "<p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 302px; \" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[5,4,3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 102px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 206&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3587.两数相加 II",
        "hardRate": "MEDIUM",
        "passRate": "58.22%",
        "problemsUrl": "https://leetcode.cn/problems/lMSNwu/",
        "solutionsUrl": "https://leetcode.cn/problems/lMSNwu/solution",
        "problemsDesc": "<p>给定两个 <strong>非空链表</strong> <code>l1</code>和 <code>l2</code>&nbsp;来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>\n\n<p>可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png\" style=\"width: 302px; \" /></p>\n\n<pre>\n<strong>输入：</strong>l1 = [7,2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,8,0,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[8,0,7]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为<code> [1, 100]</code></li>\n\t<li><code>0 &lt;= node.val &lt;= 9</code></li>\n\t<li>输入数据保证链表代表的数字无前导 0</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 445&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/add-two-numbers-ii/\">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3588.重排链表",
        "hardRate": "MEDIUM",
        "passRate": "64.68%",
        "problemsUrl": "https://leetcode.cn/problems/LGjMqU/",
        "solutionsUrl": "https://leetcode.cn/problems/LGjMqU/solution",
        "problemsDesc": "<p>给定一个单链表 <code>L</code><em> </em>的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>\n\n<p><code>&nbsp;L<sub>0&nbsp;</sub>&rarr; L<sub>1&nbsp;</sub>&rarr; &hellip; &rarr; L<sub>n-1&nbsp;</sub>&rarr; L<sub>n&nbsp;</sub></code><br />\n请将其重新排列后变为：</p>\n\n<p><code>L<sub>0&nbsp;</sub>&rarr;&nbsp;L<sub>n&nbsp;</sub>&rarr;&nbsp;L<sub>1&nbsp;</sub>&rarr;&nbsp;L<sub>n-1&nbsp;</sub>&rarr;&nbsp;L<sub>2&nbsp;</sub>&rarr;&nbsp;L<sub>n-2&nbsp;</sub>&rarr; &hellip;</code></p>\n\n<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png\" style=\"width: 240px; \" /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4]\n<strong>输出: </strong>[1,4,2,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420320-YUiulT-image.png\" style=\"width: 320px; \" /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4,5]\n<strong>输出: </strong>[1,5,2,4,3]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为 <code>[1, 5 * 10<sup>4</sup>]</code></li>\n\t<li><code>1 &lt;= node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 143&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/reorder-list/\">https://leetcode-cn.com/problems/reorder-list/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3589.回文链表",
        "hardRate": "EASY",
        "passRate": "60.29%",
        "problemsUrl": "https://leetcode.cn/problems/aMhZSa/",
        "solutionsUrl": "https://leetcode.cn/problems/aMhZSa/solution",
        "problemsDesc": "<p>给定一个链表的 <strong>头节点&nbsp;</strong><code>head</code><strong>&nbsp;，</strong>请判断其是否为回文链表。</p>\n\n<p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626421737-LjXceN-image.png\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> head = [1,2,3,3,2,1]\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626422231-wgvnWh-image.png\" style=\"width: 138px; height: 62px;\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> head = [1,2]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表 L 的长度范围为 <code>[1, 10<sup><span style=\"font-size: 9.449999809265137px;\">5</span></sup>]</code></li>\n\t<li><code>0&nbsp;&lt;= node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能否用&nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 234&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3590.扁平化多级双向链表",
        "hardRate": "MEDIUM",
        "passRate": "60.47%",
        "problemsUrl": "https://leetcode.cn/problems/Qv1Da2/",
        "solutionsUrl": "https://leetcode.cn/problems/Qv1Da2/solution",
        "problemsDesc": "<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>\n\n<p>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n<strong>输出：</strong>[1,2,3,7,8,11,12,9,10,4,5,6]\n<strong>解释：\n</strong>\n输入的多级列表如下图所示：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png\" style=\"height: 363px; width: 640px;\" />\n\n扁平化后的链表如下图：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png\" style=\"height: 80px; width: 1100px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,null,3]\n<strong>输出：</strong>[1,3,2]\n<strong>解释：\n\n</strong>输入的多级列表如下图所示：\n\n  1---2---NULL\n  |\n  3---NULL\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>如何表示测试用例中的多级链表？</strong></p>\n\n<p>以 <strong>示例 1</strong> 为例：</p>\n\n<pre>\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL</pre>\n\n<p>序列化其中的每一级之后：</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n</pre>\n\n<p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[null,null,7,8,9,10,null]\n[null,11,12,null]\n</pre>\n\n<p>合并所有序列化结果，并去除末尾的 null 。</p>\n\n<pre>\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点数目不超过 <code>1000</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10^5</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 430&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/\">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3591.循环有序列表的插入",
        "hardRate": "MEDIUM",
        "passRate": "33.54%",
        "problemsUrl": "https://leetcode.cn/problems/4ueAj6/",
        "solutionsUrl": "https://leetcode.cn/problems/4ueAj6/solution",
        "problemsDesc": "<p>给定<strong>循环单调非递减列表</strong>中的一个点，写一个函数向这个列表中插入一个新元素&nbsp;<code>insertVal</code> ，使这个列表仍然是循环升序的。</p>\n\n<p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p>\n\n<p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p>\n\n<p>如果列表为空（给定的节点是 <code>null</code>），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg\" style=\"height: 149px; width: 250px;\" /><br />\n&nbsp;</p>\n\n<pre>\n<strong>输入：</strong>head = [3,4,1], insertVal = 2\n<strong>输出：</strong>[3,4,1,2]\n<strong>解释：</strong>在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。\n\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg\" style=\"height: 149px; width: 250px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [], insertVal = 1\n<strong>输出：</strong>[1]\n<strong>解释：</strong>列表为空（给定的节点是 <code>null</code>），创建一个循环有序列表并返回这个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], insertVal = 0\n<strong>输出：</strong>[1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= Number of Nodes &lt;= 5 * 10^4</code></li>\n\t<li><code><font face=\"monospace\">-10^6 &lt;= Node.val &lt;= 10^6</font></code></li>\n\t<li><code>-10^6 &lt;=&nbsp;insertVal &lt;= 10^6</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 708&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/\">https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3592.O(1) 时间插入、删除和获取随机元素",
        "hardRate": "MEDIUM",
        "passRate": "54.10%",
        "problemsUrl": "https://leetcode.cn/problems/FortPu/",
        "solutionsUrl": "https://leetcode.cn/problems/FortPu/solution",
        "problemsDesc": "<p>设计一个支持在<em>平均&nbsp;</em>时间复杂度 <strong>O(1)</strong>&nbsp;下，执行以下操作的数据结构：</p>\n\n<ul>\n\t<li><code>insert(val)</code>：当元素 <code>val</code> 不存在时返回 <code>true</code>&nbsp;，并向集合中插入该项，否则返回 <code>false</code> 。</li>\n\t<li><code>remove(val)</code>：当元素 <code>val</code> 存在时返回 <code>true</code>&nbsp;，并从集合中移除该项，否则返回 <code>false</code>&nbsp;。</li>\n\t<li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有&nbsp;<strong>相同的概率&nbsp;</strong>被返回。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>inputs = [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>输出: </strong>[null, true, false, true, 2, true, false, 2]\n<strong>解释:\n</strong>RandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合\nrandomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入\n\nrandomSet.remove(2); // 返回 false，表示集合中不存在 2 \n\nrandomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2] \n\nrandomSet.getRandom(); // getRandom 应随机返回 1 或 2 \n  \nrandomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2] \n\nrandomSet.insert(2); // 2 已在集合中，所以返回 false \n\nrandomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n\t<li>最多进行<code> 2 * 10<sup>5</sup></code> 次&nbsp;<code>insert</code> ， <code>remove</code> 和 <code>getRandom</code> 方法调用</li>\n\t<li>当调用&nbsp;<code>getRandom</code> 方法时，集合中至少有一个元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 380&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/insert-delete-getrandom-o1/\">https://leetcode-cn.com/problems/insert-delete-getrandom-o1/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3593.LRU 缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.28%",
        "problemsUrl": "https://leetcode.cn/problems/OrIXps/",
        "solutionsUrl": "https://leetcode.cn/problems/OrIXps/solution",
        "problemsDesc": "<div class=\"title__3Vvk\">\n<p>运用所掌握的数据结构，设计和实现一个&nbsp; <a href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\">LRU (Least Recently Used，最近最少使用) 缓存机制</a> 。</p>\n\n<p>实现 <code>LRUCache</code> 类：</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> 以正整数作为容量&nbsp;<code>capacity</code> 初始化 LRU 缓存</li>\n\t<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code>&nbsp;如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>输出</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>解释</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10000</code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶</strong>：是否可以在&nbsp;<code>O(1)</code> 时间复杂度内完成这两种操作？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 146&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/lru-cache/\">https://leetcode-cn.com/problems/lru-cache/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3594.有效的字母异位词",
        "hardRate": "EASY",
        "passRate": "57.84%",
        "problemsUrl": "https://leetcode.cn/problems/dKk3P7/",
        "solutionsUrl": "https://leetcode.cn/problems/dKk3P7/solution",
        "problemsDesc": "<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断它们是不是一组变位词（字母异位词）。</p>\n\n<p><strong>注意：</strong>若&nbsp;<code><em>s</em></code> 和 <code><em>t</em></code><em>&nbsp;</em>中每个字符出现的次数都相同且<strong>字符顺序不完全相同</strong>，则称&nbsp;<code><em>s</em></code> 和 <code><em>t</em></code><em>&nbsp;</em>互为变位词（字母异位词）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"anagram\", t = \"nagaram\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"rat\", t = \"car\"\n<strong>输出：</strong>false</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\", t = \"a\"\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:&nbsp;</strong>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 242&nbsp;题相似（字母异位词定义不同）：<a href=\"https://leetcode-cn.com/problems/valid-anagram/\">https://leetcode-cn.com/problems/valid-anagram/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3595.字母异位词分组",
        "hardRate": "MEDIUM",
        "passRate": "74.86%",
        "problemsUrl": "https://leetcode.cn/problems/sfvd7V/",
        "solutionsUrl": "https://leetcode.cn/problems/sfvd7V/solution",
        "problemsDesc": "<p>给定一个字符串数组 <code>strs</code> ，将&nbsp;<strong>变位词&nbsp;</strong>组合在一起。 可以按任意顺序返回结果列表。</p>\n\n<p><strong>注意：</strong>若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>\n<strong>输出: </strong>[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;&quot;]</code>\n<strong>输出: </strong>[[&quot;&quot;]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;a&quot;]</code>\n<strong>输出: </strong>[[&quot;a&quot;]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 49&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/group-anagrams/\">https://leetcode-cn.com/problems/group-anagrams/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3596.验证外星语词典",
        "hardRate": "EASY",
        "passRate": "56.55%",
        "problemsUrl": "https://leetcode.cn/problems/lwyVBB/",
        "solutionsUrl": "https://leetcode.cn/problems/lwyVBB/solution",
        "problemsDesc": "<p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>\n\n<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>在该语言的字母表中，&#39;h&#39; 位于 &#39;l&#39; 之前，所以单词序列是按字典序排列的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;\n<strong>输出：</strong>false\n<strong>解释：</strong>在该语言的字母表中，&#39;d&#39; 位于 &#39;l&#39; 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;\n<strong>输出：</strong>false\n<strong>解释：</strong>当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 &#39;l&#39; &gt; &#39;&empty;&#39;，其中 &#39;&empty;&#39; 是空白字符，定义为比任何其他字符都小（<a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F\" target=\"_blank\">更多信息</a>）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>order.length == 26</code></li>\n\t<li>在&nbsp;<code>words[i]</code>&nbsp;和&nbsp;<code>order</code>&nbsp;中的所有字符都是英文小写字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 953&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/verifying-an-alien-dictionary/\">https://leetcode-cn.com/problems/verifying-an-alien-dictionary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3597.最小时间差",
        "hardRate": "MEDIUM",
        "passRate": "66.04%",
        "problemsUrl": "https://leetcode.cn/problems/569nqc/",
        "solutionsUrl": "https://leetcode.cn/problems/569nqc/solution",
        "problemsDesc": "<p>给定一个 24 小时制（小时:分钟 <strong>&quot;HH:MM&quot;</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= timePoints &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>timePoints[i]</code> 格式为 <strong>&quot;HH:MM&quot;</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 539&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/minimum-time-difference/\">https://leetcode-cn.com/problems/minimum-time-difference/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3598.逆波兰表达式求值",
        "hardRate": "MEDIUM",
        "passRate": "54.60%",
        "problemsUrl": "https://leetcode.cn/problems/8Zf90G/",
        "solutionsUrl": "https://leetcode.cn/problems/8Zf90G/solution",
        "problemsDesc": "<p>根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\" target=\"_blank\"> 逆波兰表示法</a>，求该后缀表达式的计算结果。</p>\n\n<p>有效的算符包括&nbsp;<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>整数除法只保留整数部分。</li>\n\t<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n<strong>输出：</strong>9\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n<strong>输出：</strong>6\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n<strong>输出：</strong>22\n<strong>解释：</strong>\n该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code> 要么是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>逆波兰表达式：</strong></p>\n\n<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>\n\n<ul>\n\t<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>\n\t<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>\n</ul>\n\n<p>逆波兰表达式主要有以下两个优点：</p>\n\n<ul>\n\t<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>\n\t<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 150&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3599.行星碰撞",
        "hardRate": "MEDIUM",
        "passRate": "46.10%",
        "problemsUrl": "https://leetcode.cn/problems/XagZNi/",
        "solutionsUrl": "https://leetcode.cn/problems/XagZNi/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。</p>\n\n<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>\n\n<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [5,10,-5]\n<strong>输出：</strong>[5,10]\n<strong>解释：</strong>10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [8,-8]\n<strong>输出：</strong>[]\n<strong>解释：</strong>8 和 -8 碰撞后，两者都发生爆炸。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [10,2,-5]\n<strong>输出：</strong>[10]\n<strong>解释：</strong>2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [-2,-1,1,2]\n<strong>输出：</strong>[-2,-1,1,2]\n<strong>解释：</strong>-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= asteroids.length&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>\n\t<li><code>asteroids[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 735&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/asteroid-collision/\">https://leetcode-cn.com/problems/asteroid-collision/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3600.每日温度",
        "hardRate": "MEDIUM",
        "passRate": "75.47%",
        "problemsUrl": "https://leetcode.cn/problems/iIQa4I/",
        "solutionsUrl": "https://leetcode.cn/problems/iIQa4I/solution",
        "problemsDesc": "<p>请根据每日 <code>气温</code> 列表 <code>temperatures</code>&nbsp;，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用&nbsp;<code>0</code> 来代替。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>temperatures = [73,74,75,71,69,72,76,73]\n<strong>输出：</strong>[1,1,4,2,1,1,0,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>temperatures = [30,40,50,60]\n<strong>输出：</strong>[1,1,1,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>temperatures = [30,60,90]\n<strong>输出：</strong>[1,1,0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>30 &lt;=&nbsp;temperatures[i]&nbsp;&lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 739&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/daily-temperatures/\">https://leetcode-cn.com/problems/daily-temperatures/</a></p>\n",
        "isPlus": false
    }
]