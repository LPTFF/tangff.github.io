[
    {
        "problemsName": " 3601.柱状图中最大的矩形",
        "hardRate": "HARD",
        "passRate": "49.92%",
        "problemsUrl": "https://leetcode.cn/problems/0ynMMM/",
        "solutionsUrl": "https://leetcode.cn/problems/0ynMMM/solution",
        "problemsDesc": "<p>给定非负整数数组 <code>heights</code>&nbsp;，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p>\n\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>heights = [2,1,5,6,2,3]\n<strong>输出：</strong>10\n<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong> heights = [2,4]\n<strong>输出：</strong> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;=10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 84&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3602.最大矩形",
        "hardRate": "HARD",
        "passRate": "58.76%",
        "problemsUrl": "https://leetcode.cn/problems/PLYXKQ/",
        "solutionsUrl": "https://leetcode.cn/problems/PLYXKQ/solution",
        "problemsDesc": "<p>给定一个由&nbsp;<code>0</code> 和 <code>1</code>&nbsp;组成的矩阵 <code>matrix</code>&nbsp;，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>\n\n<p><strong>注意：</strong>此题 <code>matrix</code>&nbsp;输入格式为一维 <code>01</code> 字符串数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"10100\",\"10111\",\"11111\",\"10010\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>最大矩形如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"0\"]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"1\"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"00\"]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[0].length</code></li>\n\t<li><code>0 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 85 题相同（输入参数格式不同）：&nbsp;<a href=\"https://leetcode-cn.com/problems/maximal-rectangle/\">https://leetcode-cn.com/problems/maximal-rectangle/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3603.数据流中的移动平均值",
        "hardRate": "EASY",
        "passRate": "77.29%",
        "problemsUrl": "https://leetcode.cn/problems/qIsx9U/",
        "solutionsUrl": "https://leetcode.cn/problems/qIsx9U/solution",
        "problemsDesc": "<p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p>\n\n<p>实现 <code>MovingAverage</code> 类：</p>\n\n<ul>\n\t<li><code>MovingAverage(int size)</code> 用窗口大小 <code>size</code> 初始化对象。</li>\n\t<li><code>double next(int val)</code>&nbsp;成员函数 <code>next</code>&nbsp;每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 <code>size</code> 个值的移动平均值，即滑动窗口里所有数字的平均值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;MovingAverage&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]\ninputs = [[3], [1], [10], [3], [5]]\n<strong>输出：</strong>\n[null, 1.0, 5.5, 4.66667, 6.0]\n\n<strong>解释：</strong>\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // 返回 1.0 = 1 / 1\nmovingAverage.next(10); // 返回 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= size &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>next</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 346&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/moving-average-from-data-stream/\">https://leetcode-cn.com/problems/moving-average-from-data-stream/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3604.最近的请求次数",
        "hardRate": "EASY",
        "passRate": "81.73%",
        "problemsUrl": "https://leetcode.cn/problems/H8086Q/",
        "solutionsUrl": "https://leetcode.cn/problems/H8086Q/solution",
        "problemsDesc": "<p>写一个&nbsp;<code>RecentCounter</code>&nbsp;类来计算特定时间范围内最近的请求。</p>\n\n<p>请实现 <code>RecentCounter</code> 类：</p>\n\n<ul>\n\t<li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li>\n\t<li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li>\n</ul>\n\n<p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]\ninputs = [[], [1], [100], [3001], [3002]]\n<strong>输出：</strong>\n[null, 1, 2, 3, 3]\n\n<strong>解释：</strong>\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [<strong>1</strong>]，范围是 [-2999,1]，返回 1\nrecentCounter.ping(100);   // requests = [<strong>1</strong>, <strong>100</strong>]，范围是 [-2900,100]，返回 2\nrecentCounter.ping(3001);  // requests = [<strong>1</strong>, <strong>100</strong>, <strong>3001</strong>]，范围是 [1,3001]，返回 3\nrecentCounter.ping(3002);  // requests = [1, <strong>100</strong>, <strong>3001</strong>, <strong>3002</strong>]，范围是 [2,3002]，返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>\n\t<li>至多调用 <code>ping</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 933&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/number-of-recent-calls/\">https://leetcode-cn.com/problems/number-of-recent-calls/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3605.完全二叉树插入器",
        "hardRate": "MEDIUM",
        "passRate": "63.25%",
        "problemsUrl": "https://leetcode.cn/problems/NaqhDT/",
        "solutionsUrl": "https://leetcode.cn/problems/NaqhDT/solution",
        "problemsDesc": "<p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 <code>n</code> 层有 <code>2<sup>n-1</sup></code>&nbsp;个节点）的，并且所有的节点都尽可能地集中在左侧。</p>\n\n<p>设计一个用完全二叉树初始化的数据结构&nbsp;<code>CBTInserter</code>，它支持以下几种操作：</p>\n\n<ul>\n\t<li><code>CBTInserter(TreeNode root)</code>&nbsp;使用根节点为&nbsp;<code>root</code>&nbsp;的给定树初始化该数据结构；</li>\n\t<li><code>CBTInserter.insert(int v)</code>&nbsp; 向树中插入一个新节点，节点类型为 <code>TreeNode</code>，值为 <code>v</code> 。使树保持完全二叉树的状态，<strong>并返回插入的新节点的父节点的值</strong>；</li>\n\t<li><code>CBTInserter.get_root()</code> 将返回树的根节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]\n<strong>输出：</strong>[null,1,[1,2]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]\n<strong>输出：</strong>[null,3,4,[1,2,3,4,5,6,7,8]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>最初给定的树是完全二叉树，且包含&nbsp;<code>1</code>&nbsp;到&nbsp;<code>1000</code>&nbsp;个节点。</li>\n\t<li>每个测试用例最多调用&nbsp;<code>CBTInserter.insert</code>&nbsp; 操作&nbsp;<code>10000</code>&nbsp;次。</li>\n\t<li>给定节点或插入节点的每个值都在&nbsp;<code>0</code>&nbsp;到&nbsp;<code>5000</code>&nbsp;之间。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 919&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/complete-binary-tree-inserter/\">https://leetcode-cn.com/problems/complete-binary-tree-inserter/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3606.在每个树行中找最大值",
        "hardRate": "MEDIUM",
        "passRate": "65.15%",
        "problemsUrl": "https://leetcode.cn/problems/hPov7L/",
        "solutionsUrl": "https://leetcode.cn/problems/hPov7L/solution",
        "problemsDesc": "<p>给定一棵二叉树的根节点&nbsp;<code>root</code> ，请找出该二叉树中每一层的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,3,2,5,3,null,9]\n<strong>输出: </strong>[1,3,9]\n<strong>解释:</strong>\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,2,3]\n<strong>输出: </strong>[1,3]\n<strong>解释:</strong>\n          1\n         / \\\n        2   3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1]\n<strong>输出: </strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,null,2]\n<strong>输出: </strong>[1,2]\n<strong>解释:</strong>      \n&nbsp;          1 \n&nbsp;           \\\n&nbsp;            2     \n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = []\n<strong>输出: </strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 515&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/\">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3607.找树左下角的值",
        "hardRate": "MEDIUM",
        "passRate": "78.56%",
        "problemsUrl": "https://leetcode.cn/problems/LwUNpT/",
        "solutionsUrl": "https://leetcode.cn/problems/LwUNpT/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的&nbsp;<strong>最底层&nbsp;最左边&nbsp;</strong>节点的值。</p>\n\n<p>假设二叉树中至少有一个节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 182px; \" /></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 242px; \" /><strong> </strong></p>\n\n<pre>\n<strong>输入: </strong>[1,2,3,4,null,5,6,null,null,7]\n<strong>输出: </strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 513&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3608.二叉树的右视图",
        "hardRate": "MEDIUM",
        "passRate": "69.77%",
        "problemsUrl": "https://leetcode.cn/problems/WNC0Lk/",
        "solutionsUrl": "https://leetcode.cn/problems/WNC0Lk/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 270px; \" /></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[1,2,3,null,5,null,4]\n<strong>输出:</strong>&nbsp;[1,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[1,null,3]\n<strong>输出:</strong>&nbsp;[1,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[]\n<strong>输出:</strong>&nbsp;[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-100&nbsp;&lt;= Node.val &lt;= 100</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 199&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3609.二叉树剪枝",
        "hardRate": "MEDIUM",
        "passRate": "67.43%",
        "problemsUrl": "https://leetcode.cn/problems/pOCWxh/",
        "solutionsUrl": "https://leetcode.cn/problems/pOCWxh/solution",
        "problemsDesc": "<p>给定一个二叉树 <strong>根节点</strong>&nbsp;<code>root</code>&nbsp;，树的每个节点的值要么是 <code>0</code>，要么是 <code>1</code>。请剪除该二叉树中所有节点的值为 <code>0</code> 的子树。</p>\n\n<p>节点 <code>node</code> 的子树为&nbsp;<code>node</code> 本身，以及所有 <code>node</code>&nbsp;的后代。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,null,0,0,1]\n<strong>输出: </strong>[1,null,0,null,1] \n<strong>解释:</strong> \n只有红色节点满足条件&ldquo;所有不包含 1 的子树&rdquo;。\n右图为返回的答案。\n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width:450px\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,0,1,0,0,0,1]\n<strong>输出: </strong>[1,null,1,null,1]\n<strong>解释:</strong> \n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width:450px\" />\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,1,0,1,1,0,1,0]\n<strong>输出: </strong>[1,1,0,1,1,null,1]\n<strong>解释:</strong> \n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width:450px\" />\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,200]</code></li>\n\t<li>二叉树节点的值只会是 <code>0</code> 或 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 814&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-pruning/\">https://leetcode-cn.com/problems/binary-tree-pruning/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3610.二叉树的序列化与反序列化",
        "hardRate": "HARD",
        "passRate": "67.13%",
        "problemsUrl": "https://leetcode.cn/problems/h54YBf/",
        "solutionsUrl": "https://leetcode.cn/problems/h54YBf/solution",
        "problemsDesc": "<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&nbsp;<a href=\"/faq/#binary-tree\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。</li>\n\t<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 297&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3611.求根节点到叶节点数字之和",
        "hardRate": "MEDIUM",
        "passRate": "73.38%",
        "problemsUrl": "https://leetcode.cn/problems/3Etpl5/",
        "solutionsUrl": "https://leetcode.cn/problems/3Etpl5/solution",
        "problemsDesc": "<p>给定一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每条从根节点到叶节点的路径都代表一个数字：</p>\n\n<ul>\n\t<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>\n</ul>\n\n<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>\n\n<p><strong>叶节点</strong> 是指没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>\n从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>\n因此，数字总和 = 12 + 13 = <code>25</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [4,9,0,5,1]\n<strong>输出：</strong>1026\n<strong>解释：</strong>\n从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 495\n从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 491\n从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = <code>1026</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>树的深度不超过 <code>10</code></li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 129&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3612.路径总和 III",
        "hardRate": "MEDIUM",
        "passRate": "49.08%",
        "problemsUrl": "https://leetcode.cn/problems/6eUYwP/",
        "solutionsUrl": "https://leetcode.cn/problems/6eUYwP/solution",
        "problemsDesc": "<p>给定一个二叉树的根节点 <code>root</code>&nbsp;，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>\n\n<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style=\"width: 452px; \" /></p>\n\n<pre>\n<strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>和等于 8 的路径有 3 条，如图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-10<sup><span style=\"font-size: 9.449999809265137px;\">9</span></sup>&nbsp;&lt;= Node.val &lt;= 10<sup><span style=\"font-size: 9.449999809265137px;\">9</span></sup></code>&nbsp;</li>\n\t<li><code>-1000&nbsp;&lt;= targetSum&nbsp;&lt;= 1000</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 437&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/path-sum-iii/\">https://leetcode-cn.com/problems/path-sum-iii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3613.二叉树中的最大路径和",
        "hardRate": "HARD",
        "passRate": "48.46%",
        "problemsUrl": "https://leetcode.cn/problems/jC7MId/",
        "solutionsUrl": "https://leetcode.cn/problems/jC7MId/solution",
        "problemsDesc": "<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>\n\n<p><strong>路径和</strong> 是路径中各节点值的总和。</p>\n\n<p>给定一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong>，即所有路径上节点值之和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [-10,9,20,null,null,15,7]\n<strong>输出：</strong>42\n<strong>解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 124&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3614.递增顺序搜索树",
        "hardRate": "EASY",
        "passRate": "73.68%",
        "problemsUrl": "https://leetcode.cn/problems/NYBBNL/",
        "solutionsUrl": "https://leetcode.cn/problems/NYBBNL/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树，请&nbsp;<strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg\" style=\"width: 600px; height: 350px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg\" style=\"width: 300px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,1,7]\n<strong>输出：</strong>[1,null,5,null,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的取值范围是 <code>[1, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 897&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/increasing-order-search-tree/\">https://leetcode-cn.com/problems/increasing-order-search-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3615.二叉搜索树中的中序后继",
        "hardRate": "MEDIUM",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/P5rCT8/",
        "solutionsUrl": "https://leetcode.cn/problems/P5rCT8/solution",
        "problemsDesc": "<p>给定一棵二叉搜索树和其中的一个节点 <code>p</code> ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 <code>null</code> 。</p>\n\n<p>节点&nbsp;<code>p</code>&nbsp;的后继是值比&nbsp;<code>p.val</code>&nbsp;大的节点中键值最小的节点，即按中序遍历的顺序节点 <code>p</code> 的下一个节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_1.PNG\" style=\"height: 117px; width: 122px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3], p = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_2.PNG\" style=\"height: 229px; width: 246px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,null,1], p = 6\n<strong>输出：</strong>null\n<strong>解释：</strong>因为给出的节点没有中序后继，所以答案就返回 <code>null 了。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>4</sup>]</code> 内。</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>树中各节点的值均保证唯一。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 285&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/inorder-successor-in-bst/\">https://leetcode-cn.com/problems/inorder-successor-in-bst/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3616.把二叉搜索树转换为累加树",
        "hardRate": "MEDIUM",
        "passRate": "85.09%",
        "problemsUrl": "https://leetcode.cn/problems/w6cpku/",
        "solutionsUrl": "https://leetcode.cn/problems/w6cpku/solution",
        "problemsDesc": "<p><span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">给定一个二叉搜索树，请将它的每个</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">的值替换成树中大于或者等于该</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值的所有</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值之和。</font></span></span></span></span></p>\n\n<p style=\"margin:0pt 0pt 0.0001pt; text-align:justify\">&nbsp;</p>\n\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height: 364px; width: 534px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root<strong> </strong>=<strong> </strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,0,2]\n<strong>输出：</strong>[3,3,2]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [3,2,4,1]\n<strong>输出：</strong>[7,9,4,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>\n\t<li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n\t<li>给定的树为二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：</p>\n\n<ul>\n\t<li>本题与主站 538&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></li>\n\t<li>本题与主站 1038&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3617.二叉搜索树迭代器",
        "hardRate": "MEDIUM",
        "passRate": "85.14%",
        "problemsUrl": "https://leetcode.cn/problems/kTOapQ/",
        "solutionsUrl": "https://leetcode.cn/problems/kTOapQ/solution",
        "problemsDesc": "<p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>\n\t<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>\n\t<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>\n</ul>\n\n<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>\n</div>\n</div>\n\n<p>可以假设&nbsp;<code>next()</code>&nbsp;调用总是有效的，也就是说，当调用 <code>next()</code>&nbsp;时，BST 的中序遍历中至少存在一个下一个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" /></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\ninputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>输出：</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>解释：</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // 返回 3\nbSTIterator.next();    // 返回 7\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 9\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 15\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 20\nbSTIterator.hasNext(); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>5</sup></code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 173&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">https://leetcode-cn.com/problems/binary-search-tree-iterator/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3618.两数之和 IV - 输入二叉搜索树",
        "hardRate": "EASY",
        "passRate": "73.83%",
        "problemsUrl": "https://leetcode.cn/problems/opLdQZ/",
        "solutionsUrl": "https://leetcode.cn/problems/opLdQZ/solution",
        "problemsDesc": "<p>给定一个二叉搜索树的 <strong>根节点</strong> <code>root</code>&nbsp;和一个整数 <code>k</code> , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 <code>k</code> 。假设二叉搜索树中节点的值均唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>root =<strong> </strong>[8,6,10,5,7,9,11], k = 12\n<strong>输出: </strong>true\n<strong>解释: </strong>节点 5 和节点 7 之和等于 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root =<strong> </strong>[8,6,10,5,7,9,11], k = 22\n<strong>输出: </strong>false\n<strong>解释: </strong>不存在两个节点值之和为 22 的节点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是&nbsp;&nbsp;<code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>root</code>&nbsp;为二叉搜索树</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 653 题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\">https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3619.存在重复元素 III",
        "hardRate": "MEDIUM",
        "passRate": "34.08%",
        "problemsUrl": "https://leetcode.cn/problems/7WqeDu/",
        "solutionsUrl": "https://leetcode.cn/problems/7WqeDu/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数&nbsp;<code>k</code> 和 <code>t</code> 。请你判断是否存在 <b>两个不同下标</b> <code>i</code> 和 <code>j</code>，使得&nbsp;<code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code><em> </em>。</p>\n\n<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k<em> </em>= 3, t = 0\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,1,1], k<em> </em>=<em> </em>1, t = 2\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,9,1,5,9], k = 2, t = 3\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= t &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 220&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/contains-duplicate-iii/\">https://leetcode-cn.com/problems/contains-duplicate-iii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3620.我的日程安排表 I",
        "hardRate": "MEDIUM",
        "passRate": "61.08%",
        "problemsUrl": "https://leetcode.cn/problems/fi9suh/",
        "solutionsUrl": "https://leetcode.cn/problems/fi9suh/solution",
        "problemsDesc": "<p>请实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 <code>true</code>。否则，返回 <code>false</code>&nbsp;并且不要将该日程安排添加到日历中。</p>\n\n<p>请按照以下步骤调用 <code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:\n</strong>[&quot;MyCalendar&quot;,&quot;book&quot;,&quot;book&quot;,&quot;book&quot;]\n[[],[10,20],[15,25],[20,30]]\n<strong>输出:</strong> [null,true,false,true]\n<strong>解释:</strong> \nMyCalendar myCalendar = new MyCalendar();\nMyCalendar.book(10, 20); // returns true \nMyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了\nMyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>1000</code>次。</li>\n\t<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 729&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/my-calendar-i/\">https://leetcode-cn.com/problems/my-calendar-i/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3621.数据流中的第 K 大元素",
        "hardRate": "EASY",
        "passRate": "62.39%",
        "problemsUrl": "https://leetcode.cn/problems/jBjn9C/",
        "solutionsUrl": "https://leetcode.cn/problems/jBjn9C/solution",
        "problemsDesc": "<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>\n\n<p>请实现 <code>KthLargest</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>\n\t<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>输出：</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>解释：</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>\n\t<li>最多调用 <code>add</code> 方法 <code>10<sup>4</sup></code> 次</li>\n\t<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 703&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/\">https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3622.前 K 个高频元素",
        "hardRate": "MEDIUM",
        "passRate": "67.99%",
        "problemsUrl": "https://leetcode.cn/problems/g5c51o/",
        "solutionsUrl": "https://leetcode.cn/problems/g5c51o/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code>&nbsp;，请返回其中出现频率前 <code>k</code> 高的元素。可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2\n<strong>输出: </strong>[1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1], k = 1\n<strong>输出: </strong>[1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>\n\t<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code><em>&nbsp;</em>是数组大小。</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 347&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/top-k-frequent-elements/\">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3623.查找和最小的 K 对数字",
        "hardRate": "MEDIUM",
        "passRate": "53.08%",
        "problemsUrl": "https://leetcode.cn/problems/qn8gGX/",
        "solutionsUrl": "https://leetcode.cn/problems/qn8gGX/solution",
        "problemsDesc": "<p>给定两个以升序排列的整数数组 <code>nums1</code> 和<strong> </strong><code>nums2</code><strong>&nbsp;</strong>,&nbsp;以及一个整数 <code>k</code><strong>&nbsp;</strong>。</p>\n\n<p>定义一对值&nbsp;<code>(u,v)</code>，其中第一个元素来自&nbsp;<code>nums1</code>，第二个元素来自 <code>nums2</code><strong>&nbsp;</strong>。</p>\n\n<p>请找到和最小的 <code>k</code>&nbsp;个数对&nbsp;<code>(u<sub>1</sub>,v<sub>1</sub>)</code>, <code>&nbsp;(u<sub>2</sub>,v<sub>2</sub>)</code> &nbsp;... &nbsp;<code>(u<sub>k</sub>,v<sub>k</sub>)</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n<strong>输出:</strong> [1,2],[1,4],[1,6]\n<strong>解释: </strong>返回序列中的前 3 对数：\n    [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n<strong>输出: </strong>[1,1],[1,1]\n<strong>解释: </strong>返回序列中的前 2 对数：\n&nbsp;    [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>nums1 = [1,2], nums2 = [3], k = 3 \n<strong>输出:</strong> [1,3],[2,3]\n<strong>解释: </strong>也可能序列中所有的数对都被返回:[1,3],[2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code>, <code>nums2</code> 均为升序排列</li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 373&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/\">https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3624.实现 Trie (前缀树)",
        "hardRate": "MEDIUM",
        "passRate": "75.23%",
        "problemsUrl": "https://leetcode.cn/problems/QC3q1f/",
        "solutionsUrl": "https://leetcode.cn/problems/QC3q1f/solution",
        "problemsDesc": "<p><strong><a href=\"https://baike.baidu.com/item/字典树/9825209?fr=aladdin\" target=\"_blank\">Trie</a></strong>（发音类似 &quot;try&quot;）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>\n\n<p>请你实现 Trie 类：</p>\n\n<ul>\n\t<li><code>Trie()</code> 初始化前缀树对象。</li>\n\t<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>\n\t<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串&nbsp;<code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\ninputs = [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]\ninputs = [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]\n<strong>输出</strong>\n[null, null, true, false, true, null, true]\n\n<strong>解释</strong>\nTrie trie = new Trie();\ntrie.insert(&quot;apple&quot;);\ntrie.search(&quot;apple&quot;);   // 返回 True\ntrie.search(&quot;app&quot;);     // 返回 False\ntrie.startsWith(&quot;app&quot;); // 返回 True\ntrie.insert(&quot;app&quot;);\ntrie.search(&quot;app&quot;);     // 返回 True\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n\t<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 208 题相同：<a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree/\">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3625.单词替换",
        "hardRate": "MEDIUM",
        "passRate": "71.55%",
        "problemsUrl": "https://leetcode.cn/problems/UhWRSj/",
        "solutionsUrl": "https://leetcode.cn/problems/UhWRSj/solution",
        "problemsDesc": "<p>在英语中，有一个叫做&nbsp;<code>词根(root)</code> 的概念，它可以跟着其他一些词组成另一个较长的单词&mdash;&mdash;我们称这个词为&nbsp;<code>继承词(successor)</code>。例如，词根<code>an</code>，跟随着单词&nbsp;<code>other</code>(其他)，可以形成新的单词&nbsp;<code>another</code>(另一个)。</p>\n\n<p>现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有<code>继承词</code>用<code>词根</code>替换掉。如果<code>继承词</code>有许多可以形成它的<code>词根</code>，则用最短的词根替换它。</p>\n\n<p>需要输出替换之后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;\n<strong>输出：</strong>&quot;the cat was rat by the bat&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], sentence = &quot;aadsfasf absbs bbab cadsfafs&quot;\n<strong>输出：</strong>&quot;a a b c&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;], sentence = &quot;a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa&quot;\n<strong>输出：</strong>&quot;a a a a a a a a bbb baba a&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;catt&quot;,&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;\n<strong>输出：</strong>&quot;the cat was rat by the bat&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;ac&quot;,&quot;ab&quot;], sentence = &quot;it is abnormal that this solution is accepted&quot;\n<strong>输出：</strong>&quot;it is ab that this solution is ac&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dictionary.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;仅由小写字母组成。</li>\n\t<li><code>1 &lt;= sentence.length &lt;= 10^6</code></li>\n\t<li><code>sentence</code>&nbsp;仅由小写字母和空格组成。</li>\n\t<li><code>sentence</code> 中单词的总量在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中每个单词的长度在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中单词之间由一个空格隔开。</li>\n\t<li><code>sentence</code>&nbsp;没有前导或尾随空格。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 648&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/replace-words/\">https://leetcode-cn.com/problems/replace-words/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3626.实现一个魔法字典",
        "hardRate": "MEDIUM",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/US1pGT/",
        "solutionsUrl": "https://leetcode.cn/problems/US1pGT/solution",
        "problemsDesc": "<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p>\n\n<p>实现 <code>MagicDictionary</code> 类：</p>\n\n<ul>\n\t<li><code>MagicDictionary()</code> 初始化对象</li>\n\t<li><code>void buildDict(String[]&nbsp;dictionary)</code> 使用字符串数组&nbsp;<code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li>\n\t<li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中<strong> 一个 </strong>字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\ninputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]\ninputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]\n<strong>输出</strong>\n[null, null, false, true, false, false]\n\n<strong>解释</strong>\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);\nmagicDictionary.search(&quot;hello&quot;); // 返回 False\nmagicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#39;h&#39; 替换为 &#39;e&#39; 可以匹配 &quot;hello&quot; ，所以返回 True\nmagicDictionary.search(&quot;hell&quot;); // 返回 False\nmagicDictionary.search(&quot;leetcoded&quot;); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;=&nbsp;searchWord.length &lt;= 100</code></li>\n\t<li><code>searchWord</code> 仅由小写英文字母组成</li>\n\t<li><code>buildDict</code> 仅在 <code>search</code> 之前调用一次</li>\n\t<li>最多调用 <code>100</code> 次 <code>search</code></li>\n</ul>\n</div>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 676&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/implement-magic-dictionary/\">https://leetcode-cn.com/problems/implement-magic-dictionary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3627.单词的压缩编码",
        "hardRate": "MEDIUM",
        "passRate": "63.20%",
        "problemsUrl": "https://leetcode.cn/problems/iSwD2y/",
        "solutionsUrl": "https://leetcode.cn/problems/iSwD2y/solution",
        "problemsDesc": "<p>单词数组&nbsp;<code>words</code> 的 <strong>有效编码</strong> 由任意助记字符串 <code>s</code> 和下标数组 <code>indices</code> 组成，且满足：</p>\n\n<ul>\n\t<li><code>words.length == indices.length</code></li>\n\t<li>助记字符串 <code>s</code> 以 <code>&#39;#&#39;</code> 字符结尾</li>\n\t<li>对于每个下标 <code>indices[i]</code> ，<code>s</code> 的一个从 <code>indices[i]</code> 开始、到下一个 <code>&#39;#&#39;</code> 字符结束（但不包括 <code>&#39;#&#39;</code>）的 <strong>子字符串</strong> 恰好与 <code>words[i]</code> 相等</li>\n</ul>\n\n<p>给定一个单词数组&nbsp;<code>words</code> ，返回成功对 <code>words</code> 进行编码的最小助记字符串 <code>s</code> 的长度 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]\n<strong>输出：</strong>10\n<strong>解释：</strong>一组有效编码为 s = <code>&quot;time#bell#&quot; 和 indices = [0, 2, 5</code>] 。\nwords[0] = &quot;time&quot; ，s 开始于 indices[0] = 0 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;<strong>time</strong>#bell#&quot;\nwords[1] = &quot;me&quot; ，s 开始于 indices[1] = 2 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;ti<strong>me</strong>#bell#&quot;\nwords[2] = &quot;bell&quot; ，s 开始于 indices[2] = 5 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#<strong>bell</strong>#&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;t&quot;]\n<strong>输出：</strong>2\n<strong>解释：</strong>一组有效编码为 s = &quot;t#&quot; 和 indices = [0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 7</code></li>\n\t<li><code>words[i]</code> 仅由小写字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 820&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/short-encoding-of-words/\">https://leetcode-cn.com/problems/short-encoding-of-words/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3628. 键值映射",
        "hardRate": "MEDIUM",
        "passRate": "64.47%",
        "problemsUrl": "https://leetcode.cn/problems/z1R5dt/",
        "solutionsUrl": "https://leetcode.cn/problems/z1R5dt/solution",
        "problemsDesc": "<p>实现一个 <code>MapSum</code> 类，支持两个方法，<code>insert</code>&nbsp;和&nbsp;<code>sum</code>：</p>\n\n<ul>\n\t<li><code>MapSum()</code> 初始化 <code>MapSum</code> 对象</li>\n\t<li><code>void insert(String key, int val)</code> 插入 <code>key-val</code> 键值对，字符串表示键 <code>key</code> ，整数表示值 <code>val</code> 。如果键 <code>key</code> 已经存在，那么原来的键值对将被替代成新的键值对。</li>\n\t<li><code>int sum(string prefix)</code> 返回所有以该前缀 <code>prefix</code> 开头的键 <code>key</code> 的值的总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]\ninputs = [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]\n<strong>输出：</strong>\n[null, null, 3, null, 5]\n\n<strong>解释：</strong>\nMapSum mapSum = new MapSum();\nmapSum.insert(&quot;apple&quot;, 3);  \nmapSum.sum(&quot;ap&quot;);           // return 3 (<u>ap</u>ple = 3)\nmapSum.insert(&quot;app&quot;, 2);    \nmapSum.sum(&quot;ap&quot;);           // return 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>\n\t<li><code>key</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= val &lt;= 1000</code></li>\n\t<li>最多调用 <code>50</code> 次 <code>insert</code> 和 <code>sum</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 677&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/map-sum-pairs/\">https://leetcode-cn.com/problems/map-sum-pairs/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3629.数组中两个数的最大异或值",
        "hardRate": "MEDIUM",
        "passRate": "65.08%",
        "problemsUrl": "https://leetcode.cn/problems/ms70jA/",
        "solutionsUrl": "https://leetcode.cn/problems/ms70jA/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>nums</code> ，返回<em> </em><code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 &le; i &le; j &lt; n</code> 。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,10,5,25,2,8]\n<strong>输出：</strong>28\n<strong>解释：</strong>最大运算结果是 5 XOR 25 = 28.</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [8,10,2]\n<strong>输出：</strong>10\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n<strong>输出：</strong>127\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以在 <code>O(n)</code> 的时间解决这个问题吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 421&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/\">https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3630.搜索插入位置",
        "hardRate": "EASY",
        "passRate": "48.62%",
        "problemsUrl": "https://leetcode.cn/problems/N6YdxV/",
        "solutionsUrl": "https://leetcode.cn/problems/N6YdxV/solution",
        "problemsDesc": "<p>给定一个排序的整数数组 <code>nums</code>&nbsp;和一个整数目标值<code> target</code> ，请在数组中找到&nbsp;<code>target&nbsp;</code>，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 5\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 2\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 7\n<strong>输出:</strong> 4\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 0\n<strong>输出:</strong> 0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1], target = 0\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 为<strong>无重复元素</strong>的<strong>升序</strong>排列数组</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 35&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/search-insert-position/\">https://leetcode-cn.com/problems/search-insert-position/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3631.山脉数组的峰顶索引",
        "hardRate": "EASY",
        "passRate": "71.17%",
        "problemsUrl": "https://leetcode.cn/problems/B1IidL/",
        "solutionsUrl": "https://leetcode.cn/problems/B1IidL/solution",
        "problemsDesc": "<p>符合下列属性的数组 <code>arr</code> 称为 <strong>山峰数组</strong>（<strong>山脉数组）</strong> ：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在 <code>i</code>（<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>）使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给定由整数组成的山峰数组 <code>arr</code> ，返回任何满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code>&nbsp;，即山峰顶部。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,5,4,2]\n<strong>输出：2</strong>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,5,2]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,4,5,1]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [24,69,100,99,79,78,67,36,26,19]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>题目数据保证 <code>arr</code> 是一个山脉数组</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>很容易想到时间复杂度 <code>O(n)</code> 的解决方案，你可以设计一个 <code>O(log(n))</code> 的解决方案吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 852&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3632.有序数组中的单一元素",
        "hardRate": "MEDIUM",
        "passRate": "60.69%",
        "problemsUrl": "https://leetcode.cn/problems/skFtm2/",
        "solutionsUrl": "https://leetcode.cn/problems/skFtm2/solution",
        "problemsDesc": "<p>给定一个只包含整数的有序数组 <code>nums</code>&nbsp;，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2,3,3,4,4,8,8]\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums =  [3,3,7,7,10,11,11]\n<strong>输出:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>采用的方案可以在 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度中运行吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 540&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/single-element-in-a-sorted-array/\">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3633.按权重随机选择",
        "hardRate": "MEDIUM",
        "passRate": "50.41%",
        "problemsUrl": "https://leetcode.cn/problems/cuyjEf/",
        "solutionsUrl": "https://leetcode.cn/problems/cuyjEf/solution",
        "problemsDesc": "<p>给定一个正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code>&nbsp;代表下标 <code>i</code>&nbsp;的权重（下标从 <code>0</code> 开始），请写一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以随机地获取下标 <code>i</code>，选取下标 <code>i</code>&nbsp;的概率与&nbsp;<code>w[i]</code>&nbsp;成正比。</p>\n\n<ol>\n</ol>\n\n<p>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3)&nbsp;= 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3)&nbsp;= 0.75</code>（即，75%）。</p>\n\n<p>也就是说，选取下标 <code>i</code> 的概率为 <code>w[i] / sum(w)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;Solution&quot;,&quot;pickIndex&quot;]\ninputs = [[[1]],[]]\n<strong>输出：</strong>\n[null,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]\ninputs = [[[1,3]],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,1,1,1,1,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= w.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10^5</code></li>\n\t<li><code>pickIndex</code>&nbsp;将被调用不超过&nbsp;<code>10000</code>&nbsp;次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 528&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/random-pick-with-weight/\">https://leetcode-cn.com/problems/random-pick-with-weight/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3634.x 的平方根",
        "hardRate": "EASY",
        "passRate": "42.73%",
        "problemsUrl": "https://leetcode.cn/problems/jJ0w9p/",
        "solutionsUrl": "https://leetcode.cn/problems/jJ0w9p/solution",
        "problemsDesc": "<p>给定一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的平方根，即实现&nbsp;<code>int sqrt(int x)</code>&nbsp;函数。</p>\n\n<p>正数的平方根有两个，只输出其中的正数平方根。</p>\n\n<p>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> x = 4\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> x = 8\n<strong>输出:</strong> 2\n<strong>解释:</strong> 8 的平方根是 2.82842...，由于小数部分将被舍去，所以返回 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><meta charset=\"UTF-8\" /><code>0 &lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 69&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/sqrtx/\">https://leetcode-cn.com/problems/sqrtx/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3635.爱吃香蕉的狒狒",
        "hardRate": "MEDIUM",
        "passRate": "53.43%",
        "problemsUrl": "https://leetcode.cn/problems/nZZqjQ/",
        "solutionsUrl": "https://leetcode.cn/problems/nZZqjQ/solution",
        "problemsDesc": "<p>狒狒喜欢吃香蕉。这里有&nbsp;<code>N</code>&nbsp;堆香蕉，第 <code>i</code> 堆中有&nbsp;<code>piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在&nbsp;<code>H</code>&nbsp;小时后回来。</p>\n\n<p>狒狒可以决定她吃香蕉的速度&nbsp;<code>K</code>&nbsp;（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>K</code> 根。如果这堆香蕉少于 <code>K</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。&nbsp;&nbsp;</p>\n\n<p>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>\n\n<p>返回她可以在 <code>H</code> 小时内吃掉所有香蕉的最小速度 <code>K</code>（<code>K</code> 为整数）。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>piles = [3,6,7,11], H = 8\n<strong>输出: </strong>4\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入: </strong>piles = [30,11,23,4,20], H = 5\n<strong>输出: </strong>30\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入: </strong>piles = [30,11,23,4,20], H = 6\n<strong>输出: </strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10^4</code></li>\n\t<li><code>piles.length &lt;= H &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10^9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 875&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/koko-eating-bananas/\">https://leetcode-cn.com/problems/koko-eating-bananas/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3636.合并区间",
        "hardRate": "MEDIUM",
        "passRate": "55.90%",
        "problemsUrl": "https://leetcode.cn/problems/SsGoHC/",
        "solutionsUrl": "https://leetcode.cn/problems/SsGoHC/solution",
        "problemsDesc": "<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>输出：</strong>[[1,6],[8,10],[15,18]]\n<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[4,5]]\n<strong>输出：</strong>[[1,5]]\n<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 56&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/merge-intervals/\">https://leetcode-cn.com/problems/merge-intervals/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3637.数组的相对排序",
        "hardRate": "EASY",
        "passRate": "69.33%",
        "problemsUrl": "https://leetcode.cn/problems/0H97ZC/",
        "solutionsUrl": "https://leetcode.cn/problems/0H97ZC/solution",
        "problemsDesc": "<p>给定两个数组，<code>arr1</code> 和&nbsp;<code>arr2</code>，</p>\n\n<ul>\n\t<li><code>arr2</code>&nbsp;中的元素各不相同</li>\n\t<li><code>arr2</code> 中的每个元素都出现在&nbsp;<code>arr1</code>&nbsp;中</li>\n</ul>\n\n<p>对 <code>arr1</code>&nbsp;中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和&nbsp;<code>arr2</code>&nbsp;中的相对顺序相同。未在&nbsp;<code>arr2</code>&nbsp;中出现过的元素需要按照升序放在&nbsp;<code>arr1</code>&nbsp;的末尾。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\n<strong>输出：</strong>[2,2,2,1,4,3,3,9,6,7,19]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>\n\t<li><code>arr2</code>&nbsp;中的元素&nbsp;<code>arr2[i]</code>&nbsp;各不相同</li>\n\t<li><code>arr2</code> 中的每个元素&nbsp;<code>arr2[i]</code>&nbsp;都出现在&nbsp;<code>arr1</code>&nbsp;中</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 1122&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/relative-sort-array/\">https://leetcode-cn.com/problems/relative-sort-array/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3638.数组中的第 K 个最大元素",
        "hardRate": "MEDIUM",
        "passRate": "65.04%",
        "problemsUrl": "https://leetcode.cn/problems/xx4gT2/",
        "solutionsUrl": "https://leetcode.cn/problems/xx4gT2/solution",
        "problemsDesc": "<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p>\n\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,5,6,4], k = 2\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,3,1,2,4,5,5,6], k = 4\n<strong>输出：</strong>4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示： </strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 215&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3639.排序链表",
        "hardRate": "MEDIUM",
        "passRate": "61.28%",
        "problemsUrl": "https://leetcode.cn/problems/7WHec2/",
        "solutionsUrl": "https://leetcode.cn/problems/7WHec2/solution",
        "problemsDesc": "<p>给定链表的头结点&nbsp;<code>head</code>&nbsp;，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 302px; \" /></p>\n\n<pre>\n<strong>输入：</strong>head = [4,2,1,3]\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 402px; \" /></p>\n\n<pre>\n<strong>输入：</strong>head = [-1,5,3,4,0]\n<strong>输出：</strong>[-1,0,3,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li>链表中节点的数目在范围&nbsp;<code>[0, 5 * 10<sup>4</sup>]</code>&nbsp;内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b>你可以在&nbsp;<code>O(n&nbsp;log&nbsp;n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 148&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/sort-list/\">https://leetcode-cn.com/problems/sort-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3640.合并 K 个升序链表",
        "hardRate": "HARD",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/vvXgSW/",
        "solutionsUrl": "https://leetcode.cn/problems/vvXgSW/solution",
        "problemsDesc": "<p>给定一个链表数组，每个链表都已经按升序排列。</p>\n\n<p>请将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>输出：</strong>[1,1,2,3,4,4,5,6]\n<strong>解释：</strong>链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lists = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>lists = [[]]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n\t<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 23&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3641.子集",
        "hardRate": "MEDIUM",
        "passRate": "84.50%",
        "problemsUrl": "https://leetcode.cn/problems/TVdhkn/",
        "solutionsUrl": "https://leetcode.cn/problems/TVdhkn/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>\n\n<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 78&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/subsets/\">https://leetcode-cn.com/problems/subsets/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3642.组合",
        "hardRate": "MEDIUM",
        "passRate": "81.52%",
        "problemsUrl": "https://leetcode.cn/problems/uUsW3B/",
        "solutionsUrl": "https://leetcode.cn/problems/uUsW3B/solution",
        "problemsDesc": "<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;n = 4, k = 2\n<strong>输出:</strong>\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;n = 1, k = 1\n<strong>输出: </strong>[[1]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 77&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/combinations/\">https://leetcode-cn.com/problems/combinations/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3643.组合总和",
        "hardRate": "MEDIUM",
        "passRate": "79.63%",
        "problemsUrl": "https://leetcode.cn/problems/Ygoe9J/",
        "solutionsUrl": "https://leetcode.cn/problems/Ygoe9J/solution",
        "problemsDesc": "<p>给定一个<strong>无重复元素</strong>的正整数数组&nbsp;<code>candidates</code>&nbsp;和一个正整数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为目标数&nbsp;<code>target</code>&nbsp;的唯一组合。</p>\n\n<p><code>candidates</code>&nbsp;中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。&nbsp;</p>\n\n<p>对于给定的输入，保证和为&nbsp;<code>target</code> 的唯一组合数少于 <code>150</code> 个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2,3,6,7], target = 7&lt;\n<strong>输出: </strong>[[7],[2,2,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2,3,5], target = 8\n<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2], target = 1\n<strong>输出: </strong>[]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [1], target = 1\n<strong>输出: </strong>[[1]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [1], target = 2\n<strong>输出: </strong>[[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>\n\t<li><code>candidate</code> 中的每个元素都是独一无二的。</li>\n\t<li><code>1 &lt;= target &lt;= 500</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 39&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/combination-sum/\">https://leetcode-cn.com/problems/combination-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3644.组合总和 II",
        "hardRate": "MEDIUM",
        "passRate": "65.30%",
        "problemsUrl": "https://leetcode.cn/problems/4sjJUc/",
        "solutionsUrl": "https://leetcode.cn/problems/4sjJUc/solution",
        "problemsDesc": "<p>给定一个可能有重复数字的整数数组&nbsp;<code>candidates</code>&nbsp;和一个目标数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为&nbsp;<code>target</code>&nbsp;的组合。</p>\n\n<p><code>candidates</code>&nbsp;中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = [10,1,2,7,6,1,5], target = 8\n<strong>输出：</strong>\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = [2,5,2,1,2], target = 5\n<strong>输出：</strong>\n[\n[1,2,2],\n[5]\n]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 40&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\">https://leetcode-cn.com/problems/combination-sum-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3645.全排列",
        "hardRate": "MEDIUM",
        "passRate": "83.61%",
        "problemsUrl": "https://leetcode.cn/problems/VvJkup/",
        "solutionsUrl": "https://leetcode.cn/problems/VvJkup/solution",
        "problemsDesc": "<p>给定一个不含重复数字的整数数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[[0,1],[1,0]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 46&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/permutations/\">https://leetcode-cn.com/problems/permutations/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3646.全排列 II ",
        "hardRate": "MEDIUM",
        "passRate": "68.73%",
        "problemsUrl": "https://leetcode.cn/problems/7p8L0Z/",
        "solutionsUrl": "https://leetcode.cn/problems/7p8L0Z/solution",
        "problemsDesc": "<p>给定一个可包含重复数字的整数集合&nbsp;<code>nums</code> ，<strong>按任意顺序</strong> 返回它所有不重复的全排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 8</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 47&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/permutations-ii/\">https://leetcode-cn.com/problems/permutations-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3647.括号生成",
        "hardRate": "MEDIUM",
        "passRate": "84.20%",
        "problemsUrl": "https://leetcode.cn/problems/IDBivT/",
        "solutionsUrl": "https://leetcode.cn/problems/IDBivT/solution",
        "problemsDesc": "<p>正整数&nbsp;<code>n</code>&nbsp;代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[&quot;()&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 22&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/generate-parentheses/\">https://leetcode-cn.com/problems/generate-parentheses/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3648.分割回文串",
        "hardRate": "MEDIUM",
        "passRate": "75.36%",
        "problemsUrl": "https://leetcode.cn/problems/M99OJA/",
        "solutionsUrl": "https://leetcode.cn/problems/M99OJA/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> ，返回 s 所有可能的分割方案。</p>\n\n<p><meta charset=\"UTF-8\" /><strong>回文串</strong>&nbsp;是正着读和反着读都一样的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;google&quot;\n<strong>输出：</strong>[[&quot;g&quot;,&quot;o&quot;,&quot;o&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;g&quot;,&quot;oo&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;goog&quot;,&quot;l&quot;,&quot;e&quot;]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;aab&quot;\n<strong>输出：</strong>[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;\n<strong>输出：</strong>[[&quot;a&quot;]]</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s </code>仅由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 131&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/palindrome-partitioning/\">https://leetcode-cn.com/problems/palindrome-partitioning/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3649.复原 IP 地址",
        "hardRate": "MEDIUM",
        "passRate": "63.41%",
        "problemsUrl": "https://leetcode.cn/problems/0on3uN/",
        "solutionsUrl": "https://leetcode.cn/problems/0on3uN/solution",
        "problemsDesc": "<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能从&nbsp;<code>s</code> 获得的 <strong>有效 IP 地址 </strong>。你可以按任何顺序返回答案。</p>\n\n<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p>\n\n<p>例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 <strong>有效</strong> IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 <strong>无效</strong> IP 地址。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;25525511135&quot;\n<strong>输出：</strong>[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;0000&quot;\n<strong>输出：</strong>[&quot;0.0.0.0&quot;]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;1111&quot;\n<strong>输出：</strong>[&quot;1.1.1.1&quot;]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;010010&quot;\n<strong>输出：</strong>[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;10203040&quot;\n<strong>输出：</strong>[&quot;10.20.30.40&quot;,&quot;102.0.30.40&quot;,&quot;10.203.0.40&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 93&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/restore-ip-addresses/\">https://leetcode-cn.com/problems/restore-ip-addresses/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3650.使用最小花费爬楼梯",
        "hardRate": "EASY",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/GzCJIP/",
        "solutionsUrl": "https://leetcode.cn/problems/GzCJIP/solution",
        "problemsDesc": "<p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值&nbsp;<code>cost[i]</code>（下标从 <code>0</code> 开始）。</p>\n\n<p>每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。</p>\n\n<p>请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [10, 15, 20]\n<strong>输出：</strong>15\n<strong>解释：</strong>最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。\n</pre>\n\n<p><strong>&nbsp;示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n<strong>输出：</strong>6\n<strong>解释：</strong>最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cost.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= cost[i] &lt;= 999</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 746&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p>\n",
        "isPlus": false
    }
]