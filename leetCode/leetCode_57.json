[
    {
        "problemsName": " 2801.统计范围内的步进数字数目",
        "hardRate": "HARD",
        "passRate": "44.61%",
        "problemsUrl": "https://leetcode.cn/problems/count-stepping-numbers-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-stepping-numbers-in-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>low</code> 和&nbsp;<code>high</code>&nbsp;，都用字符串表示，请你统计闭区间 <code>[low, high]</code>&nbsp;内的 <strong>步进数字</strong>&nbsp;数目。</p>\n\n<p>如果一个整数相邻数位之间差的绝对值都 <strong>恰好</strong>&nbsp;是 <code>1</code>&nbsp;，那么这个数字被称为 <strong>步进数字</strong>&nbsp;。</p>\n\n<p>请你返回一个整数，表示闭区间&nbsp;<code>[low, high]</code>&nbsp;之间步进数字的数目。</p>\n\n<p>由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p><b>注意：</b>步进数字不能有前导 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>low = \"1\", high = \"11\"\n<b>输出：</b>10\n<strong>解释：</strong>区间 [1,11] 内的步进数字为 1 ，2 ，3 ，4 ，5 ，6 ，7 ，8 ，9 和 10 。总共有 10 个步进数字。所以输出为 10 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>low = \"90\", high = \"101\"\n<b>输出：</b>2\n<strong>解释：</strong>区间 [90,101] 内的步进数字为 98 和 101 。总共有 2 个步进数字。所以输出为 2 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= int(low) &lt;= int(high) &lt; 10<sup>100</sup></code></li>\n\t<li><code>1 &lt;= low.length, high.length &lt;= 100</code></li>\n\t<li><code>low</code> 和&nbsp;<code>high</code>&nbsp;只包含数字。</li>\n\t<li><code>low</code> 和&nbsp;<code>high</code>&nbsp;都不含前导 0 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2802.找出第 K 个幸运数字",
        "hardRate": "MEDIUM",
        "passRate": "59.74%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-th-lucky-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-th-lucky-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2803.阶乘生成器",
        "hardRate": "EASY",
        "passRate": "83.20%",
        "problemsUrl": "https://leetcode.cn/problems/factorial-generator/",
        "solutionsUrl": "https://leetcode.cn/problems/factorial-generator/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2804.数组原型的 forEach 方法",
        "hardRate": "EASY",
        "passRate": "88.44%",
        "problemsUrl": "https://leetcode.cn/problems/array-prototype-foreach/",
        "solutionsUrl": "https://leetcode.cn/problems/array-prototype-foreach/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2805.自定义间隔",
        "hardRate": "MEDIUM",
        "passRate": "81.39%",
        "problemsUrl": "https://leetcode.cn/problems/custom-interval/",
        "solutionsUrl": "https://leetcode.cn/problems/custom-interval/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2806.取整购买后的账户余额",
        "hardRate": "EASY",
        "passRate": "69.09%",
        "problemsUrl": "https://leetcode.cn/problems/account-balance-after-rounded-purchase/",
        "solutionsUrl": "https://leetcode.cn/problems/account-balance-after-rounded-purchase/solution",
        "problemsDesc": "<p>一开始，你的银行账户里有&nbsp;<code>100</code>&nbsp;块钱。</p>\n\n<p>给你一个整数<code>purchaseAmount</code>&nbsp;，它表示你在一次购买中愿意支出的金额。</p>\n\n<p>在一个商店里，你进行一次购买，实际支出的金额会向 <strong>最近</strong>&nbsp;的&nbsp;<code>10</code>&nbsp;的 <strong>倍数</strong>&nbsp;取整。换句话说，你实际会支付一个&nbsp;<strong>非负</strong>&nbsp;金额&nbsp;<code>roundedAmount</code>&nbsp;，满足&nbsp;<code>roundedAmount</code>&nbsp;是&nbsp;<code>10</code>&nbsp;的倍数且&nbsp;<code>abs(roundedAmount - purchaseAmount)</code>&nbsp;的值 <strong>最小</strong>&nbsp;。</p>\n\n<p>如果存在多于一个最接近的 <code>10</code>&nbsp;的倍数，<strong>较大的倍数</strong>&nbsp;是你的实际支出金额。</p>\n\n<p>请你返回一个整数，表示你在愿意支出金额为<em>&nbsp;</em><code>purchaseAmount</code><em>&nbsp;</em>块钱的前提下，购买之后剩下的余额。</p>\n\n<p><strong>注意：</strong> <code>0</code>&nbsp;也是&nbsp;<code>10</code>&nbsp;的倍数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>purchaseAmount = 9\n<b>输出：</b>90\n<b>解释：</b>这个例子中，最接近 9 的 10 的倍数是 10 。所以你的账户余额为 100 - 10 = 90 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>purchaseAmount = 15\n<b>输出：</b>80\n<b>解释：</b>这个例子中，有 2 个最接近 15 的 10 的倍数：10 和 20，较大的数 20 是你的实际开销。\n所以你的账户余额为 100 - 20 = 80 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= purchaseAmount &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2807.在链表中插入最大公约数",
        "hardRate": "MEDIUM",
        "passRate": "90.32%",
        "problemsUrl": "https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头&nbsp;<code>head</code>&nbsp;，每个结点包含一个整数值。</p>\n\n<p>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 <strong>最大公约数</strong>&nbsp;。</p>\n\n<p>请你返回插入之后的链表。</p>\n\n<p>两个数的 <strong>最大公约数</strong>&nbsp;是可以被两个数字整除的最大正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png\" style=\"width: 641px; height: 181px;\"></p>\n\n<pre><b>输入：</b>head = [18,6,10,3]\n<b>输出：</b>[18,6,6,2,10,1,3]\n<b>解释：</b>第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。\n- 18 和 6 的最大公约数为 6 ，插入第一和第二个结点之间。\n- 6 和 10 的最大公约数为 2 ，插入第二和第三个结点之间。\n- 10 和 3 的最大公约数为 1 ，插入第三和第四个结点之间。\n所有相邻结点之间都插入完毕，返回链表。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png\" style=\"width: 51px; height: 191px;\"></p>\n\n<pre><b>输入：</b>head = [7]\n<strong>输出：</strong>[7]\n<b>解释：</b>第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。\n没有相邻结点，所以返回初始链表。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中结点数目在&nbsp;<code>[1, 5000]</code> 之间。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2808.使循环数组所有元素相等的最少秒数",
        "hardRate": "MEDIUM",
        "passRate": "55.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>每一秒，你可以对数组执行以下操作：</p>\n\n<ul>\n\t<li>对于范围在&nbsp;<code>[0, n - 1]</code>&nbsp;内的每一个下标&nbsp;<code>i</code>&nbsp;，将&nbsp;<code>nums[i]</code> 替换成&nbsp;<code>nums[i]</code>&nbsp;，<code>nums[(i - 1 + n) % n]</code>&nbsp;或者&nbsp;<code>nums[(i + 1) % n]</code>&nbsp;三者之一。</li>\n</ul>\n\n<p><strong>注意</strong>，所有元素会被同时替换。</p>\n\n<p>请你返回将数组 <code>nums</code>&nbsp;中所有元素变成相等元素所需要的 <strong>最少</strong>&nbsp;秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,1,2]\n<b>输出：</b>1\n<b>解释：</b>我们可以在 1 秒内将数组变成相等元素：\n- 第 1 秒，将每个位置的元素分别变为 [nums[3],nums[1],nums[3],nums[3]] 。变化后，nums = [2,2,2,2] 。\n1 秒是将数组变成相等元素所需要的最少秒数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1,3,3,2]\n<b>输出：</b>2\n<b>解释：</b>我们可以在 2 秒内将数组变成相等元素：\n- 第 1 秒，将每个位置的元素分别变为 [nums[0],nums[2],nums[2],nums[2],nums[3]] 。变化后，nums = [2,3,3,3,3] 。\n- 第 2 秒，将每个位置的元素分别变为 [nums[1],nums[1],nums[2],nums[3],nums[4]] 。变化后，nums = [3,3,3,3,3] 。\n2 秒是将数组变成相等元素所需要的最少秒数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [5,5,5,5]\n<b>输出：</b>0\n<b>解释：</b>不需要执行任何操作，因为一开始数组中的元素已经全部相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2809.使数组和小于等于 x 的最少时间",
        "hardRate": "HARD",
        "passRate": "61.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-make-array-sum-at-most-x/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-make-array-sum-at-most-x/solution",
        "problemsDesc": "<p>给你两个长度相等下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;。每一秒，对于所有下标&nbsp;<code>0 &lt;= i &lt; nums1.length</code>&nbsp;，<code>nums1[i]</code>&nbsp;的值都增加&nbsp;<code>nums2[i]</code>&nbsp;。操作&nbsp;<strong>完成后</strong>&nbsp;，你可以进行如下操作：</p>\n\n<ul>\n\t<li>选择任一满足&nbsp;<code>0 &lt;= i &lt; nums1.length</code>&nbsp;的下标 <code>i</code>&nbsp;，并使&nbsp;<code>nums1[i] = 0</code>&nbsp;。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>x</code>&nbsp;。</p>\n\n<p>请你返回使&nbsp;<code>nums1</code>&nbsp;中所有元素之和 <strong>小于等于</strong>&nbsp;<code>x</code>&nbsp;所需要的 <strong>最少</strong>&nbsp;时间，如果无法实现，那么返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,3], nums2 = [1,2,3], x = 4\n<b>输出：</b>3\n<b>解释：</b>\n第 1 秒，我们对 i = 0 进行操作，得到 nums1 = [0,2+2,3+3] = [0,4,6] 。\n第 2 秒，我们对 i = 1 进行操作，得到 nums1 = [0+1,0,6+3] = [1,0,9] 。\n第 3 秒，我们对 i = 2 进行操作，得到 nums1 = [1+1,0+2,0] = [2,2,0] 。\n现在 nums1 的和为 4 。不存在更少次数的操作，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,3], nums2 = [3,3,3], x = 4\n<b>输出：</b>-1\n<b>解释：</b>不管如何操作，nums1 的和总是会超过 x 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>1 &lt;= nums1[i] &lt;= 10<sup>3</sup></code></li>\n\t<li><code>0 &lt;= nums2[i] &lt;= 10<sup>3</sup></code></li>\n\t<li><code>nums1.length == nums2.length</code></li>\n\t<li><code>0 &lt;= x &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2810.故障键盘",
        "hardRate": "EASY",
        "passRate": "84.01%",
        "problemsUrl": "https://leetcode.cn/problems/faulty-keyboard/",
        "solutionsUrl": "https://leetcode.cn/problems/faulty-keyboard/solution",
        "problemsDesc": "<p>你的笔记本键盘存在故障，每当你在上面输入字符 <code>'i'</code> 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，请你用故障键盘依次输入每个字符。</p>\n\n<p>返回最终笔记本屏幕上输出的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"string\"\n<strong>输出：</strong>\"rtsng\"\n<strong>解释：</strong>\n输入第 1 个字符后，屏幕上的文本是：\"s\" 。\n输入第 2 个字符后，屏幕上的文本是：\"st\" 。\n输入第 3 个字符后，屏幕上的文本是：\"str\" 。\n因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 \"rts\" 。\n输入第 5 个字符后，屏幕上的文本是：\"rtsn\" 。\n输入第 6 个字符后，屏幕上的文本是： \"rtsng\" 。\n因此，返回 \"rtsng\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"poiinter\"\n<strong>输出：</strong>\"ponter\"\n<strong>解释：</strong>\n输入第 1 个字符后，屏幕上的文本是：\"p\" 。\n输入第 2 个字符后，屏幕上的文本是：\"po\" 。\n因为第 3 个字符是 'i' ，屏幕上的文本被反转，变成 \"op\" 。\n因为第 4 个字符是 'i' ，屏幕上的文本被反转，变成 \"po\" 。\n输入第 5 个字符后，屏幕上的文本是：\"pon\" 。\n输入第 6 个字符后，屏幕上的文本是：\"pont\" 。\n输入第 7 个字符后，屏幕上的文本是：\"ponte\" 。\n输入第 8 个字符后，屏幕上的文本是：\"ponter\" 。\n因此，返回 \"ponter\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>s[0] != 'i'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2811.判断是否能拆分数组",
        "hardRate": "MEDIUM",
        "passRate": "33.53%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-it-is-possible-to-split-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-it-is-possible-to-split-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> 和一个整数 <code>m</code> 。请你判断能否执行一系列操作，将数组拆分成 <code>n</code> 个 <strong>非空 </strong>数组。</p>\n\n<p>一个数组被称为 <strong>好</strong> 的，如果：</p>\n\n<ul>\n\t<li>子数组的长度为 1 ，或者</li>\n\t<li>子数组元素之和 <strong>大于或等于</strong>&nbsp; <code>m</code> 。</li>\n</ul>\n\n<p>在每一步操作中，你可以选择一个 <strong>长度至少为 2</strong> 的现有数组（之前步骤的结果） 并将其拆分成 <strong>2</strong> 个子数组，而得到的 <strong>每个</strong> 子数组都需要是好的。</p>\n\n<p>如果你可以将给定数组拆分成 <code>n</code> 个满足要求的数组，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b>nums = [2, 2, 1], m = 4</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b>true</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li>将 <code>[2, 2, 1]</code> <span class=\"example-io\">切分为</span> <code>[2, 2]</code> 和&nbsp;<code>[1]</code>。数组 <code>[1]</code> 的长度为 1，数组 <code>[2, 2]</code> 的元素之和等于 <code>4 &gt;= m</code>，所以两者都是好的数组。</li>\n\t<li>将 <code>[2, 2]</code> <span class=\"example-io\">切分为</span> <code>[2]</code> 和&nbsp;<code>[2]</code>。两个数组的长度都是 1，所以都是好的数组。</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b></span><span class=\"example-io\">nums = [2, 1, 3], m = 5</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b></span><span class=\"example-io\">false</span></p>\n\n<p><strong>解释：</strong></p>\n\n<p>第一步必须是以下之一：</p>\n\n<ul>\n\t<li>将&nbsp;<code>[2, 1, 3]</code> <span class=\"example-io\">切分为</span> <code>[2, 1]</code> 和&nbsp;<code>[3]</code>。数组&nbsp;<code>[2, 1]</code> 既不是长度为 1，也没有大于或等于 <code>m</code> 的元素和。</li>\n\t<li>将 <code>[2, 1, 3]</code> <span class=\"example-io\">切分为</span> <code>[2]</code> 和 <code>[1, 3]</code>。数组&nbsp;<code>[1, 3]</code> 既不是长度为 1，也没有大于或等于 <code>m</code> 的元素和。</li>\n</ul>\n\n<p>因此，由于这两个操作都无效（它们没有将数组分成两个好的数组），因此我们无法将 <code>nums</code> 分成 <code>n</code> 个大小为 1 的数组。</p>\n</div>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<div class=\"example-block\">\n<p><span class=\"example-io\"><b>输入：</b></span><span class=\"example-io\">nums = [2, 3, 3, 2, 3], m = 6</span></p>\n\n<p><span class=\"example-io\"><b>输出：</b></span><span class=\"example-io\">true</span></p>\n\n<p><strong>解释：</strong></p>\n\n<ul>\n\t<li><span class=\"example-io\">将&nbsp;<code>[2, 3, 3, 2, 3]</code>&nbsp;切分为&nbsp;<code>[2]</code> 和&nbsp;<code>[3, 3, 2, 3]</code>。</span></li>\n\t<li><span class=\"example-io\">将 <code>[3, 3, 2, 3]</code> 切分为 <code>[3, 3, 2]</code> 和 <code>[3]</code>。</span></li>\n\t<li><span class=\"example-io\">将 <code>[3, 3, 2]</code> 切分为 <code>[3, 3]</code> 和 <code>[2]</code>。</span></li>\n\t<li><span class=\"example-io\">将 <code>[3, 3]</code> 切分为 <code>[3]</code> 和 <code>[3]</code>。</span></li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= m &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2812.找出最安全路径",
        "hardRate": "MEDIUM",
        "passRate": "31.95%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-safest-path-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-safest-path-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的二维矩阵 <code>grid</code> ，其中 <code>(r, c)</code> 表示：</p>\n\n<ul>\n\t<li>如果 <code>grid[r][c] = 1</code> ，则表示一个存在小偷的单元格</li>\n\t<li>如果 <code>grid[r][c] = 0</code> ，则表示一个空单元格</li>\n</ul>\n\n<p>你最开始位于单元格 <code>(0, 0)</code> 。在一步移动中，你可以移动到矩阵中的任一相邻单元格，包括存在小偷的单元格。</p>\n\n<p>矩阵中路径的 <strong>安全系数</strong> 定义为：从路径中任一单元格到矩阵中任一小偷所在单元格的 <strong>最小</strong> 曼哈顿距离。</p>\n\n<p>返回所有通向单元格<em> </em><code>(n - 1, n - 1)</code> 的路径中的 <strong>最大安全系数</strong> 。</p>\n\n<p>单元格 <code>(r, c)</code> 的某个 <strong>相邻</strong> 单元格，是指在矩阵中存在的 <code>(r, c + 1)</code>、<code>(r, c - 1)</code>、<code>(r + 1, c)</code> 和 <code>(r - 1, c)</code> 之一。</p>\n\n<p>两个单元格 <code>(a, b)</code> 和 <code>(x, y)</code> 之间的 <strong>曼哈顿距离</strong> 等于 <code>| a - x | + | b - y |</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/07/02/example1.png\" style=\"width: 362px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,0,0],[0,0,0],[0,0,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>从 (0, 0) 到 (n - 1, n - 1) 的每条路径都经过存在小偷的单元格 (0, 0) 和 (n - 1, n - 1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/07/02/example2.png\" style=\"width: 362px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1],[0,0,0],[0,0,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n上图所示路径的安全系数为 2：\n- 该路径上距离小偷所在单元格（0，2）最近的单元格是（0，0）。它们之间的曼哈顿距离为 | 0 - 0 | + | 0 - 2 | = 2 。\n可以证明，不存在安全系数更高的其他路径。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/07/02/example3.png\" style=\"width: 362px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n上图所示路径的安全系数为 2：\n- 该路径上距离小偷所在单元格（0，3）最近的单元格是（1，2）。它们之间的曼哈顿距离为 | 0 - 1 | + | 3 - 2 | = 2 。\n- 该路径上距离小偷所在单元格（3，0）最近的单元格是（3，2）。它们之间的曼哈顿距离为 | 3 - 3 | + | 0 - 2 | = 2 。\n可以证明，不存在安全系数更高的其他路径。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length == n &lt;= 400</code></li>\n\t<li><code>grid[i].length == n</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>grid</code> 至少存在一个小偷</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2813.子序列最大优雅度",
        "hardRate": "HARD",
        "passRate": "53.40%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的二维整数数组 <code>items</code> 和一个整数 <code>k</code> 。</p>\n\n<p><code>items[i] = [profit<sub>i</sub>, category<sub>i</sub>]</code>，其中 <code>profit<sub>i</sub></code> 和 <code>category<sub>i</sub></code> 分别表示第 <code>i</code> 个项目的利润和类别。</p>\n\n<p>现定义&nbsp;<code>items</code> 的 <strong>子序列</strong> 的 <strong>优雅度</strong> 可以用 <code>total_profit + distinct_categories<sup>2</sup></code> 计算，其中 <code>total_profit</code> 是子序列中所有项目的利润总和，<code>distinct_categories</code> 是所选子序列所含的所有类别中不同类别的数量。</p>\n\n<p>你的任务是从 <code>items</code> 所有长度为 <code>k</code> 的子序列中，找出 <strong>最大优雅度</strong> 。</p>\n\n<p>用整数形式表示并返回 <code>items</code> 中所有长度恰好为 <code>k</code> 的子序列的最大优雅度。</p>\n\n<p><strong>注意：</strong>数组的子序列是经由原数组删除一些元素（可能不删除）而产生的新数组，且删除不改变其余元素相对顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[3,2],[5,1],[10,1]], k = 2\n<strong>输出：</strong>17\n<strong>解释：\n</strong>在这个例子中，我们需要选出长度为 2 的子序列。\n其中一种方案是 items[0] = [3,2] 和 items[2] = [10,1] 。\n子序列的总利润为 3 + 10 = 13 ，子序列包含 2 种不同类别 [2,1] 。\n因此，优雅度为 13 + 2<sup>2</sup> = 17 ，可以证明 17 是可以获得的最大优雅度。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[3,1],[3,1],[2,2],[5,3]], k = 3\n<strong>输出：</strong>19\n<strong>解释：</strong>\n在这个例子中，我们需要选出长度为 3 的子序列。 \n其中一种方案是 items[0] = [3,1] ，items[2] = [2,2] 和 items[3] = [5,3] 。\n子序列的总利润为 3 + 2 + 5 = 10 ，子序列包含 3 种不同类别 [1, 2, 3] 。 \n因此，优雅度为 10 + 3<sup>2</sup> = 19 ，可以证明 19 是可以获得的最大优雅度。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[1,1],[2,1],[3,1]], k = 3\n<strong>输出：</strong>7\n<strong>解释：\n</strong>在这个例子中，我们需要选出长度为 3 的子序列。\n我们需要选中所有项目。\n子序列的总利润为 1 + 2 + 3 = 6，子序列包含 1 种不同类别 [1] 。\n因此，最大优雅度为 6 + 1<sup>2</sup> = 7 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>items[i].length == 2</code></li>\n\t<li><code>items[i][0] == profit<sub>i</sub></code></li>\n\t<li><code>items[i][1] == category<sub>i</sub></code></li>\n\t<li><code>1 &lt;= profit<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= category<sub>i</sub> &lt;= n </code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2814.避免淹死并到达目的地的最短时间",
        "hardRate": "HARD",
        "passRate": "40.60%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-takes-to-reach-destination-without-drowning/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-takes-to-reach-destination-without-drowning/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2815.数组中的最大数对和",
        "hardRate": "EASY",
        "passRate": "72.40%",
        "problemsUrl": "https://leetcode.cn/problems/max-pair-sum-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/max-pair-sum-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。请你从 <code>nums</code> 中找出和 <strong>最大</strong> 的一对数，且这两个数数位上最大的数字相等。</p>\n\n<p>返回最大和，如果不存在满足题意的数字对，返回 <code>-1</code><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [51,71,17,24,42]\n<strong>输出：</strong>88\n<strong>解释：</strong>\ni = 1 和 j = 2 ，nums[i] 和 nums[j] 数位上最大的数字相等，且这一对的总和 71 + 17 = 88 。 \ni = 3 和 j = 4 ，nums[i] 和 nums[j] 数位上最大的数字相等，且这一对的总和 24 + 42 = 66 。\n可以证明不存在其他数对满足数位上最大的数字相等，所以答案是 88 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在数对满足数位上最大的数字相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2816.翻倍以链表形式表示的数字",
        "hardRate": "MEDIUM",
        "passRate": "63.02%",
        "problemsUrl": "https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/solution",
        "problemsDesc": "<p>给你一个 <strong>非空</strong> 链表的头节点 <code>head</code> ，表示一个不含前导零的非负数整数。</p>\n\n<p>将链表 <strong>翻倍</strong> 后，返回头节点<em> </em><code>head</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/28/example.png\" style=\"width: 401px; height: 81px;\" />\n<pre>\n<strong>输入：</strong>head = [1,8,9]\n<strong>输出：</strong>[3,7,8]\n<strong>解释：</strong>上图中给出的链表，表示数字 189 。返回的链表表示数字 189 * 2 = 378 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/28/example2.png\" style=\"width: 401px; height: 81px;\" />\n<pre>\n<strong>输入：</strong>head = [9,9,9]\n<strong>输出：</strong>[1,9,9,8]\n<strong>解释：</strong>上图中给出的链表，表示数字 999 。返回的链表表示数字 999 * 2 = 1998 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><font face=\"monospace\"><code>0 &lt;= Node.val &lt;= 9</code></font></li>\n\t<li>生成的输入满足：链表表示一个不含前导零的数字，除了数字 <code>0</code> 本身。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2817.限制条件下元素之间的最小绝对差",
        "hardRate": "MEDIUM",
        "passRate": "33.09%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-between-elements-with-constraint/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-between-elements-with-constraint/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>x</code>&nbsp;。</p>\n\n<p>请你找到数组中下标距离至少为 <code>x</code>&nbsp;的两个元素的 <strong>差值绝对值</strong>&nbsp;的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>换言之，请你找到两个下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，满足&nbsp;<code>abs(i - j) &gt;= x</code> 且&nbsp;<code>abs(nums[i] - nums[j])</code>&nbsp;的值最小。</p>\n\n<p>请你返回一个整数，表示下标距离至少为 <code>x</code>&nbsp;的两个元素之间的差值绝对值的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>nums = [4,3,2,4], x = 2\n<b>输出：</b>0\n<b>解释：</b>我们选择 nums[0] = 4 和 nums[3] = 4 。\n它们下标距离满足至少为 2 ，差值绝对值为最小值 0 。\n0 是最优解。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,3,2,10,15], x = 1\n<b>输出：</b>1\n<b>解释：</b>我们选择 nums[1] = 3 和 nums[2] = 2 。\n它们下标距离满足至少为 1 ，差值绝对值为最小值 1 。\n1 是最优解。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4], x = 3\n<b>输出：</b>3\n<strong>解释：</strong>我们选择 nums[0] = 1 和 nums[3] = 4 。\n它们下标距离满足至少为 3 ，差值绝对值为最小值 3 。\n3 是最优解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= x &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2818.操作使得分最大",
        "hardRate": "HARD",
        "passRate": "45.46%",
        "problemsUrl": "https://leetcode.cn/problems/apply-operations-to-maximize-score/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-operations-to-maximize-score/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的正整数数组&nbsp;<code>nums</code>&nbsp;和一个整数 <code>k</code>&nbsp;。</p>\n\n<p>一开始，你的分数为 <code>1</code>&nbsp;。你可以进行以下操作至多 <code>k</code>&nbsp;次，目标是使你的分数最大：</p>\n\n<ul>\n\t<li>选择一个之前没有选过的 <strong>非空</strong>&nbsp;子数组&nbsp;<code>nums[l, ..., r]</code>&nbsp;。</li>\n\t<li>从&nbsp;<code>nums[l, ..., r]</code>&nbsp;里面选择一个 <strong>质数分数</strong>&nbsp;最高的元素 <code>x</code>&nbsp;。如果多个元素质数分数相同且最高，选择下标最小的一个。</li>\n\t<li>将你的分数乘以&nbsp;<code>x</code>&nbsp;。</li>\n</ul>\n\n<p><code>nums[l, ..., r]</code>&nbsp;表示&nbsp;<code>nums</code>&nbsp;中起始下标为&nbsp;<code>l</code>&nbsp;，结束下标为 <code>r</code>&nbsp;的子数组，两个端点都包含。</p>\n\n<p>一个整数的 <strong>质数分数</strong>&nbsp;等于&nbsp;<code>x</code>&nbsp;不同质因子的数目。比方说，&nbsp;<code>300</code>&nbsp;的质数分数为&nbsp;<code>3</code>&nbsp;，因为&nbsp;<code>300 = 2 * 2 * 3 * 5 * 5</code>&nbsp;。</p>\n\n<p>请你返回进行至多 <code>k</code>&nbsp;次操作后，可以得到的 <strong>最大分数</strong>&nbsp;。</p>\n\n<p>由于答案可能很大，请你将结果对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [8,3,9,3,8], k = 2\n<b>输出：</b>81\n<b>解释：</b>进行以下操作可以得到分数 81 ：\n- 选择子数组 nums[2, ..., 2] 。nums[2] 是子数组中唯一的元素。所以我们将分数乘以 nums[2] ，分数变为 1 * 9 = 9 。\n- 选择子数组 nums[2, ..., 3] 。nums[2] 和 nums[3] 质数分数都为 1 ，但是 nums[2] 下标更小。所以我们将分数乘以 nums[2] ，分数变为 9 * 9 = 81 。\n81 是可以得到的最高得分。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [19,12,14,6,10,18], k = 3\n<b>输出：</b>4788\n<b>解释：</b>进行以下操作可以得到分数 4788 ：\n- 选择子数组 nums[0, ..., 0] 。nums[0] 是子数组中唯一的元素。所以我们将分数乘以 nums[0] ，分数变为 1 * 19 = 19 。\n- 选择子数组 nums[5, ..., 5] 。nums[5] 是子数组中唯一的元素。所以我们将分数乘以 nums[5] ，分数变为 19 * 18 = 342 。\n- 选择子数组 nums[2, ..., 3] 。nums[2] 和 nums[3] 质数分数都为 2，但是 nums[2] 下标更小。所以我们将分数乘以 nums[2] ，分数变为  342 * 14 = 4788 。\n4788 是可以得到的最高的分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= min(n * (n + 1) / 2, 10<sup>9</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2819.购买巧克力后的最小相对损失",
        "hardRate": "HARD",
        "passRate": "53.42%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-relative-loss-after-buying-chocolates/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-relative-loss-after-buying-chocolates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2820.选举结果",
        "hardRate": "MEDIUM",
        "passRate": "58.54%",
        "problemsUrl": "https://leetcode.cn/problems/election-results/",
        "solutionsUrl": "https://leetcode.cn/problems/election-results/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2821.延迟每个 Promise 对象的解析",
        "hardRate": "MEDIUM",
        "passRate": "66.30%",
        "problemsUrl": "https://leetcode.cn/problems/delay-the-resolution-of-each-promise/",
        "solutionsUrl": "https://leetcode.cn/problems/delay-the-resolution-of-each-promise/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2822.对象反转",
        "hardRate": "EASY",
        "passRate": "64.04%",
        "problemsUrl": "https://leetcode.cn/problems/inversion-of-object/",
        "solutionsUrl": "https://leetcode.cn/problems/inversion-of-object/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2823.深度对象筛选",
        "hardRate": "MEDIUM",
        "passRate": "46.84%",
        "problemsUrl": "https://leetcode.cn/problems/deep-object-filter/",
        "solutionsUrl": "https://leetcode.cn/problems/deep-object-filter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2824.统计和小于目标的下标对数目",
        "hardRate": "EASY",
        "passRate": "85.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/solution",
        "problemsDesc": "给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;，请你返回满足&nbsp;<code>0 &lt;= i &lt; j &lt; n</code> 且 <code>nums[i] + nums[j] &lt; target</code>&nbsp;的下标对&nbsp;<code>(i, j)</code>&nbsp;的数目。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-1,1,2,3,1], target = 2\n<b>输出：</b>3\n<b>解释：</b>总共有 3 个下标对满足题目描述：\n- (0, 1) ，0 &lt; 1 且 nums[0] + nums[1] = 0 &lt; target\n- (0, 2) ，0 &lt; 2 且 nums[0] + nums[2] = 1 &lt; target \n- (0, 4) ，0 &lt; 4 且 nums[0] + nums[4] = 0 &lt; target\n注意 (0, 3) 不计入答案因为 nums[0] + nums[3] 不是严格小于 target 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-6,2,5,-2,-7,-1,3], target = -2\n<b>输出：</b>10\n<b>解释：</b>总共有 10 个下标对满足题目描述：\n- (0, 1) ，0 &lt; 1 且 nums[0] + nums[1] = -4 &lt; target\n- (0, 3) ，0 &lt; 3 且 nums[0] + nums[3] = -8 &lt; target\n- (0, 4) ，0 &lt; 4 且 nums[0] + nums[4] = -13 &lt; target\n- (0, 5) ，0 &lt; 5 且 nums[0] + nums[5] = -7 &lt; target\n- (0, 6) ，0 &lt; 6 且 nums[0] + nums[6] = -3 &lt; target\n- (1, 4) ，1 &lt; 4 且 nums[1] + nums[4] = -5 &lt; target\n- (3, 4) ，3 &lt; 4 且 nums[3] + nums[4] = -9 &lt; target\n- (3, 5) ，3 &lt; 5 且 nums[3] + nums[5] = -3 &lt; target\n- (4, 5) ，4 &lt; 5 且 nums[4] + nums[5] = -8 &lt; target\n- (4, 6) ，4 &lt; 6 且 nums[4] + nums[6] = -4 &lt; target\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length == n &lt;= 50</code></li>\n\t<li><code>-50 &lt;= nums[i], target &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2825.循环增长使字符串子序列等于另一个字符串",
        "hardRate": "MEDIUM",
        "passRate": "59.39%",
        "problemsUrl": "https://leetcode.cn/problems/make-string-a-subsequence-using-cyclic-increments/",
        "solutionsUrl": "https://leetcode.cn/problems/make-string-a-subsequence-using-cyclic-increments/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>str1</code> 和&nbsp;<code>str2</code>&nbsp;。</p>\n\n<p>一次操作中，你选择&nbsp;<code>str1</code>&nbsp;中的若干下标。对于选中的每一个下标&nbsp;<code>i</code>&nbsp;，你将&nbsp;<code>str1[i]</code>&nbsp;<strong>循环</strong>&nbsp;递增，变成下一个字符。也就是说&nbsp;<code>'a'</code>&nbsp;变成&nbsp;<code>'b'</code>&nbsp;，<code>'b'</code> 变成&nbsp;<code>'c'</code>&nbsp;，以此类推，<code>'z'</code> 变成&nbsp;<code>'a'</code>&nbsp;。</p>\n\n<p>如果执行以上操作 <strong>至多一次</strong>&nbsp;，可以让 <code>str2</code>&nbsp;成为 <code>str1</code>&nbsp;的子序列，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p><b>注意：</b>一个字符串的子序列指的是从原字符串中删除一些（可以一个字符也不删）字符后，剩下字符按照原本先后顺序组成的新字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>str1 = \"abc\", str2 = \"ad\"\n<b>输出：</b>true\n<b>解释：</b>选择 str1 中的下标 2 。\n将 str1[2] 循环递增，得到 'd' 。\n因此，str1 变成 \"abd\" 且 str2 现在是一个子序列。所以返回 true 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>str1 = \"zc\", str2 = \"ad\"\n<b>输出：</b>true\n<b>解释：</b>选择 str1 中的下标 0 和 1 。\n将 str1[0] 循环递增得到 'a' 。\n将 str1[1] 循环递增得到 'd' 。\n因此，str1 变成 \"ad\" 且 str2 现在是一个子序列。所以返回 true 。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>str1 = \"ab\", str2 = \"d\"\n<b>输出：</b>false\n<b>解释：</b>这个例子中，没法在执行一次操作的前提下，将 str2 变为 str1 的子序列。\n所以返回 false 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= str1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= str2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2826.将三个组排序",
        "hardRate": "MEDIUM",
        "passRate": "62.70%",
        "problemsUrl": "https://leetcode.cn/problems/sorting-three-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/sorting-three-groups/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;。<code>nums</code>&nbsp;的每个元素是 1，2 或 3。在每次操作中，你可以删除&nbsp;<code>nums</code>&nbsp;中的一个元素。返回使 nums 成为 <strong>非递减</strong>&nbsp;顺序所需操作数的 <strong>最小值</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,3,2,1]\n<b>输出：</b>3\n<b>解释：</b>\n其中一个最优方案是删除 nums[0]，nums[2] 和 nums[3]。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,2,1,3,3]\n<b>输出：</b>2\n<b>解释：</b>\n其中一个最优方案是删除 nums[1] 和 nums[2]。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2,2,2,3,3]\n<b>输出：</b>0\n<b>解释：</b>\nnums 已是非递减顺序的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 3</code></li>\n</ul>\n\n<p><strong>进阶：</strong>你可以使用&nbsp;<code>O(n)</code>&nbsp;时间复杂度以内的算法解决吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2827.范围中美丽整数的数目",
        "hardRate": "HARD",
        "passRate": "35.96%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-beautiful-integers-in-the-range/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-beautiful-integers-in-the-range/solution",
        "problemsDesc": "<p>给你正整数&nbsp;<code>low</code>&nbsp;，<code>high</code>&nbsp;和&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果一个数满足以下两个条件，那么它是 <strong>美丽的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>偶数数位的数目与奇数数位的数目相同。</li>\n\t<li>这个整数可以被&nbsp;<code>k</code>&nbsp;整除。</li>\n</ul>\n\n<p>请你返回范围&nbsp;<code>[low, high]</code>&nbsp;中美丽整数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>low = 10, high = 20, k = 3\n<b>输出：</b>2\n<b>解释：</b>给定范围中有 2 个美丽数字：[12,18]\n- 12 是美丽整数，因为它有 1 个奇数数位和 1 个偶数数位，而且可以被 k = 3 整除。\n- 18 是美丽整数，因为它有 1 个奇数数位和 1 个偶数数位，而且可以被 k = 3 整除。\n以下是一些不是美丽整数的例子：\n- 16 不是美丽整数，因为它不能被 k = 3 整除。\n- 15 不是美丽整数，因为它的奇数数位和偶数数位的数目不相等。\n给定范围内总共有 2 个美丽整数。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>low = 1, high = 10, k = 1\n<b>输出：</b>1\n<b>解释：</b>给定范围中有 1 个美丽数字：[10]\n- 10 是美丽整数，因为它有 1 个奇数数位和 1 个偶数数位，而且可以被 k = 1 整除。\n给定范围内总共有 1 个美丽整数。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>low = 5, high = 5, k = 2\n<b>输出：</b>0\n<b>解释：</b>给定范围中有 0 个美丽数字。\n- 5 不是美丽整数，因为它的奇数数位和偶数数位的数目不相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt; low &lt;= high &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt; k &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2828.判别首字母缩略词",
        "hardRate": "EASY",
        "passRate": "84.66%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words/solution",
        "problemsDesc": "<p>给你一个字符串数组&nbsp;<code>words</code> 和一个字符串 <code>s</code> ，请你判断 <code>s</code> 是不是 <code>words</code> 的 <strong>首字母缩略词</strong> 。</p>\n\n<p>如果可以按顺序串联 <code>words</code> 中每个字符串的第一个字符形成字符串 <code>s</code> ，则认为 <code>s</code> 是 <code>words</code> 的首字母缩略词。例如，<code>\"ab\"</code> 可以由 <code>[\"apple\", \"banana\"]</code> 形成，但是无法从 <code>[\"bear\", \"aardvark\"]</code> 形成。</p>\n\n<p>如果 <code>s</code> 是 <code>words</code> 的首字母缩略词，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"alice\",\"bob\",\"charlie\"], s = \"abc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>words 中 \"alice\"、\"bob\" 和 \"charlie\" 的第一个字符分别是 'a'、'b' 和 'c'。因此，s = \"abc\" 是首字母缩略词。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"an\",\"apple\"], s = \"a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>words 中 \"an\" 和 \"apple\" 的第一个字符分别是 'a' 和 'a'。\n串联这些字符形成的首字母缩略词是 \"aa\" 。\n因此，s = \"a\" 不是首字母缩略词。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"never\",\"gonna\",\"give\",\"up\",\"on\",\"you\"], s = \"ngguoy\"\n<strong>输出：</strong>true\n<strong>解释：</strong>串联数组 words 中每个字符串的第一个字符，得到字符串 \"ngguoy\" 。\n因此，s = \"ngguoy\" 是首字母缩略词。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2829.k-avoiding 数组的最小总和",
        "hardRate": "MEDIUM",
        "passRate": "60.46%",
        "problemsUrl": "https://leetcode.cn/problems/determine-the-minimum-sum-of-a-k-avoiding-array/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-the-minimum-sum-of-a-k-avoiding-array/solution",
        "problemsDesc": "<p>给你两个整数 <code>n</code> 和 <code>k</code> 。</p>\n\n<p>对于一个由 <strong>不同</strong> 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 <strong>k-avoiding</strong> 数组。</p>\n\n<p>返回长度为 <code>n</code> 的 <strong>k-avoiding</strong> 数组的可能的最小总和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, k = 4\n<strong>输出：</strong>18\n<strong>解释：</strong>设若 k-avoiding 数组为 [1,2,4,5,6] ，其元素总和为 18 。\n可以证明不存在总和小于 18 的 k-avoiding 数组。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>可以构造数组 [1,2] ，其元素总和为 3 。\n可以证明不存在总和小于 3 的 k-avoiding 数组。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2830.销售利润最大化",
        "hardRate": "MEDIUM",
        "passRate": "45.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 表示数轴上的房屋数量，编号从 <code>0</code> 到 <code>n - 1</code> 。</p>\n\n<p>另给你一个二维整数数组 <code>offers</code> ，其中 <code>offers[i] = [start<sub>i</sub>, end<sub>i</sub>, gold<sub>i</sub>]</code> 表示第 <code>i</code> 个买家想要以 <code>gold<sub>i</sub></code> 枚金币的价格购买从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的所有房屋。</p>\n\n<p>作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。</p>\n\n<p>返回你可以赚取的金币的最大数目。</p>\n\n<p><strong>注意</strong> 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n有 5 所房屋，编号从 0 到 4 ，共有 3 个购买要约。\n将位于 [0,0] 范围内的房屋以 1 金币的价格出售给第 1 位买家，并将位于 [1,3] 范围内的房屋以 2 金币的价格出售给第 3 位买家。\n可以证明我们最多只能获得 3 枚金币。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]\n<strong>输出：</strong>10\n<strong>解释：</strong>有 5 所房屋，编号从 0 到 4 ，共有 3 个购买要约。\n将位于 [0,2] 范围内的房屋以 10 金币的价格出售给第 2 位买家。\n可以证明我们最多只能获得 10 枚金币。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= offers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>offers[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= gold<sub>i</sub> &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2831.找出最长等值子数组",
        "hardRate": "MEDIUM",
        "passRate": "48.66%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-equal-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-equal-subarray/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>如果子数组中所有元素都相等，则认为子数组是一个 <strong>等值子数组</strong> 。注意，空数组是 <strong>等值子数组</strong> 。</p>\n\n<p>从 <code>nums</code> 中删除最多 <code>k</code> 个元素后，返回可能的最长等值子数组的长度。</p>\n\n<p><strong>子数组</strong> 是数组中一个连续且可能为空的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,3,1,3], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>最优的方案是删除下标 2 和下标 4 的元素。\n删除后，nums 等于 [1, 3, 3, 3] 。\n最长等值子数组从 i = 1 开始到 j = 3 结束，长度等于 3 。\n可以证明无法创建更长的等值子数组。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,2,1,1], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>最优的方案是删除下标 2 和下标 3 的元素。 \n删除后，nums 等于 [1, 1, 1, 1] 。 \n数组自身就是等值子数组，长度等于 4 。 \n可以证明无法创建更长的等值子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2832.每个元素为最大值的最大范围",
        "hardRate": "MEDIUM",
        "passRate": "62.64%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-range-that-each-element-is-maximum-in-it/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-range-that-each-element-is-maximum-in-it/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2833.距离原点最远的点",
        "hardRate": "EASY",
        "passRate": "79.20%",
        "problemsUrl": "https://leetcode.cn/problems/furthest-point-from-origin/",
        "solutionsUrl": "https://leetcode.cn/problems/furthest-point-from-origin/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的字符串 <code>moves</code> ，该字符串仅由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成。字符串表示你在一条原点为 <code>0</code> 的数轴上的若干次移动。</p>\n\n<p>你的初始位置就在原点（<code>0</code>），第 <code>i</code> 次移动过程中，你可以根据对应字符选择移动方向：</p>\n\n<ul>\n\t<li>如果 <code>moves[i] = 'L'</code> 或 <code>moves[i] = '_'</code> ，可以选择向左移动一个单位距离</li>\n\t<li>如果 <code>moves[i] = 'R'</code> 或 <code>moves[i] = '_'</code> ，可以选择向右移动一个单位距离</li>\n</ul>\n\n<p>移动 <code>n</code> 次之后，请你找出可以到达的距离原点 <strong>最远</strong> 的点，并返回 <strong>从原点到这一点的距离</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>moves = \"L_RL__R\"\n<strong>输出：</strong>3\n<strong>解释：</strong>可以到达的距离原点 0 最远的点是 -3 ，移动的序列为 \"LLRLLLR\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>moves = \"_R__LL_\"\n<strong>输出：</strong>5\n<strong>解释：</strong>可以到达的距离原点 0 最远的点是 -5 ，移动的序列为 \"LRLLLLL\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>moves = \"_______\"\n<strong>输出：</strong>7\n<strong>解释：</strong>可以到达的距离原点 0 最远的点是 7 ，移动的序列为 \"RRRRRRR\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length == n &lt;= 50</code></li>\n\t<li><code>moves</code> 仅由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2834.找出美丽数组的最小和",
        "hardRate": "MEDIUM",
        "passRate": "35.64%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/solution",
        "problemsDesc": "<p>给你两个正整数：<code>n</code> 和 <code>target</code> 。</p>\n\n<p>如果数组 <code>nums</code> 满足下述条件，则称其为 <strong>美丽数组</strong> 。</p>\n\n<ul>\n\t<li><code>nums.length == n</code>.</li>\n\t<li><code>nums</code> 由两两互不相同的正整数组成。</li>\n\t<li>在范围 <code>[0, n-1]</code> 内，<strong>不存在 </strong>两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code> ，使得 <code>nums[i] + nums[j] == target</code> 。</li>\n</ul>\n\n<p>返回符合条件的美丽数组所可能具备的 <strong>最小</strong> 和，并对结果进行取模 <code>10<sup>9</sup>&nbsp;+ 7</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, target = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>nums = [1,3] 是美丽数组。\n- nums 的长度为 n = 2 。\n- nums 由两两互不相同的正整数组成。\n- 不存在两个不同下标 i 和 j ，使得 nums[i] + nums[j] == 3 。\n可以证明 4 是符合条件的美丽数组所可能具备的最小和。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, target = 3\n<strong>输出：</strong>8\n<strong>解释：</strong>\nnums = [1,3,4] 是美丽数组。 \n- nums 的长度为 n = 3 。 \n- nums 由两两互不相同的正整数组成。 \n- 不存在两个不同下标 i 和 j ，使得 nums[i] + nums[j] == 3 。\n可以证明 8 是符合条件的美丽数组所可能具备的最小和。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, target = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>nums = [1] 是美丽数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2835.使子序列的和等于目标的最少操作次数",
        "hardRate": "HARD",
        "passRate": "36.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-form-subsequence-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-form-subsequence-with-target-sum/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，它包含 <strong>非负</strong>&nbsp;整数，且全部为 <code>2</code>&nbsp;的幂，同时给你一个整数&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>一次操作中，你必须对数组做以下修改：</p>\n\n<ul>\n\t<li>选择数组中一个元素&nbsp;<code>nums[i]</code>&nbsp;，满足&nbsp;<code>nums[i] &gt; 1</code>&nbsp;。</li>\n\t<li>将&nbsp;<code>nums[i]</code>&nbsp;从数组中删除。</li>\n\t<li>在 <code>nums</code>&nbsp;的 <strong>末尾</strong>&nbsp;添加 <strong>两个</strong>&nbsp;数，值都为&nbsp;<code>nums[i] / 2</code>&nbsp;。</li>\n</ul>\n\n<p>你的目标是让 <code>nums</code>&nbsp;的一个 <strong>子序列</strong>&nbsp;的元素和等于&nbsp;<code>target</code>&nbsp;，请你返回达成这一目标的 <strong>最少操作次数</strong>&nbsp;。如果无法得到这样的子序列，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>数组中一个 <strong>子序列</strong>&nbsp;是通过删除原数组中一些元素，并且不改变剩余元素顺序得到的剩余数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,8], target = 7\n<b>输出：</b>1\n<b>解释：</b>第一次操作中，我们选择元素 nums[2] 。数组变为 nums = [1,2,4,4] 。\n这时候，nums 包含子序列 [1,2,4] ，和为 7 。\n无法通过更少的操作得到和为 7 的子序列。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,32,1,2], target = 12\n<b>输出：</b>2\n<b>解释：</b>第一次操作中，我们选择元素 nums[1] 。数组变为 nums = [1,1,2,16,16] 。\n第二次操作中，我们选择元素 nums[3] 。数组变为 nums = [1,1,2,16,8,8] 。\n这时候，nums 包含子序列 [1,1,2,8] ，和为 12 。\n无法通过更少的操作得到和为 12 的子序列。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,32,1], target = 35\n<b>输出：</b>-1\n<b>解释：</b>无法得到和为 35 的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2<sup>30</sup></code></li>\n\t<li><code>nums</code>&nbsp;只包含非负整数，且均为 2 的幂。</li>\n\t<li><code>1 &lt;= target &lt; 2<sup>31</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2836.在传球游戏中最大化函数值",
        "hardRate": "HARD",
        "passRate": "41.95%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>receiver</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>总共有&nbsp;<code>n</code>&nbsp;名玩家，玩家 <strong>编号</strong>&nbsp;互不相同，且为&nbsp;<code>[0, n - 1]</code>&nbsp;中的整数。这些玩家玩一个传球游戏，<code>receiver[i]</code>&nbsp;表示编号为 <code>i</code>&nbsp;的玩家会传球给编号为 <code>receiver[i]</code>&nbsp;的玩家。玩家可以传球给自己，也就是说&nbsp;<code>receiver[i]</code>&nbsp;可能等于&nbsp;<code>i</code>&nbsp;。</p>\n\n<p>你需要从 <code>n</code>&nbsp;名玩家中选择一名玩家作为游戏开始时唯一手中有球的玩家，球会被传 <strong>恰好</strong>&nbsp;<code>k</code>&nbsp;次。</p>\n\n<p>如果选择编号为 <code>x</code>&nbsp;的玩家作为开始玩家，定义函数&nbsp;<code>f(x)</code>&nbsp;表示从编号为&nbsp;<code>x</code>&nbsp;的玩家开始，<code>k</code>&nbsp;次传球内所有接触过球玩家的编号之&nbsp;<strong>和</strong>&nbsp;，如果有玩家多次触球，则 <strong>累加多次</strong>&nbsp;。换句话说，&nbsp;<code>f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver<sup>(k)</sup>[x]</code>&nbsp;。</p>\n\n<p>你的任务时选择开始玩家 <code>x</code>&nbsp;，目的是<strong>&nbsp;最大化</strong>&nbsp;<code>f(x)</code>&nbsp;。</p>\n\n<p>请你返回函数的 <strong>最大值</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong><code>receiver</code>&nbsp;可能含有重复元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<table border=\"1\" cellspacing=\"3\" style=\"border-collapse: separate; text-align: center;\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">传递次数</th>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">传球者编号</th>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">接球者编号</th>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">x + 所有接球者编号</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">&nbsp;</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">&nbsp;</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">&nbsp;</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">1</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">1</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">3</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">1</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">0</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">3</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">3</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">0</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">4</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">1</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">6</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<pre>\n<b>输入：</b>receiver = [2,0,1], k = 4\n<b>输出：</b>6\n<b>解释：</b>上表展示了从编号为 x = 2 开始的游戏过程。\n从表中可知，f(2) 等于 6 。\n6 是能得到最大的函数值。\n所以输出为 6 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<table border=\"1\" cellspacing=\"3\" style=\"border-collapse: separate; text-align: center;\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">传递次数</th>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">传球者编号</th>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">接球者编号</th>\n\t\t\t<th style=\"padding: 5px; border: 1px solid black;\">x + 所有接球者编号</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">&nbsp;</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">&nbsp;</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">&nbsp;</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">4</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">1</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">4</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">3</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">7</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">3</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">9</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">3</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">2</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">1</td>\n\t\t\t<td style=\"padding: 5px; border: 1px solid black;\">10</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<pre>\n<b>输入：</b>receiver = [1,1,1,2,3], k = 3\n<b>输出：</b>10\n<b>解释：</b>上表展示了从编号为 x = 4 开始的游戏过程。\n从表中可知，f(4) 等于 10 。\n10 是能得到最大的函数值。\n所以输出为 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= receiver.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= receiver[i] &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2837.总旅行距离",
        "hardRate": "EASY",
        "passRate": "67.50%",
        "problemsUrl": "https://leetcode.cn/problems/total-traveled-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/total-traveled-distance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2838.英雄可以获得的最大金币数",
        "hardRate": "MEDIUM",
        "passRate": "55.44%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-coins-heroes-can-collect/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-coins-heroes-can-collect/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2839.判断通过操作能否让字符串相等 I",
        "hardRate": "EASY",
        "passRate": "64.61%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-strings-can-be-made-equal-with-operations-i/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-strings-can-be-made-equal-with-operations-i/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s1</code> 和&nbsp;<code>s2</code>&nbsp;，两个字符串的长度都为&nbsp;<code>4</code>&nbsp;，且只包含 <strong>小写</strong> 英文字母。</p>\n\n<p>你可以对两个字符串中的 <strong>任意一个</strong>&nbsp;执行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>选择两个下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;且满足&nbsp;<code>j - i = 2</code>&nbsp;，然后 <strong>交换</strong> 这个字符串中两个下标对应的字符。</li>\n</ul>\n\n<p>如果你可以让字符串<em>&nbsp;</em><code>s1</code><em> </em>和<em>&nbsp;</em><code>s2</code>&nbsp;相等，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s1 = \"abcd\", s2 = \"cdab\"\n<b>输出：</b>true\n<strong>解释：</strong> 我们可以对 s1 执行以下操作：\n- 选择下标 i = 0 ，j = 2 ，得到字符串 s1 = \"cbad\" 。\n- 选择下标 i = 1 ，j = 3 ，得到字符串 s1 = \"cdab\" = s2 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s1 = \"abcd\", s2 = \"dacb\"\n<b>输出：</b>false\n<b>解释：</b>无法让两个字符串相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length == 4</code></li>\n\t<li><code>s1</code> 和&nbsp;<code>s2</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2840.判断通过操作能否让字符串相等 II",
        "hardRate": "MEDIUM",
        "passRate": "62.32%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-strings-can-be-made-equal-with-operations-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-strings-can-be-made-equal-with-operations-ii/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;，两个字符串长度都为&nbsp;<code>n</code>&nbsp;，且只包含&nbsp;<strong>小写&nbsp;</strong>英文字母。</p>\n\n<p>你可以对两个字符串中的 <strong>任意一个</strong>&nbsp;执行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>选择两个下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，满足 <code>i &lt; j</code>&nbsp;且 <code>j - i</code>&nbsp;是 <strong>偶数</strong>，然后 <strong>交换</strong> 这个字符串中两个下标对应的字符。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>如果你可以让字符串<em>&nbsp;</em><code>s1</code><em> </em>和<em>&nbsp;</em><code>s2</code>&nbsp;相等，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s1 = \"abcdba\", s2 = \"cabdab\"\n<b>输出：</b>true\n<b>解释：</b>我们可以对 s1 执行以下操作：\n- 选择下标 i = 0 ，j = 2 ，得到字符串 s1 = \"cbadba\" 。\n- 选择下标 i = 2 ，j = 4 ，得到字符串 s1 = \"cbbdaa\" 。\n- 选择下标 i = 1 ，j = 5 ，得到字符串 s1 = \"cabdab\" = s2 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s1 = \"abe\", s2 = \"bea\"\n<b>输出：</b>false\n<b>解释：</b>无法让两个字符串相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s1.length == s2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s1</code> 和&nbsp;<code>s2</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2841.几乎唯一子数组的最大和",
        "hardRate": "MEDIUM",
        "passRate": "44.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和两个正整数&nbsp;<code>m</code>&nbsp;和&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;中长度为 <code>k</code>&nbsp;的&nbsp;<strong>几乎唯一</strong>&nbsp;子数组的 <strong>最大和</strong>&nbsp;，如果不存在几乎唯一子数组，请你返回 <code>0</code>&nbsp;。</p>\n\n<p>如果 <code>nums</code>&nbsp;的一个子数组有至少 <code>m</code>&nbsp;个互不相同的元素，我们称它是 <strong>几乎唯一</strong>&nbsp;子数组。</p>\n\n<p>子数组指的是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,6,7,3,1,7], m = 3, k = 4\n<b>输出：</b>18\n<b>解释：</b>总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,9,9,2,4,5,4], m = 1, k = 3\n<b>输出：</b>23\n<b>解释：</b>总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1,2,1,2,1], m = 3, k = 3\n<b>输出：</b>0\n<b>解释：</b>输入数组中不存在长度为 <code>k = 3</code> 的子数组含有至少  <code>m = 3</code> 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m &lt;= k &lt;= nums.length</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2842.统计一个字符串的 k 子序列美丽值最大的数目",
        "hardRate": "HARD",
        "passRate": "30.29%",
        "problemsUrl": "https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty/",
        "solutionsUrl": "https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p><strong>k 子序列</strong>指的是 <code>s</code>&nbsp;的一个长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;，且所有字符都是 <strong>唯一</strong>&nbsp;的，也就是说每个字符在子序列里只出现过一次。</p>\n\n<p>定义&nbsp;<code>f(c)</code>&nbsp;为字符 <code>c</code>&nbsp;在 <code>s</code>&nbsp;中出现的次数。</p>\n\n<p>k 子序列的 <strong>美丽值</strong>&nbsp;定义为这个子序列中每一个字符 <code>c</code>&nbsp;的&nbsp;<code>f(c)</code>&nbsp;之 <strong>和</strong>&nbsp;。</p>\n\n<p>比方说，<code>s = \"abbbdd\"</code>&nbsp;和&nbsp;<code>k = 2</code>&nbsp;，我们有：</p>\n\n<ul>\n\t<li><code>f('a') = 1</code>, <code>f('b') = 3</code>, <code>f('d') = 2</code></li>\n\t<li><code>s</code>&nbsp;的部分 k 子序列为：\n\t<ul>\n\t\t<li><code>\"<em><strong>ab</strong></em>bbdd\"</code> -&gt; <code>\"ab\"</code>&nbsp;，美丽值为&nbsp;<code>f('a') + f('b') = 4</code></li>\n\t\t<li><code>\"<em><strong>a</strong></em>bbb<em><strong>d</strong></em>d\"</code> -&gt; <code>\"ad\"</code>&nbsp;，美丽值为&nbsp;<code>f('a') + f('d') = 3</code></li>\n\t\t<li><code>\"a<em><strong>b</strong></em>bb<em><strong>d</strong></em>d\"</code> -&gt; <code>\"bd\"</code>&nbsp;，美丽值为&nbsp;<code>f('b') + f('d') = 5</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回一个整数，表示所有 <strong>k 子序列&nbsp;</strong>里面 <strong>美丽值 </strong>是&nbsp;<strong>最大值</strong>&nbsp;的子序列数目。由于答案可能很大，将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p>一个字符串的子序列指的是从原字符串里面删除一些字符（也可能一个字符也不删除），不改变剩下字符顺序连接得到的新字符串。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>f(c)</code> 指的是字符&nbsp;<code>c</code>&nbsp;在字符串&nbsp;<code>s</code>&nbsp;的出现次数，不是在 k 子序列里的出现次数。</li>\n\t<li>两个 k 子序列如果有任何一个字符在原字符串中的下标不同，则它们是两个不同的子序列。所以两个不同的 k 子序列可能产生相同的字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"bcca\", k = 2\n<b>输出：</b>4\n<b>解释：</b><span style=\"white-space: normal\">s 中我们有 f('a') = 1 ，f('b') = 1 和 f('c') = 2 。</span>\ns 的 k 子序列为：\n<em><strong>bc</strong></em>ca ，美丽值为 f('b') + f('c') = 3\n<em><strong>b</strong></em>c<em><strong>c</strong></em>a ，美丽值为 f('b') + f('c') = 3\n<em><strong>b</strong></em>cc<em><strong>a</strong></em> ，美丽值为 f('b') + f('a') = 2\nb<em><strong>c</strong></em>c<em><strong>a</strong></em><strong> </strong>，美丽值为 f('c') + f('a') = 3\nbc<em><strong>ca</strong></em> ，美丽值为 f('c') + f('a') = 3\n总共有 4 个 k 子序列美丽值为最大值 3 。\n所以答案为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abbcd\", k = 4\n<b>输出：</b>2\n<b>解释：</b><span style=\"white-space: normal\">s 中我们有 f('a') = 1 ，f('b') = 2&nbsp;，f('c') = 1&nbsp;和</span> f('d') = 1 。\ns 的 k 子序列为：\n<em><strong>ab</strong></em>b<em><strong>cd</strong></em> ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5\n<span style=\"white-space: normal;\"><b><i>a</i></b></span>b<em><strong>bcd</strong></em> ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5 \n总共有 2 个 k 子序列美丽值为最大值 5 。\n所以答案为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2843.统计对称整数的数目",
        "hardRate": "EASY",
        "passRate": "71.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-symmetric-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-symmetric-integers/solution",
        "problemsDesc": "<p>给你两个正整数 <code>low</code> 和 <code>high</code> 。</p>\n\n<p>对于一个由 <code>2 * n</code> 位数字组成的整数 <code>x</code> ，如果其前 <code>n</code> 位数字之和与后 <code>n</code> 位数字之和相等，则认为这个数字是一个对称整数。</p>\n\n<p>返回在 <code>[low, high]</code> 范围内的 <strong>对称整数的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>low = 1, high = 100\n<strong>输出：</strong>9\n<strong>解释：</strong>在 1 到 100 范围内共有 9 个对称整数：11、22、33、44、55、66、77、88 和 99 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>low = 1200, high = 1230\n<strong>输出：</strong>4\n<strong>解释：</strong>在 1200 到 1230 范围内共有 4 个对称整数：1203、1212、1221 和 1230 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2844.生成特殊数字的最少操作",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-special-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-special-number/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>num</code> ，表示一个非负整数。</p>\n\n<p>在一次操作中，您可以选择 <code>num</code> 的任意一位数字并将其删除。请注意，如果你删除 <code>num</code> 中的所有数字，则 <code>num</code> 变为 <code>0</code>。</p>\n\n<p>返回最少需要多少次操作可以使 <code>num</code> 变成特殊数字。</p>\n\n<p>如果整数 <code>x</code> 能被 <code>25</code> 整除，则该整数 <code>x</code> 被认为是特殊数字。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"2245047\"\n<strong>输出：</strong>2\n<strong>解释：</strong>删除数字 num[5] 和 num[6] ，得到数字 \"22450\" ，可以被 25 整除。\n可以证明要使数字变成特殊数字，最少需要删除 2 位数字。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"2908305\"\n<strong>输出：</strong>3\n<strong>解释：</strong>删除 num[3]、num[4] 和 num[6] ，得到数字 \"2900\" ，可以被 25 整除。\n可以证明要使数字变成特殊数字，最少需要删除 3 位数字。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"10\"\n<strong>输出：</strong>1\n<strong>解释：</strong>删除 num[0] ，得到数字 \"0\" ，可以被 25 整除。\n可以证明要使数字变成特殊数字，最少需要删除 1 位数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 100</code></li>\n\t<li><code>num</code> 仅由数字 <code>'0'</code> 到 <code>'9'</code> 组成</li>\n\t<li><code>num</code> 不含任何前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2845.统计趣味子数组的数目",
        "hardRate": "MEDIUM",
        "passRate": "37.65%",
        "problemsUrl": "https://leetcode.cn/problems/count-of-interesting-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-of-interesting-subarrays/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，以及整数 <code>modulo</code> 和整数 <code>k</code> 。</p>\n\n<p>请你找出并统计数组中 <strong>趣味子数组</strong> 的数目。</p>\n\n<p>如果 <strong>子数组</strong> <code>nums[l..r]</code> 满足下述条件，则称其为 <strong>趣味子数组</strong> ：</p>\n\n<ul>\n\t<li>在范围 <code>[l, r]</code> 内，设 <code>cnt</code> 为满足 <code>nums[i] % modulo == k</code> 的索引 <code>i</code> 的数量。并且 <code>cnt % modulo == k</code> 。</li>\n</ul>\n\n<p>以整数形式表示并返回趣味子数组的数目。<em> </em></p>\n\n<p><span><strong>注意：</strong>子数组是数组中的一个连续非空的元素序列。</span></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,4], modulo = 2, k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>在这个示例中，趣味子数组分别是： \n子数组 nums[0..0] ，也就是 [3] 。 \n- 在范围 [0, 0] 内，只存在 1 个下标 i = 0 满足 nums[i] % modulo == k 。\n- 因此 cnt = 1 ，且 cnt % modulo == k 。\n子数组 nums[0..1] ，也就是 [3,2] 。\n- 在范围 [0, 1] 内，只存在 1 个下标 i = 0 满足 nums[i] % modulo == k 。\n- 因此 cnt = 1 ，且 cnt % modulo == k 。\n子数组 nums[0..2] ，也就是 [3,2,4] 。\n- 在范围 [0, 2] 内，只存在 1 个下标 i = 0 满足 nums[i] % modulo == k 。\n- 因此 cnt = 1 ，且 cnt % modulo == k 。\n可以证明不存在其他趣味子数组。因此，答案为 3 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,9,6], modulo = 3, k = 0\n<strong>输出：</strong>2\n<strong>解释：</strong>在这个示例中，趣味子数组分别是： \n子数组 nums[0..3] ，也就是 [3,1,9,6] 。\n- 在范围 [0, 3] 内，只存在 3 个下标 i = 0, 2, 3 满足 nums[i] % modulo == k 。\n- 因此 cnt = 3 ，且 cnt % modulo == k 。\n子数组 nums[1..1] ，也就是 [1] 。\n- 在范围 [1, 1] 内，不存在下标满足 nums[i] % modulo == k 。\n- 因此 cnt = 0 ，且 cnt % modulo == k 。\n可以证明不存在其他趣味子数组，因此答案为 2 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5 </sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= modulo &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt; modulo</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2846.边权重均等查询",
        "hardRate": "HARD",
        "passRate": "60.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree/solution",
        "problemsDesc": "<p>现有一棵由 <code>n</code> 个节点组成的无向树，节点按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code> 表示树中存在一条位于节点 <code>u<sub>i</sub></code> 和节点 <code>v<sub>i</sub></code> 之间、权重为 <code>w<sub>i</sub></code> 的边。</p>\n\n<p>另给你一个长度为 <code>m</code> 的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 。对于每条查询，请你找出使从 <code>a<sub>i</sub></code> 到 <code>b<sub>i</sub></code> 路径上每条边的权重相等所需的 <strong>最小操作次数</strong> 。在一次操作中，你可以选择树上的任意一条边，并将其权重更改为任意值。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>查询之间 <strong>相互独立</strong> 的，这意味着每条新的查询时，树都会回到 <strong>初始状态</strong> 。</li>\n\t<li>从 <code>a<sub>i</sub></code> 到 <code>b<sub>i</sub></code>的路径是一个由 <strong>不同</strong> 节点组成的序列，从节点 <code>a<sub>i</sub></code> 开始，到节点 <code>b<sub>i</sub></code> 结束，且序列中相邻的两个节点在树中共享一条边。</li>\n</ul>\n\n<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 条查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/11/graph-6-1.png\" style=\"width: 339px; height: 344px;\" />\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,2],[4,5,2],[5,6,2]], queries = [[0,3],[3,6],[2,6],[0,6]]\n<strong>输出：</strong>[0,0,1,3]\n<strong>解释：</strong>第 1 条查询，从节点 0 到节点 3 的路径中的所有边的权重都是 1 。因此，答案为 0 。\n第 2 条查询，从节点 3 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 0 。\n第 3 条查询，将边 [2,3] 的权重变更为 2 。在这次操作之后，从节点 2 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 1 。\n第 4 条查询，将边 [0,1]、[1,2]、[2,3] 的权重变更为 2 。在这次操作之后，从节点 0 到节点 6 的路径中的所有边的权重都是 2 。因此，答案为 3 。\n对于每条查询 queries[i] ，可以证明 answer[i] 是使从 a<sub>i</sub> 到 b<sub>i</sub> 的路径中的所有边的权重相等的最小操作次数。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/11/graph-9-1.png\" style=\"width: 472px; height: 370px;\" />\n<pre>\n<strong>输入：</strong>n = 8, edges = [[1,2,6],[1,3,4],[2,4,6],[2,5,3],[3,6,6],[3,0,8],[7,0,2]], queries = [[4,6],[0,4],[6,5],[7,4]]\n<strong>输出：</strong>[1,2,2,3]\n<strong>解释：</strong>第 1 条查询，将边 [1,3] 的权重变更为 6 。在这次操作之后，从节点 4 到节点 6 的路径中的所有边的权重都是 6 。因此，答案为 1 。\n第 2 条查询，将边 [0,3]、[3,1] 的权重变更为 6 。在这次操作之后，从节点 0 到节点 4 的路径中的所有边的权重都是 6 。因此，答案为 2 。\n第 3 条查询，将边 [1,3]、[5,2] 的权重变更为 6 。在这次操作之后，从节点 6 到节点 5 的路径中的所有边的权重都是 6 。因此，答案为 2 。\n第 4 条查询，将边 [0,7]、[0,3]、[1,3] 的权重变更为 6 。在这次操作之后，从节点 7 到节点 4 的路径中的所有边的权重都是 6 。因此，答案为 3 。\n对于每条查询 queries[i] ，可以证明 answer[i] 是使从 a<sub>i</sub> 到 b<sub>i</sub> 的路径中的所有边的权重相等的最小操作次数。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub> &lt;= 26</code></li>\n\t<li>生成的输入满足 <code>edges</code> 表示一棵有效的树</li>\n\t<li><code>1 &lt;= queries.length == m &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2847.给定数字乘积的最小数字",
        "hardRate": "MEDIUM",
        "passRate": "47.92%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-number-with-given-digit-product/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-number-with-given-digit-product/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2848.与车相交的点",
        "hardRate": "EASY",
        "passRate": "77.13%",
        "problemsUrl": "https://leetcode.cn/problems/points-that-intersect-with-cars/",
        "solutionsUrl": "https://leetcode.cn/problems/points-that-intersect-with-cars/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>nums</code> 表示汽车停放在数轴上的坐标。对于任意下标 <code>i</code>，<code>nums[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，其中 <code>start<sub>i</sub></code> 是第 <code>i</code> 辆车的起点，<code>end<sub>i</sub></code> 是第 <code>i</code> 辆车的终点。</p>\n\n<p>返回数轴上被车 <strong>任意部分</strong> 覆盖的整数点的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[3,6],[1,5],[4,7]]\n<strong>输出：</strong>7\n<strong>解释：</strong>从 1 到 7 的所有点都至少与一辆车相交，因此答案为 7 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,3],[5,8]]\n<strong>输出：</strong>7\n<strong>解释：</strong>1、2、3、5、6、7、8 共计 7 个点满足至少与一辆车相交，因此答案为 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>nums[i].length == 2</code></li>\n\t<li><code><font face=\"monospace\">1 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;= 100</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2849.判断能否在给定时间到达单元格",
        "hardRate": "MEDIUM",
        "passRate": "26.36%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-a-cell-is-reachable-at-a-given-time/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-a-cell-is-reachable-at-a-given-time/solution",
        "problemsDesc": "<p>给你四个整数 <code>sx</code>、<code>sy</code>、<code>fx</code>、<code>fy</code>&nbsp; 以及一个 <strong>非负整数</strong> <code>t</code> 。</p>\n\n<p>在一个无限的二维网格中，你从单元格 <code>(sx, sy)</code> 开始出发。每一秒，你 <strong>必须</strong> 移动到任一与之前所处单元格相邻的单元格中。</p>\n\n<p>如果你能在 <strong>恰好 </strong><code>t</code><strong> 秒</strong> 后到达单元格<em> </em><code>(fx, fy)</code> ，返回 <code>true</code> ；否则，返回&nbsp; <code>false</code> 。</p>\n\n<p>单元格的 <strong>相邻单元格</strong> 是指该单元格周围与其至少共享一个角的 8 个单元格。你可以多次访问同一个单元格。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/05/example2.svg\" style=\"width: 443px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>sx = 2, sy = 4, fx = 7, fy = 7, t = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>从单元格 (2, 4) 开始出发，穿过上图标注的单元格，可以在恰好 6 秒后到达单元格 (7, 7) 。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/05/example1.svg\" style=\"width: 383px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>sx = 3, sy = 1, fx = 7, fy = 3, t = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>从单元格 (3, 1) 开始出发，穿过上图标注的单元格，至少需要 4 秒后到达单元格 (7, 3) 。 因此，无法在 3 秒后到达单元格 (7, 3) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sx, sy, fx, fy &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= t &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2850.将石头分散到网格图的最少移动次数",
        "hardRate": "MEDIUM",
        "passRate": "58.36%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/solution",
        "problemsDesc": "<p>给你一个大小为 <code>3 * 3</code>&nbsp;，下标从 <strong>0</strong>&nbsp;开始的二维整数矩阵&nbsp;<code>grid</code>&nbsp;，分别表示每一个格子里石头的数目。网格图中总共恰好有&nbsp;<code>9</code>&nbsp;个石头，一个格子里可能会有 <strong>多个</strong>&nbsp;石头。</p>\n\n<p>每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。</p>\n\n<p>请你返回每个格子恰好有一个石头的 <strong>最少移动次数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/23/example1-3.svg\" style=\"width: 401px; height: 281px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,0],[1,1,1],[1,2,1]]\n<b>输出：</b>3\n<b>解释：</b>让每个格子都有一个石头的一个操作序列为：\n1 - 将一个石头从格子 (2,1) 移动到 (2,2) 。\n2 - 将一个石头从格子 (2,2) 移动到 (1,2) 。\n3 - 将一个石头从格子 (1,2) 移动到 (0,2) 。\n总共需要 3 次操作让每个格子都有一个石头。\n让每个格子都有一个石头的最少操作次数为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/08/23/example2-2.svg\" style=\"width: 401px; height: 281px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,3,0],[1,0,0],[1,0,3]]\n<b>输出：</b>4\n<b>解释：</b>让每个格子都有一个石头的一个操作序列为：\n1 - 将一个石头从格子 (0,1) 移动到 (0,2) 。\n2 - 将一个石头从格子 (0,1) 移动到 (1,1) 。\n3 - 将一个石头从格子 (2,2) 移动到 (1,2) 。\n4 - 将一个石头从格子 (2,2) 移动到 (2,1) 。\n总共需要 4 次操作让每个格子都有一个石头。\n让每个格子都有一个石头的最少操作次数为 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>grid.length == grid[i].length == 3</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 9</code></li>\n\t<li><code>grid</code>&nbsp;中元素之和为&nbsp;<code>9</code> 。</li>\n</ul>\n",
        "isPlus": false
    }
]