[
    {
        "problemsName": " 3651.打家劫舍",
        "hardRate": "MEDIUM",
        "passRate": "58.92%",
        "problemsUrl": "https://leetcode.cn/problems/Gu0c2T/",
        "solutionsUrl": "https://leetcode.cn/problems/Gu0c2T/solution",
        "problemsDesc": "<p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code>&nbsp;，请计算<strong>&nbsp;不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums =<strong> </strong>[1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums =<strong> </strong>[2,7,9,3,1]\n<strong>输出：</strong>12\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n&nbsp;    偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 198&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/house-robber/\">https://leetcode-cn.com/problems/house-robber/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3652.打家劫舍 II",
        "hardRate": "MEDIUM",
        "passRate": "47.39%",
        "problemsUrl": "https://leetcode.cn/problems/PzWKhm/",
        "solutionsUrl": "https://leetcode.cn/problems/PzWKhm/solution",
        "problemsDesc": "<p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算&nbsp;<strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 213&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">https://leetcode-cn.com/problems/house-robber-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3653.粉刷房子",
        "hardRate": "MEDIUM",
        "passRate": "77.07%",
        "problemsUrl": "https://leetcode.cn/problems/JEj789/",
        "solutionsUrl": "https://leetcode.cn/problems/JEj789/solution",
        "problemsDesc": "<p>假如有一排房子，共 <code>n</code> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>\n\n<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个&nbsp;<code>n x 3</code><em>&nbsp;</em>的正整数矩阵 <code>costs</code> 来表示的。</p>\n\n<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code>&nbsp;表示第 1 号房子粉刷成绿色的花费，以此类推。</p>\n\n<p>请计算出粉刷完所有房子最少的花费成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>costs = [[17,2,17],[16,16,5],[14,3,19]]\n<strong>输出: </strong>10\n<strong>解释: </strong>将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色<strong>。</strong>\n&nbsp;    最少花费: 2 + 5 + 3 = 10。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>costs = [[7,6,2]]\n<strong>输出: 2</strong>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>costs[i].length == 3</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= costs[i][j] &lt;= 20</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 256&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/paint-house/\">https://leetcode-cn.com/problems/paint-house/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3654.将字符串翻转到单调递增",
        "hardRate": "MEDIUM",
        "passRate": "68.22%",
        "problemsUrl": "https://leetcode.cn/problems/cyJERH/",
        "solutionsUrl": "https://leetcode.cn/problems/cyJERH/solution",
        "problemsDesc": "<p>如果一个由&nbsp;<code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code>&nbsp;组成的字符串，是以一些 <code>&#39;0&#39;</code>（可能没有 <code>&#39;0&#39;</code>）后面跟着一些 <code>&#39;1&#39;</code>（也可能没有 <code>&#39;1&#39;</code>）的形式组成的，那么该字符串是&nbsp;<strong>单调递增&nbsp;</strong>的。</p>\n\n<p>我们给出一个由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code>&nbsp;组成的字符串 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"caret-color: rgb(199, 37, 78); font-size: 12.600000381469727px; background-color: rgb(249, 242, 244);\">s</span></font>，我们可以将任何&nbsp;<code>&#39;0&#39;</code> 翻转为&nbsp;<code>&#39;1&#39;</code>&nbsp;或者将&nbsp;<code>&#39;1&#39;</code>&nbsp;翻转为&nbsp;<code>&#39;0&#39;</code>。</p>\n\n<p>返回使 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"caret-color: rgb(199, 37, 78); font-size: 12.600000381469727px; background-color: rgb(249, 242, 244);\">s</span></font>&nbsp;<strong>单调递增&nbsp;</strong>的最小翻转次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;00110&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>我们翻转最后一位得到 00111.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;010110&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>我们翻转得到 011111，或者是 000111。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;00011000&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>我们翻转得到 00000000。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20000</code></li>\n\t<li><font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"caret-color: rgb(199, 37, 78); font-size: 12.600000381469727px; background-color: rgb(249, 242, 244);\">s</span></font> 中只包含字符&nbsp;<code>&#39;0&#39;</code>&nbsp;和&nbsp;<code>&#39;1&#39;</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 926&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/\">https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3655.最长的斐波那契子序列的长度",
        "hardRate": "MEDIUM",
        "passRate": "56.98%",
        "problemsUrl": "https://leetcode.cn/problems/Q91FMA/",
        "solutionsUrl": "https://leetcode.cn/problems/Q91FMA/solution",
        "problemsDesc": "<p>如果序列&nbsp;<code>X_1, X_2, ..., X_n</code>&nbsp;满足下列条件，就说它是&nbsp;<em>斐波那契式&nbsp;</em>的：</p>\n\n<ul>\n\t<li><code>n &gt;= 3</code></li>\n\t<li>对于所有&nbsp;<code>i + 2 &lt;= n</code>，都有&nbsp;<code>X_i + X_{i+1} = X_{i+2}</code></li>\n</ul>\n\n<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 <code>arr</code>&nbsp;，找到 <code>arr</code> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回&nbsp;&nbsp;0 。</p>\n\n<p><em>（回想一下，子序列是从原序列&nbsp; <code>arr</code> 中派生出来的，它从 <code>arr</code> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，&nbsp;<code>[3, 5, 8]</code>&nbsp;是&nbsp;<code>[3, 4, 5, 6, 7, 8]</code>&nbsp;的一个子序列）</em></p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,2,3,4,5,6,7,8]\n<strong>输出: </strong>5\n<strong>解释: </strong>最长的斐波那契式子序列为 [1,2,3,5,8] 。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,3,7,11,12,14,18]\n<strong>输出: </strong>3\n<strong>解释</strong>: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 1000</code></li>\n\t<li>\n\t<p><code>1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 873&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/\">https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3656.分割回文串 II",
        "hardRate": "HARD",
        "passRate": "56.53%",
        "problemsUrl": "https://leetcode.cn/problems/omKAoA/",
        "solutionsUrl": "https://leetcode.cn/problems/omKAoA/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code>，请将 <code>s</code> 分割成一些子串，使每个子串都是回文串。</p>\n\n<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;aab&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>只需一次分割就可将&nbsp;s<em> </em>分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;ab&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 132&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/palindrome-partitioning-ii/\">https://leetcode-cn.com/problems/palindrome-partitioning-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3657.最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "64.89%",
        "problemsUrl": "https://leetcode.cn/problems/qJnOS7/",
        "solutionsUrl": "https://leetcode.cn/problems/qJnOS7/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>text1</code> 和&nbsp;<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>\n\n<p>一个字符串的&nbsp;<strong>子序列</strong><em>&nbsp;</em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n\n<ul>\n\t<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>\n</ul>\n\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; \n<strong>输出：</strong>3  \n<strong>解释：</strong>最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = &quot;abc&quot;, text2 = &quot;abc&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = &quot;abc&quot;, text2 = &quot;def&quot;\n<strong>输出：</strong>0\n<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>\n\t<li><code>text1</code> 和&nbsp;<code>text2</code> 仅由小写英文字符组成。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 1143&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3658.交错字符串",
        "hardRate": "MEDIUM",
        "passRate": "47.94%",
        "problemsUrl": "https://leetcode.cn/problems/IY6buf/",
        "solutionsUrl": "https://leetcode.cn/problems/IY6buf/solution",
        "problemsDesc": "<p>给定三个字符串&nbsp;<code>s1</code>、<code>s2</code>、<code>s3</code>，请判断&nbsp;<code>s3</code>&nbsp;能不能由&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code><em>&nbsp;</em><strong>交织（交错）</strong>&nbsp;组成。</p>\n\n<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交织</strong>&nbsp;的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li><b>交织</b> 是 <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> 或者 <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 97&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/interleaving-string/\">https://leetcode-cn.com/problems/interleaving-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3659.不同的子序列",
        "hardRate": "HARD",
        "passRate": "54.49%",
        "problemsUrl": "https://leetcode.cn/problems/21dk04/",
        "solutionsUrl": "https://leetcode.cn/problems/21dk04/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>\n\n<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p>\n\n<p>题目数据保证答案符合 32 位带符号整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>\n如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。\n<strong><u>rabb</u></strong>b<strong><u>it</u></strong>\n<strong><u>ra</u></strong>b<strong><u>bbit</u></strong>\n<strong><u>rab</u></strong>b<strong><u>bit</u></strong></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;babgbag&quot;, t = &quot;bag&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>\n如下图所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 \n<strong><u>ba</u></strong>b<u><strong>g</strong></u>bag\n<strong><u>ba</u></strong>bgba<strong><u>g</u></strong>\n<u><strong>b</strong></u>abgb<strong><u>ag</u></strong>\nba<u><strong>b</strong></u>gb<u><strong>ag</strong></u>\nbabg<strong><u>bag</u></strong>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 115 题相同： <a href=\"https://leetcode-cn.com/problems/distinct-subsequences/\">https://leetcode-cn.com/problems/distinct-subsequences/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3660.不同路径",
        "hardRate": "MEDIUM",
        "passRate": "75.35%",
        "problemsUrl": "https://leetcode.cn/problems/2AoeFn/",
        "solutionsUrl": "https://leetcode.cn/problems/2AoeFn/solution",
        "problemsDesc": "<p>一个机器人位于一个 <code>m x n</code><em>&nbsp;</em>网格的左上角 （起始点在下图中标记为 &ldquo;Start&rdquo; ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 &ldquo;Finish&rdquo; ）。</p>\n\n<p>问总共有多少条不同的路径？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" /></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 7\n<strong>输出：</strong>28</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向下\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 7, n = 3\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 3\n<strong>输出：</strong>6</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 62&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/unique-paths/\">https://leetcode-cn.com/problems/unique-paths/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3661.最小路径和",
        "hardRate": "MEDIUM",
        "passRate": "72.54%",
        "problemsUrl": "https://leetcode.cn/problems/0i0mDW/",
        "solutionsUrl": "https://leetcode.cn/problems/0i0mDW/solution",
        "problemsDesc": "<p>给定一个包含非负整数的 <code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;网格&nbsp;<code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>一个机器人每次只能向下或者向右移动一步。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>输出：</strong>7\n<strong>解释：</strong>因为路径 1&rarr;3&rarr;1&rarr;1&rarr;1 的总和最小。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 64&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3662.三角形最小路径和",
        "hardRate": "MEDIUM",
        "passRate": "73.75%",
        "problemsUrl": "https://leetcode.cn/problems/IlPe0q/",
        "solutionsUrl": "https://leetcode.cn/problems/IlPe0q/solution",
        "problemsDesc": "<p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>\n\n<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点 </strong>在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n<strong>输出：</strong>11\n<strong>解释：</strong>如下面简图所示：\n   <strong>2</strong>\n  <strong>3</strong> 4\n 6 <strong>5</strong> 7\n4 <strong>1</strong> 8 3\n自顶向下的最小路径和为&nbsp;11（即，2&nbsp;+&nbsp;3&nbsp;+&nbsp;5&nbsp;+&nbsp;1&nbsp;= 11）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>triangle = [[-10]]\n<strong>输出：</strong>-10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= triangle.length &lt;= 200</code></li>\n\t<li><code>triangle[0].length == 1</code></li>\n\t<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= triangle[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以只使用 <code>O(n)</code>&nbsp;的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 120&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/triangle/\">https://leetcode-cn.com/problems/triangle/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3663.分割等和子集",
        "hardRate": "EASY",
        "passRate": "48.46%",
        "problemsUrl": "https://leetcode.cn/problems/NUPfPr/",
        "solutionsUrl": "https://leetcode.cn/problems/NUPfPr/solution",
        "problemsDesc": "<p>给定一个非空的正整数数组 <code>nums</code> ，请判断能否将这些数字分成元素和相等的两部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,11,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums<strong> </strong>可以分割成 [1, 5, 5] 和 [11] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>nums<strong> </strong>不可以分为和相等的两部分\n</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 416&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3664.目标和",
        "hardRate": "MEDIUM",
        "passRate": "56.18%",
        "problemsUrl": "https://leetcode.cn/problems/YaVDxD/",
        "solutionsUrl": "https://leetcode.cn/problems/YaVDxD/solution",
        "problemsDesc": "<p>给定一个正整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>向数组中的每个整数前添加&nbsp;<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>\n\n<ul>\n\t<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>\n</ul>\n\n<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1], target = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 494&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/target-sum/\">https://leetcode-cn.com/problems/target-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3665.零钱兑换",
        "hardRate": "MEDIUM",
        "passRate": "52.91%",
        "problemsUrl": "https://leetcode.cn/problems/gaM7Ch/",
        "solutionsUrl": "https://leetcode.cn/problems/gaM7Ch/solution",
        "problemsDesc": "<p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回&nbsp;<code>-1</code>。</p>\n\n<p>你可以认为每种硬币的数量是无限的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code>\n<strong>输出：</strong><code>3</code> \n<strong>解释：</strong>11 = 5 + 5 + 1</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[2]</code>, amount = <code>3</code>\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 2\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= coins.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 322&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/coin-change/\">https://leetcode-cn.com/problems/coin-change/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3666.组合总和 Ⅳ",
        "hardRate": "MEDIUM",
        "passRate": "56.07%",
        "problemsUrl": "https://leetcode.cn/problems/D0F0SV/",
        "solutionsUrl": "https://leetcode.cn/problems/D0F0SV/solution",
        "problemsDesc": "<p>给定一个由 <strong>不同</strong>&nbsp;正整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p>\n\n<p>题目数据保证答案符合 32 位整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], target = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9], target = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 377&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/combination-sum-iv/\">https://leetcode-cn.com/problems/combination-sum-iv/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3667.岛屿的最大面积",
        "hardRate": "MEDIUM",
        "passRate": "68.55%",
        "problemsUrl": "https://leetcode.cn/problems/ZL6zAn/",
        "solutionsUrl": "https://leetcode.cn/problems/ZL6zAn/solution",
        "problemsDesc": "<p>给定一个由&nbsp;<code>0</code> 和 <code>1</code> 组成的非空二维数组&nbsp;<code>grid</code>&nbsp;，用来表示海洋岛屿地图。</p>\n\n<p>一个&nbsp;<strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在水平或者竖直方向上相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>\n\n<p>找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667010-nSGPXz-image.png\" style=\"width: 452px; \" /></p>\n\n<pre>\n<strong>输入: </strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>输出: </strong>6\n<strong>解释: </strong>对于上面这个给定矩阵应返回&nbsp;<code>6</code>。注意答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直的四个方向的 <code>1</code> 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[0,0,0,0,0,0,0,0]]\n<strong>输出: </strong>0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j] is either 0 or 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 695&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/max-area-of-island/\">https://leetcode-cn.com/problems/max-area-of-island/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3668.判断二分图",
        "hardRate": "MEDIUM",
        "passRate": "55.90%",
        "problemsUrl": "https://leetcode.cn/problems/vEAB3K/",
        "solutionsUrl": "https://leetcode.cn/problems/vEAB3K/solution",
        "problemsDesc": "<p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。</p>\n\n<p>给定一个二维数组 <code>graph</code>&nbsp;，表示图，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于&nbsp;<code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>\n\n<ul>\n\t<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>\n\t<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>\n\t<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>\n\t<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>\n</ul>\n\n<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>\n\n<p>如果图是二分图，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" style=\"width: 222px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong><code>不能将节点分割成两个独立的子集，</code>以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" style=\"width: 222px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,3],[0,2],[1,3],[0,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong><code>可以将节点分成两组: {0, 2} 和 {1, 3} 。</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>graph.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= graph[u].length &lt; n</code></li>\n\t<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>\n\t<li><code>graph[u]</code> 不会包含 <code>u</code></li>\n\t<li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li>\n\t<li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 785&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3669.01 矩阵",
        "hardRate": "MEDIUM",
        "passRate": "50.04%",
        "problemsUrl": "https://leetcode.cn/problems/2bCMpM/",
        "solutionsUrl": "https://leetcode.cn/problems/2bCMpM/solution",
        "problemsDesc": "<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code>&nbsp;，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>\n\n<p>两个相邻元素间的距离为 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<strong>输入：</strong>mat =<strong> </strong>[[0,0,0],[0,1,0],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[0,0,0]]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<strong>输入：</strong>mat =<b> </b>[[0,0,0],[0,1,0],[1,1,1]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[1,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>mat[i][j] is either 0 or 1.</code></li>\n\t<li><code>mat</code> 中至少有一个 <code>0&nbsp;</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 542&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/01-matrix/\">https://leetcode-cn.com/problems/01-matrix/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3670.单词接龙",
        "hardRate": "HARD",
        "passRate": "58.71%",
        "problemsUrl": "https://leetcode.cn/problems/om3reC/",
        "solutionsUrl": "https://leetcode.cn/problems/om3reC/solution",
        "problemsDesc": "<p>在字典（单词列表）&nbsp;<code>wordList</code> 中，从单词 <code>beginWord</code><em>&nbsp;</em>和 <code>endWord</code> 的 <strong>转换序列 </strong>是一个按下述规格形成的序列：</p>\n\n<ul>\n\t<li>序列中第一个单词是 <code>beginWord</code> 。</li>\n\t<li>序列中最后一个单词是 <code>endWord</code> 。</li>\n\t<li>每次转换只能改变一个字母。</li>\n\t<li>转换过程中的中间单词必须是字典&nbsp;<code>wordList</code> 中的单词。</li>\n</ul>\n\n<p>给定两个长度相同但内容不同的单词<em> </em><code>beginWord</code><em>&nbsp;</em>和 <code>endWord</code> 和一个字典 <code>wordList</code> ，找到从&nbsp;<code>beginWord</code> 到&nbsp;<code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong> 。如果不存在这样的转换序列，返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>输出：</strong>5\n<strong>解释：</strong>一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>输出：</strong>0\n<strong>解释：</strong>endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 127&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/word-ladder/\">https://leetcode-cn.com/problems/word-ladder/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3671.打开转盘锁",
        "hardRate": "MEDIUM",
        "passRate": "56.93%",
        "problemsUrl": "https://leetcode.cn/problems/zlDJc7/",
        "solutionsUrl": "https://leetcode.cn/problems/zlDJc7/solution",
        "problemsDesc": "<p>一个密码锁由 4&nbsp;个环形拨轮组成，每个拨轮都有 10 个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为&nbsp;<code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n\n<p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p>\n\n<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n\n<p>字符串 <code>target</code> 代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。\n注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [&quot;8888&quot;], target = &quot;0009&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>\n把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;\n<strong>输出：</strong>-1\n<strong>解释：\n</strong>无法旋转到目标数字且不被锁定。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [&quot;0000&quot;], target = &quot;8888&quot;\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;deadends.length &lt;= 500</code></li>\n\t<li><code><font face=\"monospace\">deadends[i].length == 4</font></code></li>\n\t<li><code><font face=\"monospace\">target.length == 4</font></code></li>\n\t<li><code>target</code> <strong>不在</strong> <code>deadends</code> 之中</li>\n\t<li><code>target</code> 和 <code>deadends[i]</code> 仅由若干位数字组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 752&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/open-the-lock/\">https://leetcode-cn.com/problems/open-the-lock/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3672.所有可能的路径",
        "hardRate": "MEDIUM",
        "passRate": "80.90%",
        "problemsUrl": "https://leetcode.cn/problems/bP4bmD/",
        "solutionsUrl": "https://leetcode.cn/problems/bP4bmD/solution",
        "problemsDesc": "<p>给定一个有&nbsp;<code>n</code>&nbsp;个节点的有向无环图，用二维数组&nbsp;<code>graph</code>&nbsp;表示，请找到所有从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的路径并输出（不要求按顺序）。</p>\n\n<p><code>graph</code>&nbsp;的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code>&nbsp;号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a&rarr;b 你就不能从 b&rarr;a ），若为空，就是没有下一个节点了。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg\" style=\"height: 242px; width: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[3],[3],[]]\n<strong>输出：</strong>[[0,1,3],[0,2,3]]\n<strong>解释：</strong>有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg\" style=\"height: 301px; width: 423px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[4,3,1],[3,2,4],[3],[4],[]]\n<strong>输出：</strong>[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1],[]]\n<strong>输出：</strong>[[0,1]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[2],[3],[]]\n<strong>输出：</strong>[[0,1,2,3],[0,2,3],[0,3]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,3],[2],[3],[]]\n<strong>输出：</strong>[[0,1,2,3],[0,3]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; n</code></li>\n\t<li><code>graph[i][j] != i</code>&nbsp;</li>\n\t<li>保证输入为有向无环图 <code>(GAD)</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 797&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/all-paths-from-source-to-target/\">https://leetcode-cn.com/problems/all-paths-from-source-to-target/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3673.除法求值",
        "hardRate": "MEDIUM",
        "passRate": "64.57%",
        "problemsUrl": "https://leetcode.cn/problems/vlzXQL/",
        "solutionsUrl": "https://leetcode.cn/problems/vlzXQL/solution",
        "problemsDesc": "<p>给定一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> 和 <code>values[i]</code> 共同表示等式 <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code> 。每个 <code>A<sub>i</sub></code> 或 <code>B<sub>i</sub></code> 是一个表示单个变量的字符串。</p>\n\n<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>C<sub>j</sub> / D<sub>j</sub> = ?</code> 的结果作为答案。</p>\n\n<p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>\n\n<p><strong>注意：</strong>输入总是有效的。可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\n<strong>输出：</strong>[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>解释：</strong>\n条件：<em>a / b = 2.0</em>, <em>b / c = 3.0</em>\n问题：<em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em>\n结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\n<strong>输出：</strong>[3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\n<strong>输出：</strong>[0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> 由小写英文字母与数字组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 399&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/evaluate-division/\">https://leetcode-cn.com/problems/evaluate-division/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3674.矩阵中的最长递增路径",
        "hardRate": "HARD",
        "passRate": "57.50%",
        "problemsUrl": "https://leetcode.cn/problems/fpTFWP/",
        "solutionsUrl": "https://leetcode.cn/problems/fpTFWP/solution",
        "problemsDesc": "<p>给定一个&nbsp;<code>m x n</code> 整数矩阵&nbsp;<code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p>\n\n<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>输出：</strong>4 \n<strong>解释：</strong>最长递增路径为&nbsp;<code>[1, 2, 6, 9]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>输出：</strong>4 \n<strong>解释：</strong>最长递增路径是&nbsp;<code>[3, 4, 5, 6]</code>。注意不允许在对角线方向上移动。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 329&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/\">https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3675.课程表 II",
        "hardRate": "MEDIUM",
        "passRate": "56.52%",
        "problemsUrl": "https://leetcode.cn/problems/QA2IGt/",
        "solutionsUrl": "https://leetcode.cn/problems/QA2IGt/solution",
        "problemsDesc": "<p>现在总共有 <code>numCourses</code>&nbsp;门课需要选，记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>numCourses-1</code>。</p>\n\n<p>给定一个数组&nbsp;<code>prerequisites</code> ，它的每一个元素&nbsp;<code>prerequisites[i]</code>&nbsp;表示两门课程之间的先修顺序。&nbsp;例如&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示想要学习课程 <code>a<sub>i</sub></code>&nbsp;，需要先完成课程 <code>b<sub>i</sub></code>&nbsp;。</p>\n\n<p>请根据给出的总课程数 &nbsp;<code>numCourses</code> 和表示先修顺序的&nbsp;<code>prerequisites</code>&nbsp;得出一个可行的修课序列。</p>\n\n<p>可能会有多个正确的顺序，只要任意返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> numCourses = 2, prerequisites = [[1,0]] \n<strong>输出: </strong>[0,1]\n<strong>解释:</strong>&nbsp;总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>输出: </strong>[0,1,2,3] or [0,2,1,3]\n<strong>解释:</strong>&nbsp;总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3]。另一个正确的排序是 [0,2,1,3]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> numCourses = 1, prerequisites = [] \n<strong>输出: </strong>[0]\n<strong>解释:</strong>&nbsp;总共 1 门课，直接修第一门课就可。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>\n\t<li><code>ai != bi</code></li>\n\t<li><code>prerequisites</code>&nbsp;中不存在重复元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 210&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/course-schedule-ii/\">https://leetcode-cn.com/problems/course-schedule-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3676.火星词典",
        "hardRate": "HARD",
        "passRate": "49.84%",
        "problemsUrl": "https://leetcode.cn/problems/Jf1JuT/",
        "solutionsUrl": "https://leetcode.cn/problems/Jf1JuT/solution",
        "problemsDesc": "<p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p>\n\n<p>给定一个字符串列表 <code>words</code> ，作为这门语言的词典，<code>words</code> 中的字符串已经 <strong>按这门新语言的字母顺序进行了排序</strong> 。</p>\n\n<p>请你根据该词典还原出此语言中已知的字母顺序，并 <strong>按字母递增顺序</strong> 排列。若不存在合法字母顺序，返回 <code>&quot;&quot;</code> 。若存在多种可能的合法字母顺序，返回其中 <strong>任意一种</strong> 顺序即可。</p>\n\n<p>字符串 <code>s</code> <strong>字典顺序小于</strong> 字符串 <code>t</code> 有两种情况：</p>\n\n<ul>\n\t<li>在第一个不同字母处，如果 <code>s</code> 中的字母在这门外星语言的字母顺序中位于 <code>t</code> 中字母之前，那么&nbsp;<code>s</code> 的字典顺序小于 <code>t</code> 。</li>\n\t<li>如果前面 <code>min(s.length, t.length)</code> 字母都相同，那么 <code>s.length &lt; t.length</code> 时，<code>s</code> 的字典顺序也小于 <code>t</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]\n<strong>输出：</strong>&quot;wertf&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;z&quot;,&quot;x&quot;]\n<strong>输出：</strong>&quot;zx&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>不存在合法字母顺序，因此返回 &quot;&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 269&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/alien-dictionary/\">https://leetcode-cn.com/problems/alien-dictionary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3677.序列重建",
        "hardRate": "MEDIUM",
        "passRate": "51.62%",
        "problemsUrl": "https://leetcode.cn/problems/ur2n8P/",
        "solutionsUrl": "https://leetcode.cn/problems/ur2n8P/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 是范围为 <code>[1，n]</code> 的整数的排列。还提供了一个 2D 整数数组&nbsp;<code>sequences</code>&nbsp;，其中&nbsp;<code>sequences[i]</code>&nbsp;是&nbsp;<code>nums</code>&nbsp;的子序列。<br />\n检查 <code>nums</code> 是否是唯一的最短&nbsp;<strong>超序列</strong> 。最短 <strong>超序列</strong> 是 <strong>长度最短</strong> 的序列，并且所有序列&nbsp;<code>sequences[i]</code>&nbsp;都是它的子序列。对于给定的数组&nbsp;<code>sequences</code>&nbsp;，可能存在多个有效的 <strong>超序列</strong> 。</p>\n\n<ul>\n\t<li>例如，对于&nbsp;<code>sequences = [[1,2],[1,3]]</code>&nbsp;，有两个最短的 <strong>超序列</strong> ，<code>[1,2,3]</code> 和 <code>[1,3,2]</code> 。</li>\n\t<li>而对于&nbsp;<code>sequences = [[1,2],[1,3],[1,2,3]]</code>&nbsp;，唯一可能的最短 <strong>超序列</strong> 是 <code>[1,2,3]</code> 。<code>[1,2,3,4]</code> 是可能的超序列，但不是最短的。</li>\n</ul>\n\n<p><em>如果 <code>nums</code> 是序列的唯一最短 <strong>超序列</strong> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</em><br />\n<strong>子序列</strong> 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2],[1,3]]\n<strong>输出：</strong>false\n<strong>解释：</strong>有两种可能的超序列：[1,2,3]和[1,3,2]。\n序列 [1,2] 是[<u><strong>1,2</strong></u>,3]和[<u><strong>1</strong></u>,3,<u><strong>2</strong></u>]的子序列。\n序列 [1,3] 是[<u><strong>1</strong></u>,2,<u><strong>3</strong></u>]和[<u><strong>1,3</strong></u>,2]的子序列。\n因为 nums 不是唯一最短的超序列，所以返回false。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>最短可能的超序列为 [1,2]。\n序列 [1,2] 是它的子序列：[<u><strong>1,2</strong></u>]。\n因为 nums 不是最短的超序列，所以返回false。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>true\n<strong>解释：</strong>最短可能的超序列为[1,2,3]。\n序列 [1,2] 是它的一个子序列：[<strong>1,2</strong>,3]。\n序列 [1,3] 是它的一个子序列：[<u><strong>1</strong></u>,2,<u><strong>3</strong></u>]。\n序列 [2,3] 是它的一个子序列：[1,<u><strong>2,3</strong></u>]。\n因为 nums 是唯一最短的超序列，所以返回true。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code>&nbsp;是&nbsp;<code>[1, n]</code>&nbsp;范围内所有整数的排列</li>\n\t<li><code>1 &lt;= sequences.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= sequences[i].length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= sum(sequences[i].length) &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= sequences[i][j] &lt;= n</code></li>\n\t<li><code>sequences</code>&nbsp;的所有数组都是 <strong>唯一 </strong>的</li>\n\t<li><code>sequences[i]</code>&nbsp;是&nbsp;<code>nums</code> 的一个子序列</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 444&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/sequence-reconstruction/\">https://leetcode-cn.com/problems/sequence-reconstruction/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3678.省份数量",
        "hardRate": "MEDIUM",
        "passRate": "66.83%",
        "problemsUrl": "https://leetcode.cn/problems/bLyHh0/",
        "solutionsUrl": "https://leetcode.cn/problems/bLyHh0/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>\n\n<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>\n\n<p>返回矩阵中 <strong>省份</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n == isConnected.length</code></li>\n\t<li><code>n == isConnected[i].length</code></li>\n\t<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>\n\t<li><code>isConnected[i][i] == 1</code></li>\n\t<li><code>isConnected[i][j] == isConnected[j][i]</code></li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 547&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/number-of-provinces/\">https://leetcode-cn.com/problems/number-of-provinces/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3679.相似字符串组",
        "hardRate": "HARD",
        "passRate": "61.72%",
        "problemsUrl": "https://leetcode.cn/problems/H6lPxb/",
        "solutionsUrl": "https://leetcode.cn/problems/H6lPxb/solution",
        "problemsDesc": "<p>如果交换字符串&nbsp;<code>X</code> 中的两个不同位置的字母，使得它和字符串&nbsp;<code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>\n\n<p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)；&nbsp;<code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p>\n\n<p>总之，它们通过相似性形成了两个关联组：<code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> 和 <code>{&quot;star&quot;}</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>\n\n<p>给定一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个&nbsp;<strong>字母异位词&nbsp;</strong>。请问 <code>strs</code> 中有多少个相似字符串组？</p>\n\n<p><strong>字母异位词（anagram）</strong>，一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [&quot;omv&quot;,&quot;ovm&quot;]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>\n\t<li><code>strs[i]</code> 只包含小写字母。</li>\n\t<li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li>\n</ul>\n\n<p>&nbsp; &nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 839&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/similar-string-groups/\">https://leetcode-cn.com/problems/similar-string-groups/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3680.冗余连接",
        "hardRate": "MEDIUM",
        "passRate": "69.83%",
        "problemsUrl": "https://leetcode.cn/problems/7LpjUW/",
        "solutionsUrl": "https://leetcode.cn/problems/7LpjUW/solution",
        "problemsDesc": "<p>树可以看成是一个连通且 <strong>无环&nbsp;</strong>的&nbsp;<strong>无向&nbsp;</strong>图。</p>\n\n<p>给定往一棵&nbsp;<code>n</code> 个节点 (节点值&nbsp;<code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code>&nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code>&nbsp;，<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>\n\n<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组&nbsp;<code>edges</code>&nbsp;中最后出现的边。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png\" style=\"width: 152px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2],[1,3],[2,3]]\n<strong>输出:</strong> [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png\" style=\"width: 250px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\n<strong>输出:</strong> [1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= ai&nbsp;&lt; bi&nbsp;&lt;= edges.length</code></li>\n\t<li><code>ai != bi</code></li>\n\t<li><code>edges</code> 中无重复元素</li>\n\t<li>给定的图是连通的&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 684&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/redundant-connection/\">https://leetcode-cn.com/problems/redundant-connection/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3681.最长连续序列",
        "hardRate": "MEDIUM",
        "passRate": "48.10%",
        "problemsUrl": "https://leetcode.cn/problems/WhsWhI/",
        "solutionsUrl": "https://leetcode.cn/problems/WhsWhI/solution",
        "problemsDesc": "<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100,4,200,1,3,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长数字连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>可以设计并实现时间复杂度为&nbsp;<code>O(n)</code><em> </em>的解决方案吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 128&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/\">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3682.寻找文件副本",
        "hardRate": "EASY",
        "passRate": "66.93%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution",
        "problemsDesc": "<p>设备中存有 <code>n</code> 个文件，文件 <code>id</code> 记于数组 <code>documents</code>。若文件 <code>id</code> 相同，则定义为该文件存在副本。请返回任一存在副本的文件 <code>id</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>documents = [2, 5, 3, 0, 5, 0]\n<strong>输出：</strong>0 或 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 ≤ documents[i] ≤ n-1</code></li>\n\t<li><code>2 &lt;= n &lt;= 100000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3683.寻找目标值 - 二维数组",
        "hardRate": "MEDIUM",
        "passRate": "39.53%",
        "problemsUrl": "https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution",
        "problemsDesc": "<p><code>m</code>*<code>n</code> 的二维数组 <code>plants</code> 记录了园林景观的植物排布情况，具有以下特性：</p>\n\n<ul>\n\t<li>每行中，每棵植物的右侧相邻植物不矮于该植物；</li>\n\t<li>每列中，每棵植物的下侧相邻植物不矮于该植物。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>请判断 <code>plants</code> 中是否存在目标高度值 <code>target</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [[2,3,6,8],[4,5,8,9],[5,9,10,12]], target = 8\n\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [[1,3,5],[2,5,7]], target = 4\n\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n</ul>\n\n<p>注意：本题与主站 240 题相同：<a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\" rel=\"noopener noreferrer\" target=\"_blank\">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3684.路径加密",
        "hardRate": "EASY",
        "passRate": "74.89%",
        "problemsUrl": "https://leetcode.cn/problems/ti-huan-kong-ge-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution",
        "problemsDesc": "<p>假定一段路径记作字符串 <code>path</code>，其中以 \"<code>.</code>\" 作为分隔符。现需将路径加密，加密方法为将 <code>path</code> 中的分隔符替换为空格 \"<code> </code>\"，请返回加密后的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"a.aef.qerf.bb\"\n\n<strong>输出：</strong>\"a aef qerf bb\"\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= path.length&nbsp;&lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3685.图书整理 I",
        "hardRate": "EASY",
        "passRate": "73.91%",
        "problemsUrl": "https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution",
        "problemsDesc": "<p>书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [3,6,4,1]\n\n<strong>输出：</strong>[1,4,6,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3686.推理二叉树",
        "hardRate": "MEDIUM",
        "passRate": "70.07%",
        "problemsUrl": "https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>某二叉树的先序遍历结果记录于整数数组 <code>preorder</code>，它的中序遍历结果记录于整数数组 <code>inorder</code>。请根据 <code>preorder</code> 和 <code>inorder</code> 的提示构造出这棵二叉树并返回其根节点。</p>\n\n<p>&nbsp;</p>\n\n<p>注意：<code>preorder</code> 和 <code>inorder</code> 中均不含重复数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n\n<strong>输出: </strong>[3,9,20,null,null,15,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>preorder = [-1], inorder = [-1]\n\n<strong>输出:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n\t<li><code>inorder</code> 均出现在 <code>preorder</code></li>\n\t<li><code>preorder</code> 保证 为二叉树的前序遍历序列</li>\n\t<li><code>inorder</code> 保证 为二叉树的中序遍历序列</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 105 题重复：<a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" rel=\"noopener noreferrer\" target=\"_blank\">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3687.图书整理 II",
        "hardRate": "EASY",
        "passRate": "70.37%",
        "problemsUrl": "https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution",
        "problemsDesc": "<p>读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：</p>\n\n<ul>\n\t<li><code>push(bookID)</code>：把借阅的书籍还到图书馆。</li>\n\t<li><code>pop()</code>：从图书馆中借出书籍。</li>\n</ul>\n\n<p>为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 <strong>最早</strong> 归还到图书馆的书籍。你需要返回 <strong>每次读者借出书的值</strong> 。</p>\n\n<p>如果没有归还的书可以取出，返回&nbsp;<code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"BookQueue\", \"push\", \"push\", \"pop\"]\n[[], [1], [2], []]\n<strong>输出：</strong>[null,null,null,1]\n<strong>解释：\n</strong>MyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.pop(); // return 1, queue is [2]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bookID &lt;= 10000</code></li>\n\t<li>最多会对 <code>push</code>、<code>pop</code> 进行 <code>10000</code> 次调用</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3688.斐波那契数",
        "hardRate": "EASY",
        "passRate": "35.62%",
        "problemsUrl": "https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution",
        "problemsDesc": "<p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <strong>0</strong> 和 <strong>1</strong> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n\n<pre>\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1\n</pre>\n\n<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>\n\n<p>答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>F(2) = F(1) + F(0) = 1 + 0 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>F(3) = F(2) + F(1) = 1 + 1 = 2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>F(4) = F(3) + F(2) = 2 + 1 = 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3689.跳跃训练",
        "hardRate": "EASY",
        "passRate": "45.19%",
        "problemsUrl": "https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution",
        "problemsDesc": "<p>今天的有氧运动训练内容是在一个长条形的平台上跳跃。平台有 <code>num</code> 个小格子，每次可以选择跳 <strong>一个格子</strong> 或者 <strong>两个格子</strong>。请返回在训练过程中，学员们共有多少种不同的跳跃方式。</p>\n\n<p>结果可能过大，因此结果需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 100</code></li>\n</ul>\n\n<p>注意：本题与主站 70 题相同：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">https://leetcode-cn.com/problems/climbing-stairs/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3690.库存管理 I",
        "hardRate": "EASY",
        "passRate": "49.57%",
        "problemsUrl": "https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution",
        "problemsDesc": "<p>仓库管理员以数组 <code>stock</code> 形式记录商品库存表。<code>stock[i]</code> 表示商品 <code>id</code>，可能存在重复。原库存表按商品 <code>id</code> 升序排列。现因突发情况需要进行商品紧急调拨，管理员将这批商品 <code>id</code> 提前依次整理至库存表最后。请你找到并返回库存表中编号的 <strong>最小的元素</strong> 以便及时记录本次调拨。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stock =<strong> </strong>[4,5,8,3,4]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stock = [5,7,9,1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p>提示：</p>\n\n<ul>\n\t<li>1 &lt;= stock.length &lt;= 5000</li>\n\t<li>-5000 &lt;= stock[i] &lt;= 5000</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 154 题相同：<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/\">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3691.字母迷宫",
        "hardRate": "MEDIUM",
        "passRate": "45.72%",
        "problemsUrl": "https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/solution",
        "problemsDesc": "<p>字母迷宫游戏初始界面记作 <code>m x n</code> 二维字符串数组 <code>grid</code>，请判断玩家是否能在 <code>grid</code> 中找到目标单词 <code>target</code>。<br />\n注意：寻找单词时 <strong>必须</strong> 按照字母顺序，通过水平或垂直方向相邻的单元格内的字母构成，同时，同一个单元格内的字母&nbsp;<strong>不允许被重复使用&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], target = \"ABCCED\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], target = \"SEE\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], target = \"ABCB\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n = grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 15</code></li>\n\t<li><code>grid</code> 和 <code>target</code> 仅由大小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 79 题相同：<a href=\"https://leetcode-cn.com/problems/word-search/\">https://leetcode-cn.com/problems/word-search/</a></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3692.衣橱整理",
        "hardRate": "MEDIUM",
        "passRate": "53.56%",
        "problemsUrl": "https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution",
        "problemsDesc": "<p>家居整理师将待整理衣橱划分为 <code>m x n</code> 的二维矩阵 <code>grid</code>，其中 <code>grid[i][j]</code> 代表一个需要整理的格子。整理师自 <code>grid[0][0]</code> 开始 <strong>逐行逐列</strong> 地整理每个格子。</p>\n\n<p>整理规则为：在整理过程中，可以选择&nbsp;<strong>向右移动一格&nbsp;</strong>或&nbsp;<strong>向下移动一格</strong>，但不能移动到衣柜之外。同时，不需要整理 <code>digit(i)&nbsp;+ digit(j)&nbsp;&gt; cnt</code> 的格子，其中 <code>digit(x)</code>&nbsp;表示数字&nbsp;<code>x</code> 的各数位之和。</p>\n\n<p>请返回整理师&nbsp;<strong>总共需要整理多少个格子</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 4, n = 7, cnt = 5\n<strong>输出：</strong>18\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, m &lt;= 100</code></li>\n\t<li><code>0 &lt;= cnt &lt;= 20</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3693.砍竹子 I",
        "hardRate": "MEDIUM",
        "passRate": "57.36%",
        "problemsUrl": "https://leetcode.cn/problems/jian-sheng-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/jian-sheng-zi-lcof/solution",
        "problemsDesc": "<p>现需要将一根长为正整数 <code>bamboo_len</code> 的竹子砍为若干段，每段长度均为正整数。请返回每段竹子长度的最大乘积是多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>bamboo_len<strong> </strong>=<strong> </strong>12\n<strong>输出: </strong>81\n</pre>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>2 &lt;= bamboo_len&nbsp;&lt;= 58</code></li>\n</ul>\n\n<p>注意：本题与主站 343 题相同：<a href=\"https://leetcode-cn.com/problems/integer-break/\">https://leetcode-cn.com/problems/integer-break/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3694.砍竹子 II",
        "hardRate": "MEDIUM",
        "passRate": "31.30%",
        "problemsUrl": "https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/solution",
        "problemsDesc": "<p>现需要将一根长为正整数 <code>bamboo_len</code> 的竹子砍为若干段，每段长度均为 <strong>正整数</strong>。请返回每段竹子长度的 <strong>最大乘积</strong> 是多少。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bamboo_len = 12\n<strong>输出：</strong>81\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= bamboo_len &lt;= 1000</code></li>\n</ul>\n\n<p>注意：本题与主站 343 题相同：<a href=\"https://leetcode-cn.com/problems/integer-break/\">https://leetcode-cn.com/problems/integer-break/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3695.位 1 的个数",
        "hardRate": "EASY",
        "passRate": "76.13%",
        "problemsUrl": "https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution",
        "problemsDesc": "<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为&nbsp;<a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">汉明重量</a>).）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n\t<li>在 Java 中，编译器使用 <a href=\"https://baike.baidu.com/item/二进制补码/5295284\">二进制补码</a> 记法来表示有符号整数。因此，在上面的&nbsp;<strong>示例 3&nbsp;</strong>中，输入表示有符号整数 <code>-3</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11 (控制台输入 00000000000000000000000000001011)\n<strong>输出：</strong>3\n<strong>解释：</strong>输入的二进制串 <code><strong>00000000000000000000000000001011</strong>&nbsp;中，共有三位为 '1'。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 128 (控制台输入 00000000000000000000000010000000)\n<strong>输出：</strong>1\n<strong>解释：</strong>输入的二进制串 <strong>00000000000000000000000010000000</strong>&nbsp;中，共有一位为 '1'。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）\n<strong>输出：</strong>31\n<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 中，共有 31 位为 '1'。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 191 题相同：<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3696.Pow(x, n)",
        "hardRate": "MEDIUM",
        "passRate": "35.19%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution",
        "problemsDesc": "<p>实现&nbsp;<a href=\"https://www.cplusplus.com/reference/valarray/pow/\">pow(<em>x</em>,&nbsp;<em>n</em>)</a>&nbsp;，即计算 x 的 n 次幂函数（即，x<sup>n</sup>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = 10\n<strong>输出：</strong>1024.00000\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.10000, n = 3\n<strong>输出：</strong>9.26100</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = -2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt;&nbsp;x&nbsp;&lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= n &lt;=&nbsp;2<sup>31</sup>-1</code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= x<sup>n</sup>&nbsp;&lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 50 题相同：<a href=\"https://leetcode-cn.com/problems/powx-n/\">https://leetcode-cn.com/problems/powx-n/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3697.报数",
        "hardRate": "EASY",
        "passRate": "77.61%",
        "problemsUrl": "https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution",
        "problemsDesc": "<p>实现一个十进制数字报数程序，请按照数字从小到大的顺序返回一个整数数列，该数列从数字 <code>1</code> 开始，到最大的正整数 <code>cnt</code> 位数字结束。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cnt = 2\n<strong>输出：</strong>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99]</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3698.删除链表的节点",
        "hardRate": "EASY",
        "passRate": "59.17%",
        "problemsUrl": "https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution",
        "problemsDesc": "<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>\n\n<p>返回删除后的链表的头节点。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [4,5,1,9], val = 5\n<strong>输出：</strong>[4,1,9]\n<strong>解释：</strong>给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [4,5,1,9], val = 1\n<strong>输出：</strong>[4,5,9]\n<strong>解释：</strong>给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>题目保证链表中节点的值互不相同</li>\n\t<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3699.模糊搜索验证",
        "hardRate": "HARD",
        "passRate": "38.11%",
        "problemsUrl": "https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution",
        "problemsDesc": "<p>请设计一个程序来支持用户在文本编辑器中的模糊搜索功能。用户输入内容中可能使用到如下两种通配符：</p>\n\n<ul>\n\t<li><code>'.'</code> 匹配任意单个字符。</li>\n\t<li><code>'*'</code> 匹配零个或多个前面的那一个元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>请返回用户输入内容 <code>input</code> 所有字符是否可以匹配原文字符串 <code>article</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>article = \"aa\", input = \"a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\"a\" 无法匹配 \"aa\" 整个字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>article = \"aa\", input = \"a*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>article = \"ab\", input = \".*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= article.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= input.length &lt;= 20</code></li>\n\t<li><code>article</code> 只包含从 <code>a-z</code> 的小写字母。</li>\n\t<li><code>input</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code> 。</li>\n\t<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 10&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/regular-expression-matching/\">https://leetcode-cn.com/problems/regular-expression-matching/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3700.有效数字",
        "hardRate": "MEDIUM",
        "passRate": "24.81%",
        "problemsUrl": "https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution",
        "problemsDesc": "<p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>若干空格</li>\n\t<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>\n\t<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>\n\t<li>若干空格</li>\n</ol>\n\n<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>下述格式之一：\n\t<ol>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>\n\t\t<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>\n\t</ol>\n\t</li>\n</ol>\n\n<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>至少一位数字</li>\n</ol>\n\n<p>部分有效数字列举如下：<code>[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]</code></p>\n\n<p>部分无效数字列举如下：<code>[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]</code></p>\n\n<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"e\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \".\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，空格 <code>' '</code> 或者点 <code>'.'</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    }
]